# CPS Continuation Specifications
# Generated from analysis of fn/rewrite/cps5.fn
#
# Each continuation represents a point where the CPS transform algorithm
# needs to create a closure to capture the continuation of a computation.
#
# Note: Only T_k transformations need continuation scaffolding.
# T_c transformations pass MinExp* as regular function parameters.

config:
  name: cps_kont
  description: "Continuation scaffolding for CPS transform"
  parserInfo: false
  currency: MinExp
  includes:
    - minlam.h
  limited_includes:
    - minlam_debug.h

primitives: !include ../src/primitives.yaml

external:
  MinExp:
    meta:
      brief: Minbda expressions
    data:
      cname: "struct MinExp *"
      printFn: printMinExp
      markFn: markMinExp
      valued: true
  MinArgs:
    meta:
      brief: List of MinExp
    data:
      cname: "struct MinArgs *"
      printFn: printMinArgs
      markFn: markMinArgs
      valued: true
  MinBindings:
    meta:
      brief: List of MinBindings
    data:
      cname: "struct MinBindings *"
      printFn: printMinBindings
      markFn: markMinBindings
      valued: true
  MinCondCases:
    meta:
      brief: List of MinCondCases
    data:
      cname: "struct MinCondCases *"
      printFn: printMinCondCases
      markFn: markMinCondCases
      valued: true
  MinMatchList:
    data:
      cname: "struct MinMatchList *"
      printFn: printMinMatchList
      markFn: markMinMatchList
      valued: true
  MinPrimOp:
    data:
      cname: "enum MinPrimOp"
      printf: "%d"
      valued: true
  MinSequence:
    data:
      cname: "struct MinSequence *"
      printFn: printMinSequence
      markFn: markMinSequence
      valued: true

# Naming convention, since each kont is argument to T_k and never
# to T_c, we use Tk for continuations constructed by T_k, and
# Tc for continuations constructed by T_c.
# If there are multiple continuations constructed in a case, we
# suffix them 1, 2 ecc. in the order they appear textually in
# the source.
continuations:
  TkIff:
    transformer: T_k
    key: k_if
    context: |
      fn T_k(e, k) {
          ...
          switch (e) {
              (E.if_expr(exprc, exprt, exprf)) {
                  let
                      c = kToC(k);
                  in 
                      T_k(exprc, fn(aexp) {
                          E.if_expr(aexp, T_c(exprt, c), T_c(exprf, c))
                      })
              }
          }
      }
    free_vars:
      c: MinExp
      exprt: MinExp
      exprf: MinExp

  TcIff:
    transformer: T_k
    key: c_if
    context: |
      fn T_c(e, c) {
        ...
        switch (e) {
          (E.if_expr(exprc, exprt, exprf)) {
            let
              sk = gensym("$k");
            in
              E.apply(E.lambda([sk], T_k(exprc, fn (aexp) {
                E.if_expr(aexp, T_c(exprt,sk), T_c(exprf,sk))
              })), [c])
          }
        }
      }
    free_vars:
      sk: MinExp
      exprt: MinExp
      exprf: MinExp

  TcApply1:
    transformer: T_k
    key: c_apply_1
    context: |
      fn T_c(e, c) {
          ...
          switch(e) {
              (E.apply(f, es)) {
                  T_k(f, fn(sf) {
                      Ts_k(es, fn (ses) {E.apply(sf, ses @@ [c])})
                  })
              }
          }
      }
    free_vars:
      es: MinArgs
      c: MinExp

  TcApply2:
    transformer: T_k
    key: c_apply_2
    context: |
      fn T_c(e, c) {
          ...
          switch(e) {
              (E.apply(f, es)) {
                  T_k(f, fn(sf) {
                      Ts_k(es, fn (ses) {E.apply(sf, ses @@ [c])})
                  })
              }
          }
      }
    free_vars:
      sf: MinExp
      c: MinExp

  TkCond:
    transformer: T_k
    key: k_cond
    context: |
      fn T_k(e, k) {
          ...
          switch (e) {
              (E.cond_expr(test, branches)) {
                  let
                      c = kToC(k);
                  in
                      T_k(test, fn (atest) {
                          E.cond_expr(atest, list.map(fn {(#(val, result)) {
                              #(val, T_c(result, c))
                          }}, branches))
                      })
              }
          }
      }
    free_vars:
      c: MinExp
      branches: MinCondCases

  TcCond:
    transformer: T_k
    key: c_cond
    context: |
      fn T_c(expr, c) {
          ...
          switch(expr) {
              (E.cond_expr(test, branches)) {
                  let
                      sk = gensym("$k");
                  in
                      E.apply(E.lambda([sk], T_k(test, fn (atest) {
                          E.cond_expr(atest, list.map(fn {(#(val, result)) {
                              #(val, T_c(result, sk))
                          }}, branches))
                      })), [c])
              }
          }
      }
    free_vars:
      sk: MinExp
      branches: MinCondCases

  TkS1:
    transformer: T_k
    key: k_s1
    context: |
      fn Ts_k {
          ([], k) { k([]) }
          (h @ t, k) {
              T_k(h, fn (hd) {
                  Ts_k(t, fn (tl) {
                      k(hd @ tl)
                  })
              })
          }
      }
    free_vars:
      t: MinArgs
      k: CpsKont

  TkS2:
    transformer: T_k
    key: k_s2
    context: |
      fn Ts_k {
          ([], k) { k([]) }
          (h @ t, k) {
              T_k(h, fn (hd) {
                  Ts_k(t, fn (tl) {
                      k(hd @ tl)
                  })
              })
          }
      }
    free_vars:
      k: CpsKont
      hd: MinExp

  TcCallCC:
    transformer: T_k
    key: c_callCC
    context: |
      (E.callCC_expr(e)) {
          T_k(e, fn (sf) {
              E.apply(
                  E.parse("(lambda (f cc) (f (lambda (x i) (cc x)) cc))"),
                  [sf, c]
              )
          })
      }
    free_vars:
      c: MinExp

  TkMakeVec:
    transformer: T_k
    key: k_makevec
    context: |
      (E.make_vec(size, args)) {
        Ts_k(args, fn (sargs) {
          k(E.make_vec(size, sargs))
        })
      }
    free_vars:
      k: CpsKont

  TcMakeVec:
    transformer: T_k
    key: c_makevec
    context: |
      (E.make_vec(size, args)) {
        Ts_k(args, fn (sargs) {
          E.apply(c, [E.make_vec(size, sargs)])
        })
      }
    free_vars:
      c: MinExp

  TkMatch:
    transformer: T_k
    key: k_match
    context: |
      (E.match_cases(test, cases)) {
        let
          c = kToC(k);
        in
          T_k(test, fn (atest) {
            E.match_cases(atest, list.map(fn {(#(indices, result)) {
              #(indices, T_c(result, c))
            }}, cases))
          })
        }
    free_vars:
      c: MinExp
      cases: MinMatchList

  TcMatch:
    transformer: T_k
    key: c_match
    context: |
      (E.match_cases(test, cases)) {
        let
          sk = gensym("$k");
        in
          E.apply(E.lambda([sk], T_k(test, fn (atest) {
            E.match_cases(atest, list.map(fn {(#(indices, result)) {
              #(indices, T_c(result, sk))
            }}, cases))
          })), [c])
      }
    free_vars:
      sk: MinExp
      cases: MinMatchList

  TkNameSpaces:
    transformer: T_k
    key: k_nameSpaces
    context: |
      (E.nameSpaces(exprs)) {
        Ta_k(exprs, fn (sexprs) {
          k(E.nameSpaces(sexprs))
        })
      }
    free_vars:
      k: CpsKont

  TcNameSpaces:
    transformer: T_k
    key: c_nameSpaces
    context: |
      (E.nameSpaces(exprs)) {
        Ts_k(exprs, fn (sexprs) {
          E.apply(c, [E.nameSpaces(sexprs)])
        })
      }
    free_vars:
      c: MinExp

  TkPrimApp1:
    transformer: T_k
    key: k_primapp1
    context: |
      (E.primapp(p, e1, e2)) {
        T_k(e1, fn (s1) { //////////////////
          T_k(e2, fn (s2) {
            k(E.primapp(p, s1, s2))
          })
        }) /////////////////////////////////
      }
    free_vars:
      k: CpsKont
      e2: MinExp
      p: MinPrimOp

  TkPrimApp2:
    transformer: T_k
    key: k_primapp2
    context: |
      (E.primapp(p, e1, e2)) {
        T_k(e1, fn (s1) {
          T_k(e2, fn (s2) { ////////////////
            k(E.primapp(p, s1, s2))
          }) ///////////////////////////////
        })
      }
    free_vars:
      k: CpsKont
      s1: MinExp
      p: MinPrimOp

  TcPrimApp1:
    transformer: T_k
    key: c_primapp1
    context: |
      (E.primapp(p, e1, e2)) {
        T_k(e1, fn (s1) { ////////////////////////////
          T_k(e2, fn (s2) {
            E.apply(c, [E.primapp(p, s1, s2)])
          })
        }) ///////////////////////////////////////////
      }
    free_vars:
      c: MinExp
      e2: MinExp
      p: MinPrimOp

  TcPrimApp2:
    transformer: T_k
    key: c_primapp2
    context: |
      (E.primapp(p, e1, e2)) {
        T_k(e1, fn (s1) {
          T_k(e2, fn (s2) { //////////////////////////
            E.apply(c, [E.primapp(p, s1, s2)])
          }) /////////////////////////////////////////
        })
      }
    free_vars:
      c: MinExp
      s1: MinExp
      p: MinPrimOp

  TkSequence:
    transformer: T_k
    key: k_sequence
    context: |
      (E.sequence([expr])) { T_k(expr, k) }
      (E.sequence(expr @ exprs)) {
        T_k(expr, fn (ignored) {
          T_k(E.sequence(exprs), k)
        })
      }
    free_vars:
      k: CpsKont
      exprs: MinSequence

  TcSequence:
    transformer: T_k
    key: c_sequence
    context: |
      (E.sequence([expr])) { T_c(expr, c) }
      (E.sequence(expr @ exprs)) {
        T_k(expr, fn (ignored) {
          T_c(E.sequence(exprs), c)
        })
      }
    free_vars:
      c: MinExp
      exprs: MinSequence
