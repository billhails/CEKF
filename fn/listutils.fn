namespace

// member: #a -> list(#a) -> bool
fn member {
    (_, []) { false }
    (x, x @ _) { true }
    (x, _ @ t) { member(x, t) }
}

// unique: list(#a) -> list(#a)
fn unique(lst) {
    let
        fn helper {
            ([], acc) { reverse(acc) }
            (h @ t, acc) {
                if (member(h, acc)) {
                    helper(t, acc)
                } else {
                    helper(t, h @ acc)
                }
            }
        }
    in
        helper(lst, [])
}

// exclude: list(#t) -> list(#t) -> list(#t)
fn exclude(items, lst) {
    let
        fn helper {
            ([], acc) { reverse(acc) }
            (h @ t, acc) {
                if (member(h, items)) {
                    helper(t, acc)
                } else {
                    helper(t, h @ acc)
                }
            }
        }
    in
        helper(lst, [])
}

// map: (#a -> #b) -> list(#a) -> list(#b)
fn map (f, lst) {
    map_prefix(f, lst, [])
}

// for_each: (#a -> #b) -> list(#a) -> list(#b)
// like map but guarantees l-r application of f (for side effects)
fn for_each(f, lst) {
    let
        fn helper {
            ([], acc) { reverse(acc) }
            (h @ t, acc) {
                let fh = f(h);
                in helper(t, fh @ acc)
            }
        }
    in
        helper(lst, [])
}

// map_prefix: (#a -> #b) -> list(#a) -> list(#b) -> list(#b)
fn map_prefix (f, lst, pfx) {
    let
        fn helper {
            ([], acc) { reverse(acc) }
            (h @ t, acc) { helper(t, f(h) @ acc) }
        }
    in
        helper(lst, pfx)
}

// length: list(#s) -> number
fn length(lst) {
    let fn helper {
        ([], n) { n }
        (_ @ t, n) { helper(t, n + 1) }
    }
    in helper(lst, 0)
}

// foldl (#a -> #b -> #b) -> #b -> list(#a) -> #b
fn foldl {
    (_, acc, []) { acc }
    (func, acc, h @ t) { foldl(func, func(h, acc), t) }
}

// foldr (#a -> #b -> #b) -> #b -> list(#a) -> #b
fn foldr(func, acc, lst) {
    foldl(func, acc, reverse(lst))
}

// foldl1 (#a -> #a -> #a) -> list(#a) -> #a
unsafe fn foldl1 (func, h @ t) {
    foldl(func, h, t)
}

// foldr1 (#a -> #a -> #a) -> list(#a) -> #a
fn foldr1(func, lst) {
    foldl1(func, reverse(lst))
}

// reverse: list)#a) -> list(#a)
fn reverse (lst) {
    foldl(fn (elem, acc) { elem @ acc }, [], lst)
}

// scanl: (#a -> #b -> #b) -> #a-> list(#a) -> list(list(#b))
fn scanl (func, acc, lst) {
    let unsafe fn scan {
        (acc, []) { acc }
        (acc = acc_h @ _, lst_h @ lst_t) { scan(func(lst_h, acc_h) @ acc, lst_t) }
    }
    in scan([acc], lst)
}

// filter: (#a -> bool) -> list(#a) -> list(#a)
fn filter(f, lst) {
    let
        fn helper {
            ([], acc) { reverse(acc) }
            (h @ t, acc) {
                if (f(h)) {
                    helper(t, h @ acc)
                } else {
                    helper(t, acc)
                }
            }
        }
    in
        helper(lst, [])
}

// filter_not: (#a -> bool) -> list(#a) -> list(#a)
fn filter_not (f, l) {
    filter(fn (x) { not f(x) }, l)
}

// indices: (#a -> bool) -> list(#a) -> list(number)
// like filter but returns the indices of the matching elements
fn indices(f, lst) {
    let fn helper {
        ([], _, acc) { reverse(acc) }
        (h @ t, n, acc) {
            if (f(h)) {
                helper(t, n + 1, n @ acc)
            } else {
                helper(t, n + 1, acc)
            }
        }
    }
    in helper(lst, 0, [])
}

// nths: list(number) -> list(#a) -> list(#a)
fn nths (indices, lst) {
    map(fn (n) { nth(n, lst) }, indices)
}

// except_nth: number -> list(#a) -> list(#a)
fn except_nth (index, lst) {
    let fn helper {
        ([], _, acc) { reverse(acc) }
        (h @ t, n, acc) {
            if (n == index) {
                helper(t, n + 1, acc)
            } else {
                helper(t, n + 1, h @ acc)
            }
        }
    }
    in helper(lst, 0, [])
}

// concat: list(list(#a)) -> list(#a)
fn concat(lst) {
    foldr(fn (elem, acc) { elem @@ acc }, [], lst)
}

// join: list(#a) -> list(list(#a)) -> list(#a)
fn join(sep, lst) {
    foldr(fn {
        (elem, []) { elem }
        (elem, acc) { elem @@ sep @@ acc }
    }, [], lst)
}

// any: (#a -> bool) -> list(#a) -> bool
fn any {
    (_, []) { false }
    // this is TCO because "or" is short-circuiting
    (f, h @ t) { f(h) or any(f, t) }
}

// none: (#a -> bool) -> list(#a) -> bool
fn none(f, l) {
    not any(f, l)
}

// all: (#a -> bool) -> list(#a) -> bool
fn all {
    (_, []) { true }
    // this is TCO because "and" is short-circuiting
    (f, h @ t) { f(h) and all(f, t) }
}

// repeat_prefix: number -> #a -> list(#a) -> list(#a)
// repeat_prefix(n, item, list) is a more efficient way of doing repeat(n, item) @@ list
fn repeat_prefix(n, v, tail) {
    let fn helper {
        (0, acc) { acc }
        (n, acc) { helper(n - 1, v @ acc) }
    }
    in helper(n, tail)
}

// repeat: number -> #a -> list(#a)
fn repeat (n, v) {
    repeat_prefix(n, v, [])
}

// nth: number -> list(#a) -> #a
unsafe fn nth {
    (0, h @ _) { h }
    (n, _ @ t) { nth(n - 1, t) }
}

// sum: list(number) -> number
fn sum(lst) {
    foldl(fn (elm, acc) { elm + acc }, 0, lst)
}

// product: list(number) -> number
fn product(lst) {
    foldl(fn (elm, acc) { elm * acc }, 1, lst)
}

// zip: list(#a) -> list(#b) -> list(#(#a, #b))
fn zip(a, b) {
    zip_with(fn (x, y) { #(x, y) }, a, b)
}

// zipwith: (#a -> #b -> #c) -> list(#a) -> list(#b) -> list(#c)
fn zip_with(f, a, b) {
    let
        fn helper {
            (h1 @ t1, h2 @ t2, acc) {
                helper(t1, t2, f(h1, h2) @ acc)
            }
            (_, _, acc) { reverse(acc) }
        }
    in
        helper(a, b, [])
}

// unzip: list(#(#a, #b)) -> #(list(#a), list(#b))
fn unzip {
    ([]) { #([], []) }
    (#(x, y) @ rest) {
        switch (unzip(rest)) {
            (#(xs, ys)) { #(x @ xs, y @ ys) }
        }
    }
}

// last: list(#a) -> #a
unsafe fn last {
    ([a]) { a }
    (_ @ t) { last(t) }
}

// empty: list(#a) -> bool
fn empty {
    ([]) { true }
    (_) { false }
}

// take: number -> list(#a) -> list(#a)
fn take(n, lst) {
    let
        fn helper {
            (0, _, acc) { reverse(acc) }
            (n, [], acc) { reverse(acc) }
            (n, h @ t, acc) { helper(n - 1, t, h @ acc) }
        }
    in
        helper(n, lst, [])
}

// drop: number -> list(#a) -> list(#a)
fn drop {
    (0, l) { l }
    (n, []) { [] }
    (n, _ @ t) { drop(n - 1, t) }
}

// minimum: list(#a) -> #a
fn minimum(lst) {
    foldl1(fn (elem, acc) { if (elem < acc) { elem } else { acc } }, lst)
}

// maximum: list(#a) -> #a
fn maximum(lst) {
    foldl1(fn (elem, acc) { if (elem > acc) { elem } else { acc } }, lst)
}

// range: number -> number -> list(number)
fn range(low, high) {
    let
        fn helper(h, acc) {
            if (h < low) {
                acc
            } else {
                helper(h - 1, h @ acc)
            }
        }
    in
        helper(high, [])
}

// dedup: list(#a) -> list(#a)
fn dedup(lst) {
    unique(lst)
}

// sortBy: (#a -> #a -> cmp) -> list(#a) -> list(#a)
fn sortBy(predicate, lst) {
    let
        fn full_sort {
            ([]) { [] }
            (first @ rest) {
                partition(first, rest, fn (lesser, greater) {
                    partial_sort(lesser, first @ full_sort(greater))
                })
            }
        }
        fn partial_sort {
            (first @ rest, already_sorted) {
                partition(first, rest, fn (lesser, greater) {
                    partial_sort(lesser, first @ partial_sort(greater, already_sorted))
                })
            }
            ([], already_sorted) { already_sorted }
        }
        fn partition(key, lst, kont) {
            let fn helper {
                ([], lesser, greater) { kont(lesser, greater) }
                (first @ rest, lesser, greater) {
                    if (predicate(key, first) == lt) {
                        helper(rest, lesser, first @ greater)
                    } else {
                        helper(rest, first @ lesser, greater)
                    }
                }
            }
            in helper(lst, [], [])
        }
    in
        full_sort(lst)
}

// sort: list(#a) -> list(#a)
fn sort(l) { sortBy(fn (a, b) { a <=> b }, l) }
