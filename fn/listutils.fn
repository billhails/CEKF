fn member {
    (_, []) { false }
    (x, x @ _) { true }
    (x, _ @ t) { member(x, t) }
}

fn map {
    (_, []) { [] }
    (func, h @ t) { func(h) @ map(func, t)) }
}

fn length {
    ([]) { 0 }
    (_ @ t) { 1 + length(t) }
}

fn foldl {
    (_, [], acc) { acc }
    (func, h @ t, acc) { foldl(func, t, func(h, acc)) }
}

fn foldr(func, lst, acc) {
    foldl(func, reverse(lst), acc)
}

fn reverse (lst) {
    foldl((elem, acc) { elem @ acc }, lst, [])
}

fn filter {
    (_, []) { [] }
    (func, h @ t) {
        if (func(h)) {
            h @ filter(func, t)
        } else {
            filter(func, t)
        }
    }
}

fn fill {
    (0, _) { [] }
    (n, v) { v @ fill(n - 1, v) }
}

fn nth {
    (0, h @ _) { h }
    (n, _ @ t) { nth(n - 1, t) }
}

fn sum(lst) {
    foldl(fn (elm, acc) { elm + acc }, lst, 0)
}

fn range(low, high) {
    if (low >= high) { [] }
    else { low @ range(low + 1, high) }
}

fn partition(p, l, k) {
    let fn helper {
        ([], lesser, greater) { k(lesser, greater) }
        (h @ t, lesser, greater) {
            if (p < h) {
                partition(t, lesser, h @ greater)
            } else {
                partition(t, h @ lesser, greater)
            }
        }
    }
    in helper(l, [], [])
}

fn sort_h {
    (h @ t, sorted) {
        partition(h, t, fn (lesser, greater) { sort_h(lesser, h @ sort_h(greater, sorted)) }
    }
    ([], sorted) { sorted }
}

fn sort {
    ([]) { [] }
    (h @ t) {
        partition(h, t, fn (lesser, greater) { sort_h(lesser, h @ sort(greater)) })
    }
}
