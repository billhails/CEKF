namespace
    // minexpr: somewhat reduced expression set output by desugaring and used by later passes
    link "../listutils.fn" as list;
    import list operator "_|>_";

    typedef expr {
        amb_expr(expr, expr) |
        apply_closure(expr, list(expr)) |
        apply(expr, list(expr)) |
        back_expr |
        bigint(number) |
        callcc_expr(expr) |
        character(char) |
        cond_expr(expr, list(#(expr, expr))) |
        env_ref(expr, string) |
        if_expr(expr, expr, expr) |
        lambdac(list(string), expr) |
        lambda(list(string), expr) |
        letrec_expr(list(#(string, #(expr, number))), expr) |
        make_closure(expr, expr) |
        make_env(list(#(string, expr))) |
        make_vec(number, list(expr)) |
        match_cases(expr, list(#(list(number), expr))) |
        primop(string) |
        sequence(list(expr)) |
        stdint(number) |
        var(string)
    }

    // Pretty-printer for expressions.
    // indent_width: number of spaces per depth level (e.g. 2 or 4).
    fn print_expr_depth(indent_width, x) {
        let
            fn put_indent(depth) {
                let
                    fn spaces(i) {
                        if (i > 0) { putc(' '); spaces(i - 1) } else { "" }
                    }
                in {
                    putc('\n');
                    spaces(depth * indent_width)
                }
            }

            // Returns true when an expression can be printed on a single line.
            fn all_simple {
                ([])     { true }
                (h @ t)  { if (is_simple(h)) { all_simple(t) } else { false } }
            }

            fn all_simple_bindings {
                ([])                { true }
                (#(_, e) @ t)       { if (is_simple(e)) { all_simple_bindings(t) } else { false } }
            }

            fn is_simple {
                (var(_))         { true }
                (stdint(_))      { true }
                (bigint(_))      { true }
                (primop(_))      { true }
                (character(_))   { true }
                (back_expr)      { true }
                (env_ref(_, _))  { true }
                (apply(f, args)) { if (is_simple(f)) { all_simple(args) } else { false } }
                (_)              { false }
            }

            // Like the old print_list, but putter is always a plain 1-arg fn.
            // Callers capture depth via closure when needed.
            fn go_list(items, putter, space) {
                switch (items) {
                    ([]) { "" }
                    (h @ t) {
                        putter(h);
                        list.for_each(fn(i) { puts(space); putter(i) }, t);
                        ""
                    }
                };
            }

            fn go_bindings(depth, bindings) {
                list.for_each(fn(#(name, #(e, arity))) {
                    put_indent(depth + 1);
                    putc('(');
                    puts(name);
                    put_indent(depth + 2);
                    go(depth + 2, e);
                    puts(" [");
                    putn(arity);
                    puts("])");
                }, bindings);
            }

            fn go_let(depth, name, bindings, body) {
                puts("(");
                puts(name);
                puts(" [");
                go_bindings(depth, bindings);
                put_indent(depth);
                puts("]");
                put_indent(depth + 1);
                go(depth + 1, body);
                puts(")");
            }

            fn go_sequence(depth, exprs) {
                list.for_each(fn(e) { put_indent(depth + 1); go(depth + 1, e) }, exprs)
            }

            fn go (depth, x) {
                switch (x) {
                    (lambdac(args, e)) {
                        puts("(λ* (");
                        go_list(args, puts, " ");
                        puts(")");
                        put_indent(depth + 1);
                        go(depth + 1, e);
                        puts(")");
                        x;
                    }
                    (make_closure(func, env)) {
                        puts("[CLO");
                        put_indent(depth + 1);
                        go(depth + 1, func);
                        put_indent(depth + 1);
                        go(depth + 1, env);
                        puts("]");
                        x;
                    }
                    (make_env(bindings)) {
                        let
                            fn print_binding(sep, d, name, e) {
                                puts(sep);
                                puts(name);
                                switch (e) {
                                    (var(name2)) {
                                        if (name == name2) { "" }
                                        else { puts(": "); go(d, e); "" }
                                    }
                                    (_) { puts(": "); go(d, e); "" }
                                }
                            }
                        in
                        if (all_simple_bindings(bindings)) {
                            puts("{ ");
                            switch (bindings) {
                                ([]) { "" }
                                (#(name, e) @ rest) {
                                    print_binding("", depth, name, e);
                                    list.for_each(fn(#(n, ev)) { print_binding(", ", depth, n, ev) }, rest);
                                }
                            };
                            puts(" }");
                        } else {
                            puts("{");
                            list.for_each(fn(#(name, e)) {
                                put_indent(depth + 1);
                                print_binding("", depth + 1, name, e);
                            }, bindings);
                            put_indent(depth);
                            puts("}");
                        };
                        x;
                    }
                    (env_ref(env, name)) {
                        go(depth, env);
                        puts("->");
                        puts(name);
                        x;
                    }
                    (apply_closure(closure, args)) {
                        puts("(A/C");
                        put_indent(depth + 1);
                        go(depth + 1, closure);
                        go_sequence(depth, args);
                        puts(")");
                        x;
                    }
                    (callcc_expr(e)) {
                        puts("(call/cc");
                        put_indent(depth + 1);
                        go(depth + 1, e);
                        puts(")");
                        x;
                    }
                    (stdint(i)) {
                        putn(i);
                        x;
                    }
                    (sequence(exprs)) {
                        puts("(begin");
                        go_sequence(depth, exprs);
                        puts(")");
                        x;
                    }
                    (match_cases(exp, cases)) {
                        puts("(match-cases");
                        put_indent(depth + 1);
                        go(depth + 1, exp);
                        list.for_each(fn(#(indices, caseExpr)) {
                            put_indent(depth + 1);
                            puts("((");
                            go_list(indices, fn(i) { putn(i) }, " ");
                            puts(")");
                            put_indent(depth + 2);
                            go(depth + 2, caseExpr);
                            puts(")");
                        }, cases);
                        puts(")");
                        x;
                    }
                    (make_vec(size, elements)) {
                        puts("(make-vec ");
                        putn(size);
                        go_sequence(depth, elements);
                        puts(")");
                        x;
                    }
                    (cond_expr(test, branches)) {
                        puts("(cond");
                        put_indent(depth + 1);
                        go(depth + 1, test);
                        list.for_each(fn(#(e1, e2)) {
                            put_indent(depth + 1);
                            putc('(');
                            go(depth + 2, e1);
                            put_indent(depth + 2);
                            go(depth + 2, e2);
                            puts(")");
                        }, branches);
                        puts(")");
                        x;
                    }
                    (letrec_expr(bindings, body)) {
                        go_let(depth, "letrec", bindings, body);
                        x;
                    }
                    (lambda(args, e)) {
                        puts("(λ (");
                        go_list(args, fn(name) { puts(name) }, " ");
                        puts(")");
                        put_indent(depth + 1);
                        go(depth + 1, e);
                        puts(")");
                        x;
                    }
                    (if_expr(e1, e2, e3)) {
                        puts("(if");
                        put_indent(depth + 1);
                        go(depth + 1, e1);
                        put_indent(depth + 1);
                        go(depth + 1, e2);
                        put_indent(depth + 1);
                        go(depth + 1, e3);
                        puts(")");
                        x;
                    }
                    (apply(e1, args)) {
                        if (is_simple(x)) {
                            puts("(");
                            go(depth, e1);
                            list.for_each(fn(e) { puts(" "); go(depth, e) }, args);
                            puts(")");
                        } else if (is_simple(e1)) {
                            puts("(");
                            go(depth, e1);
                            switch (args) {
                                ([]) { "" }
                                (h @ t) {
                                    puts(" ");
                                    go(depth + 1, h);
                                    list.for_each(fn(e) { put_indent(depth + 1); go(depth + 1, e) }, t);
                                }
                            };
                            puts(")");
                        } else {
                            puts("(");
                            go(depth + 1, e1);
                            go_sequence(depth, args);
                            puts(")");
                        };
                        x;
                    }
                    (bigint(i)) {
                        putn(i);
                        x;
                    }
                    (var(chars)) {
                        puts(chars);
                        x;
                    }
                    (amb_expr(e1, e2)) {
                        puts("(amb");
                        put_indent(depth + 1);
                        go(depth + 1, e1);
                        put_indent(depth + 1);
                        go(depth + 1, e2);
                        puts(")");
                        x;
                    }
                    (back_expr) {
                        puts("(back)");
                        x;
                    }
                    (character(c)) {
                        putc('\'');
                        putc(c);
                        putc('\'');
                        x;
                    }
                    (primop(name)) {
                        puts(name);
                        x;
                    }
                }
            }
        in
            go(0, x)
    }

    fn print_expr(x) { print_expr_depth(2, x) }

    // A *very* dumb parser for basic s-expressions
    fn parse(s) {
        let
            // parser "tokens"
            typedef sexpr {
                atom(string) |
                sexp(list(sexpr))
            }

            fn to_number(s) {
                let
                    fn to_digit {
                        ('0') { 0 }
                        ('1') { 1 }
                        ('2') { 2 }
                        ('3') { 3 }
                        ('4') { 4 }
                        ('5') { 5 }
                        ('6') { 6 }
                        ('7') { 7 }
                        ('8') { 8 }
                        ('9') { 9 }
                        (_) { error("Invalid digit") }
                    }
                    fn helper {
                        ([], acc) { acc }
                        (c @ rest, acc) {
                            let
                                digit = to_digit(c);
                            in
                                helper(rest, acc * 10 + digit);
                        }
                    }
                in
                    helper(s, 0)
            }

            fn atom_to_string {
                (atom(s)) { s }
                (_) { error("Expected atom") }
            }

            fn to_expr {
                (atom("back")) { back_expr }
                (atom(['\'', c, '\''])) { character(c) }
                (atom(x = '0' @ rest)) | (atom(x = '1' @ rest)) | (atom(x = '2' @ rest)) |
                (atom(x = '3' @ rest)) | (atom(x = '4' @ rest)) | (atom(x = '5' @ rest)) |
                (atom(x = '6' @ rest)) | (atom(x = '7' @ rest)) | (atom(x = '8' @ rest)) |
                (atom(x = '9' @ rest)) { bigint(to_number(x))}
                (atom(s)) { var(s) }
                (sexp([atom("amb"), a, b])) { amb_expr(to_expr(a), to_expr(b)) }
                (sexp([atom("call/cc"), e])) { callcc_expr(to_expr(e)) }
                (sexp([atom("if"), e1, e2, e3])) { if_expr(to_expr(e1), to_expr(e2), to_expr(e3)) }
                (sexp(atom("cond") @ test @ branches)) { cond_expr(to_expr(test), branches |> fn {
                    (sexp([e1, e2])) { #(to_expr(e1), to_expr(e2)) }
                    (_) { error("Invalid cond branch") }
                }) }
                (sexp([atom("lambda"), sexp(args), body])) |
                (sexp([atom("\u03bb;"), sexp(args), body])) {
                    lambda(args |> atom_to_string, to_expr(body))
                }
                (sexp(atom("begin") @ exprs)) { sequence(exprs |> to_expr) }
                (sexp([atom("letrec"), sexp(bindings), body])) {
                    let bindingsList = bindings |> fn {
                        (sexp([atom(name), expr])) { #(name, #(to_expr(expr), 0)) }
                        (_) { error("Invalid letrec binding") }
                    };
                    in
                        letrec_expr(bindingsList, to_expr(body))
                }
                (sexp(atom("make_vec") @ atom(size) @ elements)) { make_vec(to_number(size), elements |> to_expr) }
                (sexp(atom("match_cases") @ exp @ cases)) { match_cases(to_expr(exp), cases |> fn {
                    (sexp([sexp(indices), caseExpr])) {
                        let indexList = indices |> fn {
                            (atom(i)) { to_number(i) }
                            (_) { error("Invalid match_cases index") }
                        };
                        in
                            #(indexList, to_expr(caseExpr))
                    }
                    (_) { error("Invalid match_cases case") }
                }) }
                (sexp([atom("+"),  e1, e2])) { apply(primop("+"),  [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("-"),  e1, e2])) { apply(primop("-"),  [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("*"),  e1, e2])) { apply(primop("*"),  [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("/"),  e1, e2])) { apply(primop("/"),  [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("**"), e1, e2])) { apply(primop("**"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("=="), e1, e2])) { apply(primop("=="), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("="),  e1, e2])) { apply(primop("="),  [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("<"),  e1, e2])) { apply(primop("<"),  [to_expr(e1), to_expr(e2)]) }
                (sexp([atom(">"),  e1, e2])) { apply(primop(">"),  [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("<="), e1, e2])) { apply(primop("<="), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom(">="), e1, e2])) { apply(primop(">="), [to_expr(e1), to_expr(e2)]) }
                (sexp([])) { error("Empty expression") }
                (sexp(func @ args)) { apply(to_expr(func), args |> to_expr) }
                (x) {
                    print x;
                    error("Cannot parse expression");
                }
            }

            // Tokenizer function
            fn parse_sexpr(s) {
                let
                    fn parse_atom {
                        ([], acc) { #(atom(list.reverse(acc)), []) }
                        (' ' @ rest, acc) { #(atom(list.reverse(acc)), rest) }
                        (')' @ rest, acc) { #(atom(list.reverse(acc)), ')' @ rest) }
                        (c @ rest, acc) { parse_atom(rest, c @ acc) }
                    }

                    fn parse_list {
                        ([], _) { error("Unexpected end of input") }
                        (')' @ rest, acc) { #(sexp(list.reverse(acc)), rest) }
                        (' ' @ rest, acc) { parse_list(rest, acc) }
                        (input, acc) {
                            let
                                #(sexpr, rest) = parse_sexpr(input);
                            in
                                parse_list(rest, sexpr @ acc)
                        }
                    }
                in
                    switch (s) {
                        ([]) { error("Unexpected end of input") }
                        ('(' @ rest) { parse_list(rest, []) }
                        (' ' @ rest) { parse_sexpr(rest) }
                        (')' @ rest) { error("Unexpected )") }
                        (c @ rest) { parse_atom(rest, [c]) }
                    }
            }
        in {
            let #(sexpr, rest) = parse_sexpr(s);
            in if (list.empty(rest)) {
                to_expr(sexpr);
            } else {
                 error("Extra input after expression: " @@ rest);
            }
        }
    }