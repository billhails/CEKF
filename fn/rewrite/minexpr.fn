namespace
    // minexpr: somewhat reduced expression set output by desugaring and used by later passes
    link "../listutils.fn" as list;

    typedef expr {
        lambdac(list(string), expr) |
        make_closure(expr, expr) |
        make_env(list(#(string, expr))) |
        env_ref(expr, string) |
        apply_closure(expr, list(expr)) |
        amb_expr(expr, expr) |
        apply(expr, list(expr)) |
        back_expr |
        bigint(number) |
        callcc_expr(expr) |
        character(char) |
        cond_expr(expr, list(#(expr, expr))) |
        env_expr |
        error_expr |
        if_expr(expr, expr, expr) |
        lambda(list(string), expr) |
        letrec_expr(list(#(string, expr)), expr) |
        lookup(string, number, expr) |
        make_vec(number, list(expr)) |
        match_cases(expr, list(#(list(number), expr))) |
        namespaces(list(expr)) |
        primop(string) |
        sequence(list(expr)) |
        stdint(number) |
        var(string)
    }

    // Helper printers
    fn print_list(indices, putter, space) {
        switch (indices) {
            ([]) { "" }
            (h @ t) {
                putter(h);
                list.for_each (fn(i) { puts(space); putter(i) }, t);
                ""
            }
        };
    }

    fn print_bindings(bindings) {
        print_list(bindings, fn(#(name, expr)) {
            putc('(');
            puts(name);
            putc(' ');
            print_expr(expr);
            putc(')');
        }, " ");
    }

    fn print_let(name, bindings, body) {
        puts("(");
        puts(name);
        puts(" [");
        print_bindings(bindings);
        puts("] ");
        print_expr(body);
        puts(")");
    }

    fn print_sequence(exprs) {
        list.map (fn(e) { puts(" "); print_expr(e) }, exprs);
    }

    // Printer for expressions
    fn print_expr {
        (x=lambdac(args, expr)) {
            puts("(λ* (");
            print_list(args, puts, " ");
            puts(") ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=make_closure(func, env)) {
            puts("(CLO ");
            print_expr(func);
            puts(" ");
            print_expr(env);
            puts(")");
            x;
        }
        (x=make_env(bindings)) {
            puts("{ ");
            print_list(bindings, fn(#(name, expr)) {
                puts(name);
                switch (expr) {
                    (var(name2)) {
                        if (name == name2) {
                            ""
                        } else {
                            puts(": ");
                            print_expr(expr);
                            ""
                        }
                    }
                    (_) {
                        puts(": ");
                        print_expr(expr);
                        ""
                    }
                }
            }, ", ");
            puts(" }");
            x;
        }
        (x=env_ref(env, name)) {
            print_expr(env);
            puts("->");
            puts(name);
            x;
        }
        (x=apply_closure(closure, args)) {
            puts("(A/C ");
            print_expr(closure);
            print_sequence(args);
            puts(")");
            x;
        }
        (x=callcc_expr(e)) {
            puts("(call/cc ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=stdint(i)) {
            putn(i);
            x;
        }
        (x=sequence(exprs)) {
            puts("(begin");
            print_sequence(exprs);
            puts(")");
            x;
        }
        (x=namespaces(exprs)) {
            puts("(namespaces");
            print_sequence(exprs);
            puts(")");
            x;
        }
        (x=match_cases(exp, cases)) {
            puts("(match-cases ");
            print_expr(exp);
            list.for_each (fn {
                (#(indices, caseExpr)) {
                    puts(" ((");
                    print_list(indices, fn(i) { putn(i) }, " ");
                    puts(") ");
                    print_expr(caseExpr);
                    puts(")");
                }
            }, cases);
            puts(")");
            x;
        }
        (x=make_vec(size, elements)) {
            puts("(make-vec ");
            putn(size);
            print_sequence(elements);
            puts(")");
            x;
        }
        (x=lookup(name, index, expr)) {
            puts("(lookup ");
            puts(name);
            puts(" ");
            putn(index);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=env_expr) {
            puts("(env)");
            x;
        }
        (x=error_expr) {
            puts("(error)");
            x;
        }
        (x=cond_expr(test, branches)) {
            puts("(cond ");
            print_expr(test);
            list.for_each (fn {
                (#(e1, e2)) {
                    puts(" ");
                    putc('(');
                    print_expr(e1);
                    puts(" ");
                    print_expr(e2);
                    putc(')');
                }
            }, branches);
            puts(")");
            x;
        }
        (x=letrec_expr(bindings, body)) {
            print_let("letrec", bindings, body);
            x;
        }
        (x=lambda(args, expr)) {
            puts("(λ (");
            print_list(args, fn(name) { puts(name) }, " ");
            puts(") ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=if_expr(e1, e2, e3)) {
            puts("(if ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(" ");
            print_expr(e3);
            puts(")");
            x;
        }
        (x=apply(e1, args)) {
            puts("(");
            print_expr(e1);
            print_sequence(args);
            puts(")");
            x;
        }
        (x=bigint(i)) {
            putn(i);
            x;
        }
        (x=var(chars)) {
            puts(chars);
            x;
        }
        (x=amb_expr(e1, e2)) {
            puts("(amb ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(")");
            x;
        }
        (x=back_expr) {
            puts("(back)");
            x;
        }
        (x=character(c)) {
            putc('\'');
            putc(c);
            putc('\'');
            x;
        }
        (x=primop(name)) {
            puts(name);
            x;
        }
    }

    // A *very* dumb parser for basic s-expressions
    fn parse(s) {
        let
            // IR for the parser "tokenization"
            typedef sexpr {
                atom(string) |
                sexp(list(sexpr))
            }

            fn to_number(s) {
                let
                    fn to_digit {
                        ('0') { 0 }
                        ('1') { 1 }
                        ('2') { 2 }
                        ('3') { 3 }
                        ('4') { 4 }
                        ('5') { 5 }
                        ('6') { 6 }
                        ('7') { 7 }
                        ('8') { 8 }
                        ('9') { 9 }
                        (_) { error("Invalid digit") }
                    }
                    fn helper {
                        ([], acc) { acc }
                        (c @ rest, acc) {
                            let
                                digit = to_digit(c);
                            in
                                helper(rest, acc * 10 + digit);
                        }
                    }
                in
                    helper(s, 0)
            }

            fn atom_to_string {
                (atom(s)) { s }
                (_) { error("Expected atom") }
            }

            fn to_expr {
                (atom("back")) { back_expr }
                (atom(['\'', c, '\''])) { character(c) }
                (sexp([atom("env")])) { env_expr }
                (sexp([atom("error")])) { error_expr }
                (atom(x = '0' @ rest)) | (atom(x = '1' @ rest)) | (atom(x = '2' @ rest)) |
                (atom(x = '3' @ rest)) | (atom(x = '4' @ rest)) | (atom(x = '5' @ rest)) |
                (atom(x = '6' @ rest)) | (atom(x = '7' @ rest)) | (atom(x = '8' @ rest)) |
                (atom(x = '9' @ rest)) { bigint(to_number(x))}
                (atom(s)) { var(s) }
                (sexp([atom("amb"), a, b])) { amb_expr(to_expr(a), to_expr(b)) }
                (sexp([atom("call/cc"), e])) { callcc_expr(to_expr(e)) }
                (sexp([atom("if"), e1, e2, e3])) { if_expr(to_expr(e1), to_expr(e2), to_expr(e3)) }
                (sexp(atom("cond") @ test @ branches)) { cond_expr(to_expr(test), list.map (fn {
                    (sexp([e1, e2])) { #(to_expr(e1), to_expr(e2)) }
                    (_) { error("Invalid cond branch") }
                }, branches)) }
                (sexp([atom("lambda"), sexp(args), body])) |
                (sexp([atom("\u03bb;"),      sexp(args), body])) { lambda(list.map(atom_to_string, args), to_expr(body)) }
                (sexp(atom("begin") @ exprs)) { sequence(list.map(to_expr, exprs)) }
                (sexp([atom("letrec"), sexp(bindings), body])) {
                    let bindingsList = list.map (fn {
                        (sexp([atom(name), expr])) { #(name, to_expr(expr)) }
                        (_) { error("Invalid letrec binding") }
                    }, bindings);
                    in
                        letrec_expr(bindingsList, to_expr(body))
                }
                (sexp([atom("lookup"), atom(name), atom(index), e])) { lookup(name, to_number(index), to_expr(e)) }
                (sexp(atom("make_vec") @ atom(size) @ elements)) { make_vec(to_number(size), list.map(to_expr, elements)) }
                (sexp(atom("match_cases") @ exp @ cases)) { match_cases(to_expr(exp), list.map (fn {
                    (sexp([sexp(indices), caseExpr])) {
                        let indexList = list.map (fn {
                            (atom(i)) { to_number(i) }
                            (_) { error("Invalid match_cases index") }
                        }, indices);
                        in
                            #(indexList, to_expr(caseExpr))
                    }
                    (_) { error("Invalid match_cases case") }
                }, cases)) }
                (sexp(atom("namespaces") @ exprs)) { namespaces(list.map(to_expr, exprs)) }
                (sexp([atom("+"), e1, e2])) { apply(primop("+"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("-"), e1, e2])) { apply(primop("-"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("*"), e1, e2])) { apply(primop("*"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("/"), e1, e2])) { apply(primop("/"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("**"), e1, e2])) { apply(primop("**"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("=="), e1, e2])) { apply(primop("=="), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("="), e1, e2])) { apply(primop("="), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("<"), e1, e2])) { apply(primop("<"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom(">"), e1, e2])) { apply(primop(">"), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom("<="), e1, e2])) { apply(primop("<="), [to_expr(e1), to_expr(e2)]) }
                (sexp([atom(">="), e1, e2])) { apply(primop(">="), [to_expr(e1), to_expr(e2)]) }
                (sexp([])) { error("Empty expression") }
                (sexp(func @ args)) { apply(to_expr(func), list.map(to_expr, args)) }
                (x) {
                    print x;
                    error("Cannot parse expression");
                }
            }

            // "Tokenizer" function
            fn parse_sexpr(s) {
                let
                    fn parse_atom {
                        ([], acc) { #(atom(list.reverse(acc)), []) }
                        (' ' @ rest, acc) { #(atom(list.reverse(acc)), rest) }
                        (')' @ rest, acc) { #(atom(list.reverse(acc)), ')' @ rest) }
                        (c @ rest, acc) { parse_atom(rest, c @ acc) }
                    }

                    fn parse_list {
                        ([], _) { error("Unexpected end of input") }
                        (')' @ rest, acc) { #(sexp(list.reverse(acc)), rest) }
                        (' ' @ rest, acc) { parse_list(rest, acc) }
                        (input, acc) {
                            let
                                #(sexpr, rest) = parse_sexpr(input);
                            in
                                parse_list(rest, sexpr @ acc)
                        }
                    }
                in
                    switch (s) {
                        ([]) { error("Unexpected end of input") }
                        ('(' @ rest) { parse_list(rest, []) }
                        (' ' @ rest) { parse_sexpr(rest) }
                        (')' @ rest) { error("Unexpected )") }
                        (c @ rest) { parse_atom(rest, [c]) }
                    }
            }
        in {
            let #(sexpr, rest) = parse_sexpr(s);
            in if (list.empty(rest)) {
                to_expr(sexpr);
            } else {
                 error("Extra input after expression: " @@ rest);
            }
        }
    }