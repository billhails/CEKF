namespace
    link "minexpr.fn" as M;
    link "../listutils.fn" as list;
    link "gensym.fn" as GS;
    import list operator "_|>_";
    import list operator "_&&_";

    fn isAexpr {
        (M.var(_)) |
        (M.primop(_)) |
        (M.back_expr) |
        (M.character(_)) |
        (M.lambda(_, _)) |
        (M.stdint(_)) |
        (M.bigint(_)) { true }
        (_) { false }
    }

    fn M {
        (M.lambda(vars, body)) {
            let c = GS.genstring("$k");
            in M.lambda(vars @@ [c], T_c(body, M.var(c)))
        }
        (x) { x }
    }

    fn kToC(k) {
        let rv = GS.genstring("$rv");
        in M.lambda([rv], k(M.var(rv)))
    }

    fn T_k(e, k) {
        if (isAexpr(e)) {
            k(M(e))
        } else {
            switch (e)  {
                (M.amb_expr(expr1, expr2)) {
                    let
                        c = kToC(k);
                    in
                        M.amb_expr(T_c(expr1, c), T_c(expr2, c))
                }

                (M.apply(_, _)) {
                    let
                        c = kToC(k);
                    in
                        T_c(e, c)
                }

                (M.callcc_expr(e)) {
                    let
                        c = kToC(k);
                    in
                        T_c(M.callcc_expr(e), c)
                }

                (M.cond_expr(test, branches)) {
                    let
                        c = kToC(k);
                    in
                        T_k(test, fn (atest) {
                            M.cond_expr(atest, branches |> identity && T_c flip c)
                        })
                }

                (M.if_expr(exprc, exprt, exprf)) {
                    let
                        c = kToC(k);
                    in
                        T_k(exprc, fn(aexp) {
                            M.if_expr(aexp, T_c(exprt, c), T_c(exprf, c))
                        })
                }

                (M.letrec_expr(bindings, expr)) {
                    M.letrec_expr(bindings |> identity && (M && identity), T_k(expr, k))
                }

                (M.make_vec(size, args)) {
                    Ts_k(args, fn (sargs) {
                        k(M.make_vec(size, sargs))
                    })
                }

                (M.match_cases(test, cases)) {
                    let
                        c = kToC(k);
                    in
                        T_k(test, fn (atest) {
                            M.match_cases(atest, cases |> identity && T_c flip c)
                        })
                }

                (M.sequence([expr])) { T_k(expr, k) }
                (M.sequence(expr @ exprs)) {
                    T_k(expr, fn (ignored) {
                        T_k(M.sequence(exprs), k)
                    })
                }

                (x) {
                    M.print_expr(x);
                    puts("\n");
                    error("T_k: unsupported expression")
                }
            }
        }
    }

    fn T_c(expr, c) {
        if (isAexpr(expr)) {
            M.apply(c, [M(expr)])
        } else {
            switch(expr) {
                (M.amb_expr(expr1, expr2)) {
                    let
                        sk = GS.genstring("$k");
                        vsk = M.var(sk);
                    in
                        M.apply(M.lambda([sk],
                                M.amb_expr(T_c(expr1, vsk),
                                           T_c(expr2, vsk))),
                                [c])
                }

                (M.apply(p=M.primop(_), [e1, e2])) {
                    T_k(e1, fn (s1) {
                        T_k(e2, fn (s2) {
                            M.apply(c, [M.apply(p, [s1, s2])])
                        })
                    })
                }

                (M.apply(f, es)) {
                    T_k(f, fn(sf) {
                        Ts_k(es, fn (ses) {M.apply(sf, ses @@ [c])})
                    })
                }

                (M.callcc_expr(e)) {
                    T_k(e, fn (sf) {
                        M.apply(
                            M.parse("(λ (f cc) (f (λ (x i) (cc x)) cc))"),
                            [sf, c]
                        )
                    })
                }

                (M.cond_expr(test, branches)) {
                    let
                        sk = GS.genstring("$k");
                        vsk = M.var(sk);
                    in
                        M.apply(M.lambda([sk], T_k(test, fn (atest) {
                            M.cond_expr(atest, branches |> identity && T_c flip vsk)
                        })), [c])
                }

                (M.if_expr(exprc, exprt, exprf)) {
                    let
                        sk = GS.genstring("$k");
                        vsk = M.var(sk);
                    in
                        M.apply(M.lambda([sk], T_k(exprc, fn (aexp) {
                            M.if_expr(aexp, T_c(exprt, vsk), T_c(exprf, vsk))
                        })), [c])
                }

                (M.letrec_expr(bindings, expr)) {
                    M.letrec_expr(bindings |> identity && (M && identity), T_c(expr, c))
                }

                (M.make_vec(size, args)) {
                    Ts_k(args, fn (sargs) {
                        M.apply(c, [M.make_vec(size, sargs)])
                    })
                }

                (M.match_cases(test, cases)) {
                    let
                        sk = GS.genstring("$k");
                        vsk = M.var(sk);
                    in
                        M.apply(M.lambda([sk], T_k(test, fn (atest) {
                            M.match_cases(atest, cases |> identity && T_c flip vsk)
                        })), [c])
                }

                (M.sequence([expr])) { T_c(expr, c) }
                (M.sequence(expr @ exprs)) {
                    T_k(expr, fn (ignored) {
                        T_c(M.sequence(exprs), c)
                    })
                }

                (x) {
                    M.print_expr(x);
                    puts("\n");
                    error("T_c: unsupported expression")
                }
            }
        }
    }

    fn Ts_k {
        ([], k) { k([]) }
        (h @ t, k) {
            T_k(h, fn (hd) {
                Ts_k(t, fn (tl) {
                    k(hd @ tl)
                })
            })
        }
    }