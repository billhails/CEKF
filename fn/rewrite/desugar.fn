namespace
    link "expr.fn" as E;
    link "../listutils.fn" as list;

    // desugar: E.expr -> E.expr
    // currently this just rewrites let* to nested lets
    // and let to an anonymous lambda application
    fn desugar(e) {
        let ds = desugar;
        in
        switch (e)  {
            (E.amb_expr(expr1, expr2)) {
                // amb_expr(expr, expr)
                E.amb_expr(ds(expr1), ds(expr2))
            }

            // apply_closure(expr, list(expr))
            (E.apply_closure(f, args)) {
                E.apply_closure(ds(f), list.map(ds, args))
            }

            (E.apply(fun, args)) {
                // apply(expr, list(expr))
                E.apply(ds(fun), list.map(ds, args))
            }

            (x = E.back_expr) |
            (x = E.env_expr) |
            (x = E.error_expr) |
            (x = E.bigint(_)) |
            (x = E.character(_)) |
            (x = E.constructor_info(_)) |
            (x = E.stdint(_)) |
            (x = E.var(_)) |
            (x = E.constant(_)) { x }

            (E.callcc_expr(e)) {
                // callcc_expr(expr)
                E.callcc_expr(ds(e))
            }

            (E.cond_expr(test, branches)) {
                // cond_expr(expr, list(#(expr, expr)))
                let #(vals, results) = list.unzip(branches);
                in  E.cond_expr(ds(test),
                                list.zip(list.map(ds, vals),
                                         list.map(ds, results)))
            }

            (E.construct(name, args)) {
                // construct(string, list(expr))
                E.construct(name, list.map(ds, args))
            }

            (E.deconstruct(name, index, expr)) {
                // deconstruct(string, number, expr)
                E.deconstruct(name, index, ds(expr))
            }

            (E.if_expr(exprc, exprt, exprf)) {
                // if_expr(expr, expr, expr)
                E.if_expr(ds(exprc),
                          ds(exprt),
                          ds(exprf))
            }

            (E.lambda(params, body)) {
                // lambda(list(string), expr)
                E.lambda(params, ds(body))
            }

            (E.lambdac(params, body)) {
                // lambda(list(string), expr)
                E.lambdac(params, ds(body))
            }

            (E.make_closure(body, env)) {
                // make_closure(expr, env)
                E.make_closure(ds(body), ds(env))
            }

            // make_env(list(#(string, expr)))
            (E.make_env(bindings)) {
                E.make_env(list.map(fn (#(v, e)) { #(v, ds(e)) }, bindings))
            }

            // env_ref(expr, string)
            (E.env_ref(e, s)) {
                E.env_ref(ds(e), s)
            }

            (E.letrec_expr(bindings, expr)) {
                // letrec_expr(list(#(string, expr)), expr)
                E.letrec_expr(bindings, ds(expr)) // new environment
            }

            (E.let_expr(bindings, expr)) {
                // let_expr(list(#(string, expr)), expr)
                let #(vars, vals) = list.unzip(bindings);
                    newvals = list.map(ds, vals);
                in E.apply(E.lambda(vars, ds(expr)), newvals)
            }

            (E.letstar_expr(bindings, expr)) {
                // letstar_expr(list(#(string, expr)), expr)
                let
                    fn nest_lets {
                        ([], body) { body }
                        (#(var, exp) @ rest, body) {
                            E.let_expr([#(var, exp)], nest_lets(rest, body))
                        }
                    }
                in ds(nest_lets(bindings, expr));
            }

            (E.lookup(name, index, expr)) {
                // lookup(string, number, expr)
                E.lookup(name, index, ds(expr))
            }

            (E.make_tuple(args)) {
                // make_tuple(list(expr))
                E.make_tuple(list.map(ds, args))
            }

            (E.make_vec(size, args)) {
                // make_vec(number, list(expr))
                E.make_vec(size, list.map(ds, args))
            }

            (E.match_cases(test, cases)) {
                // match_cases(expr, list(#(list(number), expr)))
                let #(vals, results) = list.unzip(cases);
                in
                    E.match_cases(ds(test),
                                  list.zip(vals, list.map(ds, results)))
            }

            (E.namespaces(exprs)) {
                // namespaces(list(expr))
                E.namespaces(list.map(ds, exprs))
            }

            (E.primapp(p, e1, e2)) {
                // primapp(string, expr, expr)
                E.primapp(p, ds(e1), ds(e2))
            }

            (E.print_exp(expr)) {
                // print_exp(expr)
                E.print_exp(ds(expr))
            }

            (E.sequence(exprs)) {
                // sequence(list(expr))
                E.sequence(list.map(ds, exprs))
            }

            (E.tag(expr)) {
                // tag(expr)
                E.tag(ds(expr))
            }

            (E.tuple_index(size, index, expr)) {
                // tuple_index(number, number, expr)
                E.tuple_index(size, index, ds(expr))
            }

            (E.typedefs(defs, expr)) {
                // typedefs(list(def), expr)
                E.typedefs(defs, ds(expr))
            }

            (E.typeof_expr(expr)) {
                // typeof_expr(expr)
                E.typeof_expr(ds(expr))
            }

            (x) {
                E.print_expr(x);
                puts("\n");
                error("desugar: unsupported expression")
            }
        }
    }