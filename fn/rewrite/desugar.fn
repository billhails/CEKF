namespace
    link "expr.fn" as E;
    link "minexpr.fn" as M;
    link "../listutils.fn" as list;
    link "../dictutils.fn" as DICT;
    link "../ioutils.fn" as IO;
    import IO operator "$_";
    import list operator "_|>_";
    import list operator "_&&_";
    import list operator "_::_";
    import list operator "len_";
    import list operator "_take_";
    import list operator "_drop_";
    import list operator "unzip_";


    fn makeVar (s) {
        M.var(s)
    }

    // desugar: E.expr -> M.expr
    // rewrites let* to nested lets
    // rewrites let to an anonymous lambda application
    // rewrites constructs and deconstructs to vector operations

    fn desugar {
        (E.amb_expr(expr1, expr2)) {
            M.amb_expr(desugar(expr1), desugar(expr2))
        }

        (E.apply(E.var(v), args)) {
            M.apply(M.var(v), args |> desugar)
        }

        (E.apply(fun, args)) {
            M.apply(desugar(fun), args |> desugar)
        }

        (E.back_expr) { M.back_expr }
        (E.env_expr) { 
            error("desugar: env_expr not supported")
        }
        (E.error_expr) { 
            error("desugar: error_expr not supported")
        }
        (E.bigint(i)) { M.bigint(i) }
        (E.character(c)) { M.character(c) }
        (E.constructor_info(_)) {
            error("desugar: constructor_info not supported")
        }
        (E.stdint(i)) { M.stdint(i) }
        (E.var(v)) { M.var(v) }
        (E.constant(name, n)) { M.stdint(n) }

        (E.callcc_expr(e)) {
            M.callcc_expr(desugar(e))
        }

        (E.cond_expr(test, branches)) {
            M.cond_expr(desugar(test), branches |> desugar && desugar);
        }

        (E.construct(name, tag, args)) {
            let aargs = E.stdint(tag) @ args
            in
                desugar(E.make_vec(len aargs, aargs))
        }

        (E.deconstruct(name, index, expr)) {
            M.apply(M.primop("vec-ref"), [M.stdint(index), desugar(expr)])
        }

        (E.if_expr(exprc, exprt, exprf)) {
            M.if_expr(desugar(exprc),
                    desugar(exprt),
                    desugar(exprf))
        }

        (E.lambda(params, body)) {
            M.lambda(params, desugar(body))
        }

        (E.letrec_expr(bindings, expr)) {
            let
                bindings2 = bindings |>
                            identity && desugar |>
                            identity && fn (e) { #(e, 0) };
            in M.letrec_expr(bindings2, desugar(expr))
        }

        (E.let_expr(bindings, expr)) {
            let #(vars, vals) = unzip (bindings |> identity && desugar);
            in M.apply(M.lambda(vars, desugar(expr)), vals)
        }

        (E.letstar_expr(bindings, expr)) {
            let
                fn nest_lets {
                    ([], body) { body }
                    (#(var, exp) @ rest, body) {
                        E.let_expr([#(var, exp)], nest_lets(rest, body))
                    }
                }
            in
                desugar(nest_lets(bindings, expr));
        }

        (E.make_tuple(args)) {
            M.make_vec(len args, args |> desugar)
        }

        (E.make_vec(size, args)) {
            M.make_vec(size, args |> desugar)
        }

        (E.match_cases(test, cases)) {
            M.match_cases(desugar(test), cases |> identity && desugar)
        }

        (E.namespaces(_)) {
            error("desugar: namespaces not supported")
        }

        (E.primapp(p, e1, e2)) {
            M.apply(M.primop(p), [desugar(e1), desugar(e2)])
        }

        (E.print_exp(expr)) {
            M.apply(M.lambda(["x"], M.var("x")), [desugar(expr)])
        }

        (E.sequence(exprs)) {
            M.sequence(exprs |> desugar)
        }

        (E.tag(expr)) {
            desugar(E.primapp("vec", E.stdint(0), expr))
        }

        (E.tuple_index(size, index, expr)) {
            desugar(E.primapp("vec", E.stdint(index), expr))
        }

        (E.typedefs(defs, expr)) {
            desugar(expr)
        }

        (E.typeof_expr(expr)) {
            // fake typeof until type checking is implemented
            M.make_vec(2, [M.character('t'), M.make_vec(0, [])])
        }

        (x) {
            E.print_expr(x);
            puts("\n");
            error("desugar: unsupported expression")
        }
    }