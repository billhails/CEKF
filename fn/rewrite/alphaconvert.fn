let
    link "expr.fn" as E;
    link "env.fn" as Env;
    link "../listutils.fn" as list;
    link "../ioutils.fn" as io;
    import io operator "$_";

    fn genstring(p) { p @@ "$" @@ $incr() }
    fn gensym(p) { E.var(genstring(p)) }

    fn alphaconvert(c, e) {
        switch (e)  {
            (E.amb_expr(expr1, expr2)) {
                // amb_expr(expr, expr)
                E.amb_expr(alphaconvert(c, expr1), alphaconvert(c, expr2))
            }

            (E.apply(fun, args)) {
                // apply(expr, list(expr))
                E.apply(alphaconvert(c, fun), list.map(fn (arg) { alphaconvert(c, arg) }, args))
            }

            (x = E.back_expr) |
            (x = E.env_expr) |
            (x = E.error_expr) |
            (x = E.bigint(_)) |
            (x = E.character(_)) |
            (x = E.constructor_info(_)) |
            (x = E.stdint(_)) |
            (x = E.constant(_)) {
                x
            }

            (E.callcc_expr(e)) {
                // callcc_expr(expr)
                E.callcc_expr(alphaconvert(c, e))
            }

            (E.cond_expr(test, branches)) {
                // cond_expr(expr, list(#(expr, expr)))
                let #(vals, results) = list.unzip(branches);
                in
                    E.cond_expr(alphaconvert(c, test),
                                list.zip(list.map(alphaconvert(c), vals),
                                         list.map(alphaconvert(c), results)))
            }

            (E.construct(name, args)) {
                // construct(string, list(expr))
                E.construct(name, list.map(alphaconvert(c), args))
            }

            (E.deconstruct(name, index, expr)) {
                // deconstruct(string, number, expr)
                E.deconstruct(name, index, alphaconvert(c, expr))
            }

            (E.if_expr(exprc, exprt, exprf)) {
                // if_expr(expr, expr, expr)
                E.if_expr(alphaconvert(c, exprc),
                          alphaconvert(c, exprt),
                          alphaconvert(c, exprf))
            }

            (E.lambda(params, body)) {
                // lambda(list(string), expr)
                let #(en, nsa) = c;
                    newparams = list.map(genstring, params);
                    ee = Env.add_lists(Env.extend(en), params, newparams);
                in
                    E.lambda(newparams, alphaconvert(#(ee, nsa), body))
            }

            (E.letrec_expr(bindings, expr)) {
                // letrec_expr(list(#(string, expr)), expr)
                let #(en, nsa) = c;
                    #(vars, exprs) = list.unzip(bindings);
                    newvars = list.map(genstring, vars);
                    ee = Env.add_lists(Env.extend(en), vars, newvars);
                    newvals = list.map(alphaconvert(#(ee, nsa)), exprs); // in new environment
                    newbindings = list.zip(newvars, newvals);
                in
                    E.letrec_expr(newbindings, alphaconvert(#(ee, nsa), expr)) // new environment
            }

            (E.let_expr(bindings, expr)) {
                // let_expr(list(#(string, expr)), expr)
                let #(en, nsa) = c;
                    #(vars, exprs) = list.unzip(bindings);
                    newvals = list.map(alphaconvert(c), exprs); // in old environment
                    newvars = list.map(genstring, vars);
                    ee = Env.add_lists(Env.extend(en), vars, newvars);
                    newbindings = list.zip(newvars, newvals);
                in
                    E.let_expr(newbindings, alphaconvert(#(ee, nsa), expr)) // new environment
            }

            (E.letstar_expr(bindings, expr)) {
                // letstar_expr(list(#(string, expr)), expr)
                let
                    fn nest_lets {
                        ([], body) { body }
                        (#(var, exp) @ rest, body) {
                            E.let_expr([#(var, exp)], nest_lets(rest, body))
                        }
                    }
                in
                    alphaconvert(c, nest_lets(bindings, expr));
            }

            (E.lookup(name, index, expr)) {
                // lookup(string, number, expr)
                let #(e, nsa) = c;
                    fn find {
                        (0, h @ t) { h }
                        (n, h @ t) { find(n - 1, t) }
                        (_, []) { error("Namespace index out of bounds") }
                    }
                in
                    E.lookup(name, index, alphaconvert(#(find(index, nsa), nsa), expr))
            }

            (E.make_tuple(args)) {
                // make_tuple(list(expr))
                E.make_tuple(list.map(alphaconvert(c), args))
            }

            (E.make_vec(size, args)) {
                // make_vec(number, list(expr))
                E.make_vec(size, list.map(alphaconvert(c), args))
            }

            (E.match_cases(test, cases)) {
                // match_cases(expr, list(#(list(number), expr)))
                let #(vals, results) = list.unzip(cases);
                in
                    E.match_cases(alphaconvert(c, test),
                                  list.zip(vals, list.map(alphaconvert(c), results)))
            }

            (E.namespaces(exprs)) {
                // namespaces(list(expr))
                E.namespaces(list.map(alphaconvert(c), exprs))
            }

            (E.primapp(p, e1, e2)) {
                // primapp(string, expr, expr)
                E.primapp(p, alphaconvert(c, e1), alphaconvert(c, e2))
            }

            (E.print_exp(expr)) {
                // print_exp(expr)
                E.print_exp(alphaconvert(c, expr))
            }

            (E.sequence(exprs)) {
                // sequence(list(expr))
                E.sequence(list.map(alphaconvert(c), exprs))
            }

            (E.tag(expr)) {
                // tag(expr)
                E.tag(alphaconvert(c, expr))
            }

            (E.tuple_index(size, index, expr)) {
                // tuple_index(number, number, expr)
                E.tuple_index(size, index, alphaconvert(c, expr))
            }

            (E.typedefs(defs, expr)) {
                // typedefs(list(def), expr)
                E.typedefs(defs, alphaconvert(c, expr))
            }

            (E.typeof_expr(expr)) {
                // typeof_expr(expr)
                E.typeof_expr(alphaconvert(c, expr))
            }
            (E.var(name)) {
                // var(string)
                let #(e, nsa) = c;
                    v = Env.get(e, name);
                in
                    switch (v) {
                        (nothing) {
                            error("Unbound variable: " @@ name)
                        }
                        (x=some(vname)) {
                            E.var(vname)
                        }
                    }
            }

            (x) {
                E.print_expr(x);
                puts("\n");
                error("alphaconvert: unsupported expression")
            }
        }
    }
in
    list.for_each(fn (str) {
        let expr = E.parse(str);
        in
            E.print_expr(expr);
            puts(" ==>\n    ");
            E.print_expr(alphaconvert(#(Env.root, []), expr));
            puts("\n\n")
    },
    [
        // Basic application
        "(let ((g 3) (a 4)) (g a))",

        // Simple lambda application
        "(let ((h 1) (g 2)) ((lambda (x) (h x)) (g 4)))",

        // Lambda definition with primitives
        "(lambda (a b) (+ a (* b 2)))",

        // Lambda application with primitives - nested
        "((lambda (a b) (+ a (* b 2))) 3 4)",

        // Lambda application with function call in primitive
        "(let ((f 5)) ((lambda (a b) (+ a (* (f b) 2))) 3 4))",

        // Amb operator (non-determinism)
        "(amb 1 2)",

        // Simple call/cc - immediate escape
        "(call/cc (lambda (k) (k 5)))",

        // call/cc that doesn't escape
        "(call/cc (lambda (k) 42))",

        // call/cc with computation before escape
        "(call/cc (lambda (k) (+ 10 (k 5))))",

        // Nested call/cc
        "(call/cc (lambda (k1) (call/cc (lambda (k2) (k1 (k2 7))))))",

        // call/cc with amb
        "(call/cc (lambda (k) (amb (k 1) (k 2))))",

        // Factorial with letrec
        "(letrec ((fact (lambda (n) (if (== n 0) 1 (* n (fact (- n 1))))))) (fact 5))",

        // Multiple argument function
        "((lambda (x y z) (+ x (+ y z))) 1 2 3)",

        // Nested lambdas (currying)
        "((lambda (x) (lambda (y) (+ x y))) 5)",

        // Application of curried function
        "(((lambda (x) (lambda (y) (+ x y))) 5) 3)",

        // If expression with complex branches
        "(let ((x 1) (f 2) (g 3)) (if (== x 0) (f 1) (g 2)))",

        // If with nested if
        "(let ((x 1) (y 2)) (if (== x 0) (if (== y 0) 1 2) 3))",

        // Sequence (begin in Racket)
        "(let ((f 1) (g 2) (h 3)) (begin (f 1) (g 2) (h 3)))",

        // Letrec with mutual recursion
        "(letrec ((even (lambda (n) (if (= n 0) true (odd (- n 1))))) (odd (lambda (n) (if (= n 0) false (even (- n 1)))))) (even 5))",

        // Complex amb with computation
        "(+ (amb 1 2) (amb 3 4))",

        // Nested application
        "(let ((f 1) (g 2) (h 3) (x 4)) (f (g (h x))))",

        // Multiple primitives in sequence
        "(+ (* 2 3) (- 5 1))",

        // call/cc capturing continuation in letrec
        "(letrec ((k null)) (call/cc (lambda (cont) (begin (set! k cont) 42))))",

        // Lambda with no arguments
        "((lambda () 42))",

        // call/cc with primitive operations
        "(call/cc (lambda (k) (if (= 1 1) (k 10) 20)))",

        // Deeply nested primitives
        "(+ 1 (+ 2 (+ 3 (+ 4 5))))",

        // Application with multiple complex arguments
        "(let ((f 1) (g 2) (h 3) (i 4) (a 5) (b 6) (c 7)) (f (g a) (h b) (i c)))",

        // If where branches have applications
        "(let ((test 1) (f 2) (g 3) (h 4) (i 5) (x 6) (y 7)) (if test (f (g x)) (h (i y))))",

        // Sequence with amb
        "(begin (amb 1 2) (amb 3 4))",

        // call/cc that passes continuation to another function
        "(let ((f 1)) (call/cc (lambda (k) (f k))))",

        // cond expression - like switch/case
        "(let ((result1 1) (result2 2) (result3 3)) (let ((x 1)) (cond x (1 (result1)) (2 (result2)) (3 (result3)))))",

        // cond with complex test and results
        "(let ((f 1) (x 2) (g 3) (h 4)) (cond (f x) (1 (g 1)) (2 (h 2))))",

        // construct with atomic arguments
        "(construct pair 1 2)",

        // construct with complex arguments
        "(let ((f 1) (g 2)) (construct pair (f 1) (g 2)))",

        // nested construct
        "(let ((f 1) (g 2) (x 3) (y 4)) (construct cons (f x) (construct cons (g y) (constant nil))))",

        // deconstruct with atomic argument
        "(let ((p 1)) (deconstruct pair 0 p))",

        // deconstruct with complex argument
        "(let ((f 1) (x 2)) (deconstruct pair 1 (f x)))",

        // nested deconstruct
        "(let ((f 1) (x 2)) (deconstruct pair 0 (deconstruct pair 1 (f x))))",

        // let with atomic value
        "(let ((f 1)) (let ((x 42)) (f x)))",

        // let with complex value
        "(let ((f 1) (g 2)) (let ((x (f 10))) (g x)))",

        // nested let
        "(let ((f 1) (g 2) (h 3) (x 4)) (let ((x (f 1)) (y (g x))) (h x y)))",

        // nested let*
        "(let ((f 1) (g 2) (h 3) (x 4)) (let* ((x (f 1)) (y (g x))) (h x y)))",

        // lookup with simple variable
        // "(let ((ns 1) (x 2)) (lookup ns 0 x))",

        // lookup with function call
        // "(lookup ns 0 (f x))",

        // nested lookup
        // "(f (lookup ns 0 (g x)))",

        // make_tuple with atomic args
        "(make_tuple 1 2 3)",

        // make_tuple with complex args
        "(let ((f 1) (g 2)) (make_tuple (f 1) (g 2)))",

        // make_tuple with mixed args
        "(let ((x 1) (y 2) (f 3)) (make_tuple x (f y) 42))",

        // make_vec with atomic args
        "(make_vec 3 1 2 3)",

        // make_vec with complex args
        "(let ((f 1) (g 2)) (make_vec 2 (f 1) (g 2)))",

        // make_vec with mixed args
        "(let ((x 1) (y 2) (f 3)) (make_vec 3 x (f y) 42))",

        // match_cases with atomic test
        "(let ((x 1) (r1 2) (r2 3)) (match_cases x ((1 2) (r1)) ((3 4 5) (r2))))",

        // match_cases with complex test
        // "(match_cases (f x) ((1) (g 1)) ((2) (h 2)))",

        // match_cases with complex results
        // "(match_cases x ((1) (f 1)) ((2) (g 2)))",

        // namespaces with atomic expressions
        // "(namespaces x y z)",

        // namespaces with complex expressions
        // "(namespaces (f 1) (g 2))",

        // namespaces with mixed expressions
        // "(namespaces x (f y) z)",

        // namespaces with letrec bodies returning env
        "(namespaces (letrec ((x 1) (y 2)) (let* ((f 1) (g f)) (env))) (letrec ((a 3) (b 4)) (env)))",

        // print_exp with atomic argument
        "(let ((x 1)) (print x))",

        // print_exp with complex argument
        "(let ((f 1) (x 2)) (print (f x)))",

        // print_exp nested in computation
        "(let ((f 1) (x 2)) (+ (print (f x)) 10))",

        // tag with atomic argument
        "(let ((x 1)) (tag x))",

        // tag with complex argument
        "(let ((f 1) (x 2)) (tag (f x)))",

        // tag in cond test
        "(let ((f 1) (x 2) (r1 3) (r2 4)) (cond (tag (f x)) (1 (r1)) (2 (r2))))",

        // tuple_index with atomic tuple
        "(let ((t 1)) (tuple_index 3 0 t))",

        // tuple_index with complex tuple
        "(let ((f 1) (x 2)) (tuple_index 2 1 (f x)))",

        // nested tuple_index
        "(let ((f 1) (x 2)) (tuple_index 2 0 (tuple_index 3 1 (f x))))",

        // typedefs with simple expression
        "(let ((x 1)) (typedefs 0 x))",

        // typedefs with letrec body
        "(let ((g 1)) (typedefs 0 (letrec ((f (lambda (x) (g x)))) (f 42))))",

        // typedefs with complex body
        "(let ((f 1) (g 2) (x 3)) (typedefs 0 (f (g x))))",

        // typedefs wrapping letrec with env body
        "(typedefs 0 (letrec ((x 1) (y 2)) (env)))",

        // typeof_expr with atomic argument
        "(let ((x 1)) (typeof x))",

        // typeof_expr with complex argument
        "(let ((f 1) (x 2)) (typeof (f x)))",

        // typeof_expr in conditional
        "(let ((f 1) (x 2) (g 3) (h 4)) (if (typeof (f x)) (g 1) (h 2)))"
    ]);

// output:
//
// (g a) ==>
//     (g a halt)
//
// ((λ (x) (h x)) (g 4)) ==>
//     (g 4 (λ ($rv2) ((λ (x $k1) (h x $k1)) $rv2 halt)))
//
// (λ (a b) (+ a (* b 2))) ==>
//     (halt (λ (a b $k3) ($k3 (+ a (* b 2)))))
//
// ((λ (a b) (+ a (* b 2))) 3 4) ==>
//     ((λ (a b $k4) ($k4 (+ a (* b 2)))) 3 4 halt)
//
// ((λ (a b) (+ a (* (f b) 2))) 3 4) ==>
//     ((λ (a b $k5) (f b (λ ($rv6) ($k5 (+ a (* $rv6 2)))))) 3 4 halt)
//
// (amb 1 2) ==>
//     ((λ ($k7) (amb ($k7 1) ($k7 2))) halt)
//
// (call/cc (λ (k) (k 5))) ==>
//     ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k $k8) (k 5 $k8)) halt)
//
// (call/cc (λ (k) 42)) ==>
//     ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k $k9) ($k9 42)) halt)
//
// (call/cc (λ (k) (+ 10 (k 5)))) ==>
//     ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k $k10) (k 5 (λ ($rv11) ($k10 (+ 10 $rv11))))) halt)
//
// (call/cc (λ (k1) (call/cc (λ (k2) (k1 (k2 7)))))) ==>
//     ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k1 $k12) ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k2 $k13) (k2 7 (λ ($rv14) (k1 $rv14 $k13)))) $k12)) halt)
//
// (call/cc (λ (k) (amb (k 1) (k 2)))) ==>
//     ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k $k15) ((λ ($k16) (amb (k 1 $k16) (k 2 $k16))) $k15)) halt)
//
// (letrec ((fact (λ (n) (if (= n 0) 1 (* n (fact (- n 1))))))) (fact 5)) ==>
//     (letrec ((fact (λ (n $k17) ((λ ($k18) (= n 0 (λ ($rv19) (if $rv19 ($k18 1) (fact (- n 1) (λ ($rv20) ($k18 (* n $rv20)))))))) $k17)))) (fact 5 halt))
//
// ((λ (x y z) (+ x (+ y z))) 1 2 3) ==>
//     ((λ (x y z $k21) ($k21 (+ x (+ y z)))) 1 2 3 halt)
//
// ((λ (x) (λ (y) (+ x y))) 5) ==>
//     ((λ (x $k22) ($k22 (λ (y $k23) ($k23 (+ x y))))) 5 halt)
//
// (((λ (x) (λ (y) (+ x y))) 5) 3) ==>
//     ((λ (x $k25) ($k25 (λ (y $k26) ($k26 (+ x y))))) 5 (λ ($rv24) ($rv24 3 halt)))
//
// (if (= x 0) (f 1) (g 2)) ==>
//     ((λ ($k27) (= x 0 (λ ($rv28) (if $rv28 (f 1 $k27) (g 2 $k27))))) halt)
//
// (if (= x 0) (if (= y 0) 1 2) 3) ==>
//     ((λ ($k29) (= x 0 (λ ($rv30) (if $rv30 ((λ ($k31) (= y 0 (λ ($rv32) (if $rv32 ($k31 1) ($k31 2))))) $k29) ($k29 3))))) halt)
//
// (begin (f 1) (g 2) (h 3)) ==>
//     (f 1 (λ ($rv33) (g 2 (λ ($rv34) (h 3 (λ ($rv35) (begin $rv33 $rv34 $rv35 halt)))))))
//
// (letrec ((even (λ (n) (if (= n 0) true (odd (- n 1)))))(odd (λ (n) (if (= n 0) false (even (- n 1)))))) (even 5)) ==>
//     (letrec ((even (λ (n $k36) ((λ ($k37) (= n 0 (λ ($rv38) (if $rv38 ($k37 true) (odd (- n 1) $k37))))) $k36)))(odd (λ (n $k39) ((λ ($k40) (= n 0 (λ ($rv41) (if $rv41 ($k40 false) (even (- n 1) $k40))))) $k39)))) (even 5 halt))
//
// (+ (amb 1 2) (amb 3 4)) ==>
//     (amb ((λ ($rv42) (amb ((λ ($rv43) (halt (+ $rv42 $rv43))) 3) ((λ ($rv43) (halt (+ $rv42 $rv43))) 4))) 1) ((λ ($rv42) (amb ((λ ($rv43) (halt (+ $rv42 $rv43))) 3) ((λ ($rv43) (halt (+ $rv42 $rv43))) 4))) 2))
//
// (f (g (h x))) ==>
//     (h x (λ ($rv45) (g $rv45 (λ ($rv44) (f $rv44 halt)))))
//
// (+ (* 2 3) (- 5 1)) ==>
//     (halt (+ (* 2 3) (- 5 1)))
//
// (letrec ((k null)) (call/cc (λ (cont) (begin (k = cont) 42)))) ==>
//     (letrec ((k null)) ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (cont $k46) (k = cont (λ ($rv47) (begin $rv47 42 $k46)))) halt))
//
// ((λ () 42)) ==>
//     ((λ ($k48) ($k48 42)) halt)
//
// (call/cc (λ (k) (if (= 1 1) (k 10) 20))) ==>
//     ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k $k49) ((λ ($k50) (= 1 1 (λ ($rv51) (if $rv51 (k 10 $k50) ($k50 20))))) $k49)) halt)
//
// (+ 1 (+ 2 (+ 3 (+ 4 5)))) ==>
//     (halt (+ 1 (+ 2 (+ 3 (+ 4 5)))))
//
// (f (g a) (h b) (i c)) ==>
//     (g a (λ ($rv52) (h b (λ ($rv53) (i c (λ ($rv54) (f $rv52 $rv53 $rv54 halt)))))))
//
// (if test (f (g x)) (h (i y))) ==>
//     ((λ ($k55) (if test (g x (λ ($rv56) (f $rv56 $k55))) (i y (λ ($rv57) (h $rv57 $k55))))) halt)
//
// (begin (amb 1 2) (amb 3 4)) ==>
//     (amb ((λ ($rv58) (amb ((λ ($rv59) (begin $rv58 $rv59 halt)) 3) ((λ ($rv59) (begin $rv58 $rv59 halt)) 4))) 1) ((λ ($rv58) (amb ((λ ($rv59) (begin $rv58 $rv59 halt)) 3) ((λ ($rv59) (begin $rv58 $rv59 halt)) 4))) 2))
//
// (call/cc (λ (k) (f k))) ==>
//     ((λ (f cc) (f (λ (x i) (cc x)) cc)) (λ (k $k60) (f k $k60)) halt)
//
// (cond x (1 (result1)) (2 (result2)) (3 (result3))) ==>
//     ((λ ($k61) (cond x (1 (result1 $k61)) (2 (result2 $k61)) (3 (result3 $k61)))) halt)
//
// (cond (f x) (1 (g 1)) (2 (h 2))) ==>
//     ((λ ($k62) (f x (λ ($rv63) (cond $rv63 (1 (g 1 $k62)) (2 (h 2 $k62)))))) halt)
//
// (construct pair 1 2) ==>
//     (halt (construct pair 1 2))
//
// (construct pair (f 1) (g 2)) ==>
//     (f 1 (λ ($rv64) (g 2 (λ ($rv65) (halt (construct pair $rv64 $rv65))))))
//
// (construct cons (f x) (construct cons (g y) (constant nil))) ==>
//     (f x (λ ($rv66) (g y (λ ($rv67) (halt (construct cons $rv66 (construct cons $rv67 (constant nil))))))))
//
// (deconstruct pair 0 p) ==>
//     (halt (deconstruct pair 0 p))
//
// (deconstruct pair 1 (f x)) ==>
//     (f x (λ ($rv68) (halt (deconstruct pair 1 $rv68))))
//
// (deconstruct pair 0 (deconstruct pair 1 (f x))) ==>
//     (f x (λ ($rv69) (halt (deconstruct pair 0 (deconstruct pair 1 $rv69)))))
//
// (let (x 42) (f x)) ==>
//     (let (x 42) (f x halt))
//
// (let (x (f 10)) (g x)) ==>
//     (f 10 (λ ($rv70) (let (x $rv70) (g x halt))))
//
// (let (x (f 1)) (let (y (g x)) (h x y))) ==>
//     (f 1 (λ ($rv71) (let (x $rv71) (g x (λ ($rv72) (let (y $rv72) (h x y halt)))))))
//
// (lookup ns 0 x) ==>
//     (lookup ns 0 (halt x))
//
// (lookup ns 0 (f x)) ==>
//     (lookup ns 0 (f x halt))
//
// (f (lookup ns 0 (g x))) ==>
//     (lookup ns 0 (g x (λ ($rv73) (f $rv73 halt))))
//
// (make_tuple 1 2 3) ==>
//     (halt (make_tuple 1 2 3))
//
// (make_tuple (f 1) (g 2)) ==>
//     (f 1 (λ ($rv74) (g 2 (λ ($rv75) (halt (make_tuple $rv74 $rv75))))))
//
// (make_tuple x (f y) 42) ==>
//     (f y (λ ($rv76) (halt (make_tuple x $rv76 42))))
//
// (make_vec 3 1 2 3) ==>
//     (halt (make_vec 3 1 2 3))
//
// (make_vec 2 (f 1) (g 2)) ==>
//     (f 1 (λ ($rv77) (g 2 (λ ($rv78) (halt (make_vec 2 $rv77 $rv78))))))
//
// (make_vec 3 x (f y) 42) ==>
//     (f y (λ ($rv79) (halt (make_vec 3 x $rv79 42))))
//
// (match_cases x ((1 2) (result1)) ((3 4 5) (result2))) ==>
//     ((λ ($k80) (match_cases x ((1 2) (result1 $k80)) ((3 4 5) (result2 $k80)))) halt)
//
// (match_cases (f x) ((1) (g 1)) ((2) (h 2))) ==>
//     ((λ ($k81) (f x (λ ($rv82) (match_cases $rv82 ((1) (g 1 $k81)) ((2) (h 2 $k81)))))) halt)
//
// (match_cases x ((1) (f 1)) ((2) (g 2))) ==>
//     ((λ ($k83) (match_cases x ((1) (f 1 $k83)) ((2) (g 2 $k83)))) halt)
//
// (namespaces x y z) ==>
//     (halt (namespaces x y z))
//
// (namespaces (f 1) (g 2)) ==>
//     (f 1 (λ ($rv84) (g 2 (λ ($rv85) (halt (namespaces $rv84 $rv85))))))
//
// (namespaces x (f y) z) ==>
//     (f y (λ ($rv86) (halt (namespaces x $rv86 z))))
//
// (namespaces (letrec ((x 1)(y 2)) (env)) (letrec ((a 3)(b 4)) (env))) ==>
//     (letrec ((x 1)(y 2)) (letrec ((a 3)(b 4)) (halt (namespaces (env) (env)))))
//
// (print x) ==>
//     (halt (print x))
//
// (print (f x)) ==>
//     (f x (λ ($rv87) (halt (print $rv87))))
//
// (+ (print (f x)) 10) ==>
//     (f x (λ ($rv88) (halt (+ (print $rv88) 10))))
//
// (tag x) ==>
//     (halt (tag x))
//
// (tag (f x)) ==>
//     (f x (λ ($rv89) (halt (tag $rv89))))
//
// (cond (tag (f x)) (1 (result1)) (2 (result2))) ==>
//     ((λ ($k90) (f x (λ ($rv91) (cond (tag $rv91) (1 (result1 $k90)) (2 (result2 $k90)))))) halt)
//
// (tuple_index 1 1 t) ==>
//     (halt (tuple_index 1 1 t))
//
// (tuple_index 1 1 (f x)) ==>
//     (f x (λ ($rv92) (halt (tuple_index 1 1 $rv92))))
//
// (tuple_index 1 1 (tuple_index 1 1 (f x))) ==>
//     (f x (λ ($rv93) (halt (tuple_index 1 1 (tuple_index 1 1 $rv93)))))
//
// (typedefs 1 x) ==>
//     (typedefs 1 (halt x))
//
// (typedefs 1 (letrec ((f (λ (x) (g x)))) (f 42))) ==>
//     (typedefs 1 (letrec ((f (λ (x $k94) (g x $k94)))) (f 42 halt)))
//
// (typedefs 1 (f (g x))) ==>
//     (typedefs 1 (g x (λ ($rv95) (f $rv95 halt))))
//
// (typedefs 1 (letrec ((x 1)(y 2)) (env))) ==>
//     (typedefs 1 (letrec ((x 1)(y 2)) (halt (env))))
//
// (typeof x) ==>
//     (halt (typeof x))
//
// (typeof (f x)) ==>
//     (f x (λ ($rv96) (halt (typeof $rv96))))
//
// (if (typeof (f x)) (g 1) (h 2)) ==>
//     ((λ ($k97) (f x (λ ($rv98) (if (typeof $rv98) (g 1 $k97) (h 2 $k97))))) halt)
//