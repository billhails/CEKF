namespace
link "minexpr.fn" as M;
link "env.fn" as Env;
link "../listutils.fn" as list;
link "gensym.fn" as GS;
import list operator "_|>_";
import list operator "_&&_";
import list operator "_zip_";
import list operator "unzip_";

fn alphaconvert(c, e) {
    switch (e)  {
        (M.amb_expr(expr1, expr2)) {
            M.amb_expr(alphaconvert(c, expr1), alphaconvert(c, expr2))
        }

        (M.apply(fun, args)) {
            M.apply(alphaconvert(c, fun), args |> alphaconvert(c))
        }

        (x = M.back_expr) |
        (x = M.primop(_)) |
        (x = M.env_expr) |
        (x = M.error_expr) |
        (x = M.bigint(_)) |
        (x = M.character(_)) |
        (x = M.constructor_info(_)) |
        (x = M.stdint(_)) {
            x
        }

        (M.callcc_expr(e)) {
            M.callcc_expr(alphaconvert(c, e))
        }

        (M.cond_expr(test, branches)) {
            M.cond_expr(alphaconvert(c, test),
                        branches |> alphaconvert(c) && alphaconvert(c))
        }

        (M.construct(name, args)) {
            M.construct(name, args |> alphaconvert(c))
        }

        (M.deconstruct(name, index, expr)) {
            M.deconstruct(name, index, alphaconvert(c, expr))
        }

        (M.if_expr(exprc, exprt, exprf)) {
            M.if_expr(alphaconvert(c, exprc),
                      alphaconvert(c, exprt),
                      alphaconvert(c, exprf))
        }

        (M.lambda(params, body)) {
            let #(en, nsa) = c;
                newparams = params |> GS.genstring;
                ee = Env.add_lists(Env.extend(en), params, newparams);
            in
                M.lambda(newparams, alphaconvert(#(ee, nsa), body))
        }

        (M.letrec_expr(bindings, expr)) {
            let #(en, nsa) = c;
                #(vars, exprs) = unzip bindings;
                newvars = vars |> GS.genstring;
                ee = Env.add_lists(Env.extend(en), vars, newvars);
                newvals = exprs |> alphaconvert(#(ee, nsa)); // in new environment
                newbindings = newvars zip newvals;
            in
                M.letrec_expr(newbindings, alphaconvert(#(ee, nsa), expr)) // new environment
        }

        (M.lookup(name, index, expr)) {
            let #(e, nsa) = c;
                fn find {
                    (0, h @ t) { h }
                    (n, h @ t) { find(n - 1, t) }
                    (_, []) { error("Namespace index out of bounds") }
                }
            in
                M.lookup(name, index, alphaconvert(#(find(index, nsa), nsa), expr))
        }

        (M.make_tuple(args)) {
            M.make_tuple(args |> alphaconvert(c))
        }

        (M.make_vec(size, args)) {
            M.make_vec(size, args |> alphaconvert(c))
        }

        (M.match_cases(test, cases)) {
            M.match_cases(alphaconvert(c, test),
                          cases |> identity && alphaconvert(c))
        }

        (M.namespaces(exprs)) {
            M.namespaces(exprs |> alphaconvert(c))
        }

        (M.print_exp(expr)) {
            M.print_exp(alphaconvert(c, expr))
        }

        (M.sequence(exprs)) {
            M.sequence(exprs |> alphaconvert(c))
        }

        (M.tag(expr)) {
            M.tag(alphaconvert(c, expr))
        }

        (M.tuple_index(size, index, expr)) {
            M.tuple_index(size, index, alphaconvert(c, expr))
        }

        (M.typedefs(defs, expr)) {
            M.typedefs(defs, alphaconvert(c, expr))
        }

        (M.typeof_expr(expr)) {
            M.typeof_expr(alphaconvert(c, expr))
        }
        (M.var(name)) {
            let #(e, nsa) = c;
                v = Env.get(e, name);
            in
                switch (v) {
                    (nothing) {
                        error("Unbound variable: " @@ name)
                    }
                    (x=just(vname)) {
                        M.var(vname)
                    }
                }
        }

        (x) {
            M.print_expr(x);
            puts("\n");
            error("alphaconvert: unsupported expression")
        }
    }
}