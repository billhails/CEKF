namespace
    link "minexpr.fn" as M;
    link "env.fn" as Env;
    link "subst.fn" as SUBST;
    link "../listutils.fn" as list;
    link "../dictutils.fn" as DICT;
    link "../ioutils.fn" as io;
    import io operator "$_"; // to-string

    fn reduce(e) {
    let
        fn genstring(p) { p @@ "$" @@ $incr() }

        fn gensym(p) { M.var(genstring(p)) }

        fn subst (expr, var, arg) { // replace var with arg in expr
            SUBST.substitute(DICT.make([var], [arg]), expr)
        }

        fn βr(c, e) {
            switch (e) {
                (M.amb_expr(expr1, expr2)) {
                    // amb_expr(expr, expr)
                    M.amb_expr(βr(c, expr1), βr(c, expr2))
                }

                (M.apply(fun, args)) {
                    // apply(expr, list(expr))
                    M.apply(βr(c, fun), list.map(fn (arg) { βr(c, arg) }, args))
                }

                (M.apply_closure(closure, args)) {
                    // apply_closure(expr, list(expr))
                    M.apply_closure(βr(c, closure),
                                    list.map(fn (arg) { βr(c, arg) }, args))
                }

                (x = M.back_expr) |
                (x = M.env_expr) |
                (x = M.error_expr) |
                (x = M.bigint(_)) |
                (x = M.character(_)) |
                (x = M.stdint(_)) {
                    x
                }

                (M.callcc_expr(e)) {
                    // callcc_expr(expr)
                    M.callcc_expr(βr(c, e))
                }

                (M.make_closure(lambda_expr, env)) {
                    // closure(expr, list(string))
                    M.make_closure(βr(c, lambda_expr), βr(c, env))
                }

                (M.cond_expr(test, branches)) {
                    // cond_expr(expr, list(#(expr, expr)))
                    let #(vals, results) = list.unzip(branches);
                    in
                        M.cond_expr(βr(c, test),
                                    list.zip(list.map(βr(c), vals),
                                            list.map(βr(c), results)))
                }

                (M.if_expr(exprc, exprt, exprf)) {
                    // if_expr(expr, expr, expr)
                    M.if_expr(βr(c, exprc),
                            βr(c, exprt),
                            βr(c, exprf))
                }

                (M.lambda(params, body)) {
                    // lambda(list(string), expr)
                    let #(en, nsa) = c;
                        newparams = list.map(genstring, params);
                        ee = Env.add_lists(Env.extend(en), params, newparams);
                    in
                        M.lambda(newparams, βr(#(ee, nsa), body))
                }

                (M.lambdac(params, body)) {
                    // lambdac(list(string), expr)
                    let #(en, nsa) = c;
                        newparams = list.map(genstring, params);
                        ee = Env.add_lists(Env.extend(en), params, newparams);
                    in
                        M.lambdac(newparams, βr(#(ee, nsa), body))
                }

                (M.make_env(bindings)) {
                    // make_env(list(expr))
                    let #(en, nsa) = c;
                        #(vars, exprs) = list.unzip(bindings);
                        newvals = list.map(βr(c), exprs); // in current environment
                        newbindings = list.zip(vars, newvals);
                    in
                        M.make_env(newbindings)
                }

                (M.env_ref(env, name)) {
                    // env_ref(expr, string)
                    M.env_ref(βr(c, env), name)
                }

                (M.letrec_expr(bindings, expr)) {
                    // letrec_expr(list(#(string, expr)), expr)
                    let #(en, nsa) = c;
                        #(vars, exprs) = list.unzip(bindings);
                        newvars = list.map(genstring, vars);
                        ee = Env.add_lists(Env.extend(en), vars, newvars);
                        newvals = list.map(βr(#(ee, nsa)), exprs); // in new environment
                        newbindings = list.zip(newvars, newvals);
                    in
                        M.letrec_expr(newbindings, βr(#(ee, nsa), expr)) // new environment
                }

                (M.lookup(name, index, expr)) {
                    // lookup(string, number, expr)
                    let #(e, nsa) = c;
                        fn find {
                            (0, h @ t) { h }
                            (n, h @ t) { find(n - 1, t) }
                            (_, []) { Env.root }
                        }
                    in
                        M.lookup(name, index, βr(#(find(index, nsa), nsa), expr))
                }

                (M.make_vec(size, args)) {
                    // make_vec(number, list(expr))
                    M.make_vec(size, list.map(βr(c), args))
                }

                (M.match_cases(test, cases)) {
                    // match_cases(expr, list(#(list(number), expr)))
                    let #(vals, results) = list.unzip(cases);
                    in
                        M.match_cases(βr(c, test),
                                    list.zip(vals, list.map(βr(c), results)))
                }

                (M.namespaces(exprs)) {
                    // namespaces(list(expr))
                    M.namespaces(list.map(βr(c), exprs))
                }

                (M.primapp(p, e1, e2)) {
                    // primapp(string, expr, expr)
                    M.primapp(p, βr(c, e1), βr(c, e2))
                }

                (M.sequence(exprs)) {
                    // sequence(list(expr))
                    M.sequence(list.map(βr(c), exprs))
                }

                (M.var(name)) {
                    // var(string)
                    let #(e, nsa) = c;
                        v = Env.get(e, name);
                    in
                        switch (v) {
                            (nothing) {
                                M.var("unbound-variable-" @@ name)
                            }
                            (x=some(vname)) {
                                M.var(vname)
                            }
                        }
                }

                (x) {
                    M.print_expr(x);
                    puts("\n");
                    error("reduce: unsupported expression")
                }
            }
        }
    in
        βr(#(Env.add(Env.extend(Env.root), "□", genstring("□")), []), e)
    }