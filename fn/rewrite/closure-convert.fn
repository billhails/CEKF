namespace
link "../listutils.fn" as list;
link "../dictutils.fn" as DICT;
link "minexpr.fn" as M;
link "transform.fn" as TR;
link "freevars.fn" as FV;
link "gensym.fn" as GS;
link "subst.fn" as SUBST;
import list operator "_|>_";

// https://matt.might.net/articles/closure-conversion/

// How to avoid having to declare extra types just to support closure conversion?
// I'm thinking make_env is obviously just make_vec, likewise make_closure.
// env_ref becomes vec, lambdac becomes lambda.
// The `(VEC index vector)` needs to know the index of the var in the vector.
// That can work if we keep an additional IntMap from fv to index, and sort
// by that when creating the make_vec env.
// apply closure is just `(Î» (vec . args) (apply (VEC 0 vec) (cons (VEC 1 vec) args)))`
// How to optimize that?
// minApplyClosure(vec, args) |-->
//     newMinApply(newMinPrimApp(MINPRIMOP_TYPE_VEC, 0, vec),
//                 newMinExprList(newMinPrimApp(MINPRIMOP_TYPE_VEC, 1, vec), args))
fn closure_convert {
    (exp=M.lambda(params, body)) {
        let
            senv = GS.genstring("$env");
            sparams = senv @ params;
            fv = FV.free(exp);
            venv = fv |> fn (v) { #(v, M.var(v)) };
            sub = DICT.make(fv, fv |> fn (v) { M.env_ref(M.var(senv), v) });
            vbody = SUBST.substitute(sub, body);
        in
            M.make_closure(M.lambdac(sparams, vbody), M.make_env(venv))
    }
    (x=M.apply(M.primop(_), _)) { x }
    (M.apply(func, args)) {
        M.apply_closure(func, args)
    }
    (x) { x }
}

fn flat_closure_convert(exp) { TR.bottom_up(closure_convert, exp) }
fn shared_closure_convert(exp) { TR.top_down(closure_convert, exp) }