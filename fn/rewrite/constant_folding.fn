namespace

// operator and constant folding

link "minexpr.fn" as M;
link "../listutils.fn" as list;

fn simplify (e) {
    let
        // a more convenient form for doing algebra
        typedef term {
            num(number) |
            add(term, term) |
            sub(term, term) |
            mul(term, term) |
            div(term, term) |
            pow(term, term) |
            other(M.expr)
        }

        // allow for commutativity of add and mul
        EQ term {
            (add(a, b), add(a, b)) |
            (add(b, a), add(a, b)) |
            (sub(a, b), sub(a, b)) |
            (mul(a, b), mul(a, b)) |
            (mul(b, a), mul(a, b)) |
            (div(a, b), div(a, b)) |
            (pow(a, b), pow(a, b)) |
            (num(a), num(a)) |
            (other(a), other(a)) { true }
            (_, _) { false }
        }

        fn term_to_expr(term) {
            switch(term) {
                (num(n))    { M.bigint(n) }
                (add(a, b)) { M.apply(M.primop("+"), [term_to_expr(a), term_to_expr(b)]) }
                (sub(a, b)) { M.apply(M.primop("-"), [term_to_expr(a), term_to_expr(b)]) }
                (mul(a, b)) { M.apply(M.primop("*"), [term_to_expr(a), term_to_expr(b)]) }
                (div(a, b)) { M.apply(M.primop("/"), [term_to_expr(a), term_to_expr(b)]) }
                (pow(a, b)) { M.apply(M.primop("**"), [term_to_expr(a), term_to_expr(b)]) }
                (other(x))  { x }
            }
        }

        fn expr_to_term(expr) {
            let
                result = switch(expr) {
                    (M.bigint(n)) {
                        num(n)
                    }
                    (M.apply(M.primop("+"), [e1, e2])) {
                        add(expr_to_term(e1), expr_to_term(e2))
                    }
                    (M.apply(M.primop("-"), [e1, e2])) {
                        sub(expr_to_term(e1), expr_to_term(e2))
                    }
                    (M.apply(M.primop("*"), [e1, e2])) {
                        mul(expr_to_term(e1), expr_to_term(e2))
                    }
                    (M.apply(M.primop("/"), [e1, e2])) {
                        div(expr_to_term(e1), expr_to_term(e2))
                    }
                    (M.apply(M.primop("**"), [e1, e2])) {
                        pow(expr_to_term(e1), expr_to_term(e2))
                    }
                    (x) {
                        other(x)
                    }
                }
            in
                result
        }

// patterns that may be reduced (n is number, x is other)
// (n op n)
// (n op x) [for certain n, i.e. 0 or 1]
// (x op n) [for certain n]
// (n op (x op n))
// (n op (n op x))
// ((x op n) op n)
// ((n op x) op n)
// ((x op n) op (x op n))
// ((x op n) op (n op x))
// ((n op x) op (x op n))
// ((n op x) op (n op x))
//
// (**) < (*, /) < (+, -)
//
        fn sim(term) {
            let basis = switch(term) {
                    (num(_)) | (other(_)) { term }
                    (add(x, y)) { add(sim(x), sim(y)) }
                    (sub(x, y)) { sub(sim(x), sim(y)) }
                    (mul(x, y)) { mul(sim(x), sim(y)) }
                    (div(x, y)) { div(sim(x), sim(y)) }
                    (pow(x, y)) { pow(sim(x), sim(y)) }
                };
            in
                switch(basis) {
                    // a + b
                    (add(num(a), num(b))) { num(a + b) }
                    // 0 + a = a + 0 = a
                    (add(num(0), a))      |
                    (add(a, num(0)))      { a }
                    // a + (0 - a) = 0
                    (add(a, sub(num(0), a))) |
                    (add(sub(num(0), a), a)) { num(0) }
                    // a + (b + x) = a + (x + b) = (a + x) + b = (x + a) + b = (a + b) + x
                    (add(num(a), add(num(b), x))) |
                    (add(num(a), add(x, num(b)))) |
                    (add(add(x, num(a)), num(b))) |
                    (add(add(num(a), x), num(b))) { sim(add(num(a + b), x)) }
                    // a + (b - x) = (b - x) + a = (a + b) - x
                    (add(num(a), sub(num(b), x))) |
                    (add(sub(num(b), x), num(a))) { sim(sub(num(a + b), x)) }
                    // a + (x - b) = (x - b) + a = (a - b) + x
                    (add(num(a), sub(x, num(b)))) |
                    (add(sub(x, num(b)), num(a))) { sim(add(num(a - b), x)) }
                    // + + +
                    // (a + x) + (b + y) = (a + b) + (x + y)
                    (add(add(num(a), x), add(num(b), y))) |
                    (add(add(num(a), x), add(y, num(b)))) |
                    (add(add(x, num(a)), add(num(b), y))) |
                    (add(add(x, num(a)), add(y, num(b)))) { sim(add(num(a + b), add(x, y))) }
                    // + + -
                    // (a + x) + (b - y) = (b - y) + (a + x) = (a + b) + (x - y)
                    (add(add(num(a), x), sub(num(b), y))) |
                    (add(sub(num(b), y), add(num(a), x))) |
                    (add(add(x, num(a)), sub(num(b), y))) |
                    (add(sub(num(b), y), add(x, num(a)))) { sim(add(num(a + b), sub(x, y))) }
                    // (a + x) + (y - b) = (y - b) + (a + x) = (a - b) + (x + y)
                    (add(add(num(a), x), sub(y, num(b)))) |
                    (add(sub(y, num(b)), add(num(a), x))) |
                    (add(add(x, num(a)), sub(y, num(b)))) |
                    (add(sub(y, num(b)), add(x, num(a)))) { sim(add(num(a - b), add(x, y))) }
                    // - + -
                    // (a - x) + (b - y) = (b - y) + (a - x) = (a + b) - (x + y)
                    (add(sub(num(a), x), sub(num(b), y))) |
                    (add(sub(num(b), y), sub(num(a), x))) { sim(sub(num(a + b), add(x, y))) }
                    // (x - a) + (b - y) = (b - y) + (x - a) = (b - a) + (x - y)
                    (add(sub(x, num(a)), sub(num(b), y))) |
                    (add(sub(num(b), y), sub(x, num(a)))) { sim(add(num(b - a), sub(x, y))) }
                    // (x - a) + (y - b) = (y - b) + (x - a) = (x + y) - (a + b)
                    (add(sub(x, num(a)), sub(y, num(b)))) |
                    (add(sub(y, num(b)), sub(x, num(a)))) { sim(sub(add(x, y), num(a + b))) }

                    // a - b
                    (sub(num(a), num(b))) { num(a - b) }
                    // a - 0 = a
                    (sub(a, num(0))) { a }
                    // MISSING: 0 - a could be reduced to neg(a) or mul(num(-1), a)
                    // there is no negation operator currently

                    (sub(x, x)) { num(0) }
                    
                    // a - (b + x) = a - (x + b) = (a - b) - x
                    (sub(num(a), add(num(b), x))) |
                    (sub(num(a), add(x, num(b))) ) { sim(sub(num(a - b), x)) }
                    // (a + x) - b = (x + a) - b = (a - b) + x
                    (sub(add(num(a), x), num(b))) |
                    (sub(add(x, num(a)), num(b))) { sim(add(num(a - b), x)) }
                    // (a - x) - b = (a - b) - x
                    (sub(sub(num(a), x), num(b))) { sim(sub(num(a - b), x)) }
                    // (x - a) - b = (x - (a + b))
                    (sub(sub(x, num(a)), num(b))) { sim(sub(x, num(a + b))) }
                    // a - (b - x) = a - b + x = (a - b) + x
                    (sub(num(a), sub(num(b), x))) { sim(add(num(a - b), x)) }
                    // a - (x - b) = a - x + b = (a + b) - x
                    (sub(num(a), sub(x, num(b)))) { sim(sub(num(a + b), x)) }
                    // + - +
                    // (a + x) - (b + y) = (x + a) - (y + b) = (a - b) + (x - y)
                    (sub(add(num(a), x), add(num(b), y))) |
                    (sub(add(x, num(a)), add(num(b), y))) |
                    (sub(add(num(a), x), add(y, num(b)))) |
                    (sub(add(x, num(a)), add(y, num(b)))) { sim(add(num(a - b), sub(x, y))) }
                    // - - +
                    // (a - x) - (b + y) = (a - b) - (x + y)
                    (sub(sub(num(a), x), add(num(b), y))) |
                    (sub(sub(num(a), x), add(y, num(b)))) { sim(sub(num(a - b), add(x, y))) }
                    // (x - a) - (b + y) = (x - (a + b)) - y
                    (sub(sub(x, num(a)), add(num(b), y))) |
                    (sub(sub(x, num(a)), add(y, num(b)))) { sim(sub(sub(x, num(a + b)), y)) }
                    // (a + x) - (b - y) = a + x - b + y = (a - b) + (x + y)
                    (sub(add(num(a), x), sub(num(b), y))) |
                    (sub(add(x, num(a)), sub(num(b), y))) { sim(add(num(a - b), add(x, y))) }
                    // (a + x) - (y - b) = a + x - y + b = (a + b) + (x - y)
                    (sub(add(num(a), x), sub(y, num(b)))) |
                    (sub(add(x, num(a)), sub(y, num(b)))) { sim(add(num(a + b), sub(x, y))) }
                    // (x + a) - (b - y)
                    (sub(add(x, num(a)), sub(num(b), y))) |
                    (sub(add(x, num(a)), sub(y, num(b)))) { sim(add(num(a - b), add(x, y))) }
                    // (x + a) - (y - b)
                    (sub(add(num(a), x), sub(y, num(b)))) |
                    (sub(add(x, num(a)), sub(y, num(b)))) { sim(add(num(a + b), sub(x, y))) }
                    
                    // - - -
                    // (a - x) - (b - y) = a - x - b + y = (a - b) - (x - y)
                    (sub(sub(num(a), x), sub(num(b), y))) { sim(sub(num(a - b), sub(x, y))) }
                    // (x - a) - (b - y) = (x - (a + b)) + y
                    (sub(sub(x, num(a)), sub(num(b), y))) { sim(add(sub(x, num(a + b)), y)) }
                    // (x - a) - (y - b) = (b - a) + (x - y)
                    (sub(sub(x, num(a)), sub(y, num(b)))) { sim(add(num(b - a), sub(x, y))) }
                    // (a - x) - (y - b) = a - x - y + b = (a + b) - (x + y)
                    (sub(sub(num(a), x), sub(y, num(b)))) { sim(sub(num(a + b), add(x, y))) }

                    // a * b
                    (mul(num(a), num(b))) { num(a * b) }
                    // 0 * a = a * 0 = 0
                    (mul(num(0), a))      |
                    (mul(a, num(0)))      { num(0) }
                    // 1 * a = a * 1 = a
                    (mul(num(1), a))      |
                    (mul(a, num(1)))      { a }
                    // x * (1 / x) = 1
                    (mul(x, div(num(1), x))) |
                    (mul(div(num(1), x), x)) { num(1) }
                    // x * x = x ** 2
                    (mul(a, a)) { pow(a, num(2)) }
                    // x * x ** n = x ** (n + 1)
                    (mul(a, pow(a, b))) |
                    (mul(pow(a, b), a)) { sim(pow(a, add(b, num(1)))) }

                    // MISSING: (-1) * a = -a (if you have negation)
                    // there is no negation operator currently
                    
                    // a * (b * x) = a * (x * b) = (a * x) * b = (x * a) * b = (a * b) * x
                    (mul(num(a), mul(num(b), x))) |
                    (mul(num(a), mul(x, num(b)))) |
                    (mul(mul(x, num(a)), num(b))) |
                    (mul(mul(num(a), x), num(b))) { sim(mul(num(a * b), x)) }
                    // a * (x + b) = a * (b + x) = (x + b) * a = (b + x) * a = (a * b) + (a * x)
                    (mul(num(a), add(x, num(b)))) |
                    (mul(num(a), add(num(b), x))) |
                    (mul(add(x, num(b)), num(a))) |
                    (mul(add(num(b), x), num(a))) { sim(add(num(a * b), mul(num(a), x))) }
                    // a * (x - b) = (x - b) * a = (a * x) - (a * b)
                    (mul(num(a), sub(x, num(b)))) |
                    (mul(sub(x, num(b)), num(a))) { sim(sub(mul(num(a), x), num(a * b))) }
                    // a * (b - x) = (b - x) * a = (a * b) - (a * x)
                    (mul(num(a), sub(num(b), x))) |
                    (mul(sub(num(b), x), num(a))) { sim(sub(num(a * b), mul(num(a), x))) }
                    // a * (b / x) = (b / x) * a = (a * b) / x
                    (mul(num(a), div(num(b), x))) |
                    (mul(div(num(b), x), num(a))) { sim(div(num(a * b), x)) }
                    // a * (x / b) = (x / b) * a = (a / b) * x
                    (mul(num(a), div(x, num(b)))) |
                    (mul(div(x, num(b)), num(a))) { sim(mul(num(a / b), x)) }
                    // MISSING: a * (b ** x) - no simple reduction
                    // MISSING: (a + x) * (b + y) - could expand but increases term count
                    
                    (div(num(a), num(b))) { num(a / b) }
                    // a / 1 = a
                    (div(a, num(1))) { a }
                    // 0 / a = 0
                    (div(num(0), _)) { num(0) }
                    (div(x, x)) { num(1) }
                    
                    // (x / a) / b = x / (a * b)
                    (div(div(x, num(a)), num(b))) { sim(div(x, num(a * b))) }
                    // (a / x) / b = (a / b) / x
                    (div(div(num(a), x), num(b))) { sim(div(num(a / b), x)) }
                    // a / (b / x) = (a / b) * x
                    (div(num(a), div(num(b), x))) { sim(mul(num(a / b), x)) }
                    // a / (x / b) = (a * b) / x
                    (div(num(a), div(x, num(b))) ) { sim(div(num(a * b), x)) }
                    // a / (x * b) = a / (b * x) = (a / b) / x
                    (div(num(a), mul(x, num(b)))) |
                    (div(num(a), mul(num(b), x))) { sim(div(num(a / b), x)) }
                    // (a * x) / b = (x * a) / b = (a / b) * x
                    (div(mul(num(a), x), num(b))) |
                    (div(mul(x, num(a)), num(b))) { sim(mul(num(a / b), x)) }
                    // ( x + a) / b = (a + x) / b = (a / b) + (x / b)
                    (div(add(num(a), x), num(b))) |
                    (div(add(x, num(a)), num(b))) { sim(add(num(a / b), div(x, num(b)))) }
                    // (a - x) / b = (a / b) - (x / b)
                    (div(sub(num(a), x), num(b))) { sim(sub(num(a / b), div(x, num(b)))) }
                    // (x - a) / b = (x / b) - (a / b)
                    (div(sub(x, num(a)), num(b))) { sim(sub(div(x, num(b)), num(a / b))) }
                    // (x / a) * (y / b) = (x * y) / (a * b)
                    (mul(div(x, num(a)), div(y, num(b)))) { sim(div(mul(x, y), num(a * b))) }
                    // (a / x) * (b / y) = (a * b) / (x * y)
                    (mul(div(num(a), x), div(num(b), y))) { sim(div(num(a * b), mul(x, y))) }
                    // (x/2) / (y/3) = (x/2) * (3/y) = 3x/2y
                    (div(div(x, num(a)), div(y, num(b)))) { sim(mul(div(x, y), num(b / a))) }    
                    // (2/x) / (3/y) = (2/x) * (y/3) = 2y/3x
                    (div(div(num(a), x), div(num(b), y))) { sim(mul(num(a / b), div(y, x))) }

                    // a ** b
                    (pow(num(a), num(b)))       { num(a ** b) }
                    // x ** 0 = 1 (for x != 0)
                    (pow(_, num(0)))            { num(1) }
                    // x ** 1 = x
                    (pow(x, num(1)))            { x }
                    // 0 ** n = 0
                    (pow(num(0), _))            { num(0) }
                    // 1 ** n = 1
                    (pow(num(1), _))            { num(1) }
                    // (x ** a) ** b = x ** (a * b)
                    (pow(pow(x, a), b))         { sim(pow(x, mul(a, b))) }
                    // x ** a * x ** b = x ** (a + b)
                    (mul(pow(x, a), pow(x, b))) { sim(pow(x, add(a, b))) }
                    
                    (x) { x }
                };
        }
    in
        term_to_expr(sim(expr_to_term(e)))
}

fn fold {
    (M.amb_expr(expr1, expr2)) {
        // amb_expr(expr, expr)
        M.amb_expr(fold(expr1), fold(expr2))
    }

    (x = M.apply(fun, args)) {
        // apply(expr, list(expr))
        {
        let f = fold(fun);
            a = list.map(fold, args);
        in
            switch (f) {
                (M.primop(_)) {
                    simplify(M.apply(f, a))
                }
                (_) {
                    M.apply(f, a)
                }
            }
        }
    }

    (x = M.back_expr) |
    (x = M.primop(_)) |
    (x = M.env_expr) |
    (x = M.error_expr) |
    (x = M.bigint(_)) |
    (x = M.character(_)) |
    (x = M.var(_)) |
    (x = M.stdint(_)) {
        x
    }

    (M.callcc_expr(e)) {
        // callcc_expr(expr)
        M.callcc_expr(fold(e))
    }

    (M.cond_expr(test, branches)) {
        // cond_expr(expr, list(#(expr, expr)))
        let #(vals, results) = list.unzip(branches);
        in
            M.cond_expr(fold(test),
                        list.zip(list.map(fold, vals),
                                list.map(fold, results)))
    }

    (M.if_expr(exprc, exprt, exprf)) {
        // if_expr(expr, expr, expr)
        let exprc = fold(exprc);
        in
            switch (exprc) {
                (M.bigint(n)) {
                    if (n != 0) {
                        fold(exprt)
                    } else {
                        fold(exprf)
                    }
                }
                (_) {
                    M.if_expr(exprc, fold(exprt), fold(exprf))
                }
            }
    }

    (M.lambda(params, body)) {
        // lambda(list(string), expr)
        M.lambda(params, fold(body))
    }

    (M.letrec_expr(bindings, expr)) {
        // letrec_expr(list(#(string, expr)), expr)
        let #(vars, exprs) = list.unzip(bindings);
            newexprs = list.map(fold, exprs);
            newbindings = list.zip(vars, newexprs);
        in
            M.letrec_expr(newbindings, fold(expr))
    }

    (M.lookup(name, index, expr)) {
        // lookup(string, number, expr)
        M.lookup(name, index, fold(expr))
    }

    (M.make_vec(size, args)) {
        // make_vec(number, list(expr))
        M.make_vec(size, list.map(fold, args))
    }

    (M.match_cases(test, cases)) {
        // match_cases(expr, list(#(list(number), expr)))
        let #(vals, results) = list.unzip(cases);
        in
            M.match_cases(fold(test),
                        list.zip(vals, list.map(fold, results)))
    }

    (M.namespaces(exprs)) {
        // namespaces(list(expr))
        M.namespaces(list.map(fold, exprs))
    }

    (M.sequence(exprs)) {
        // sequence(list(expr))
        M.sequence(list.map(fold, exprs))
    }

    (x) {
        M.print_expr(x);
        puts("\n");
        error("fold: unsupported expression")
    }
}