
namespace
link "minexpr.fn" as M;
link "../listutils.fn" as list;

// free: expr -> list(string)
fn free {

    // amb_expr(expr, expr)
    (M.amb_expr(e1, e2)) {
        list.unique(free(e1) @@ free(e2))
    }

    // apply[_closure](expr, list(expr))
    (M.apply_closure(f, args)) | (M.apply(f, args)) {
        list.unique(list.concat(free(f) @ list.map(free, args)))
    }

    // back_expr
    (M.back_expr) |
    // bigint(number)
    (M.bigint(_)) |
    // character(char)
    (M.character(_)) |
    // env_expr
    (M.env_expr) |
    // error_expr
    (M.error_expr) |
    // stdint(number)
    (M.stdint(_)) { [] }

    // callcc_expr(expr)
    (M.callcc_expr(e)) {
        free(e)
    }

    // env_ref(expr, string)
    (M.env_ref(e, s)) {
        free(e)
    }

    // cond_expr(expr, list(#(expr, expr)))
    (M.cond_expr(test, branches)) {
        list.unique(free(test) @@ list.concat(list.map(fn (#(cond, res)) {
            list.unique(free(cond) @@ free(res))
        }, branches)))
    }

    // env_ref(expr, string)
    (M.env_ref(e, s)) {
        free(e)
    }

    // if_expr(expr, expr, expr)
    (M.if_expr(cond, then_branch, else_branch)) {
        list.unique(free(cond) @@ free(then_branch) @@ free(else_branch))
    }

    // lambda[c](list(string), expr)
    (M.lambda(params, body)) | (M.lambdac(params, body)) {
        list.exclude(params, free(body))
    }

    // letrec_expr(list(#(string, expr)), expr)
    (M.letrec_expr(bindings, body)) {
        let
            #(names, exprs) = list.unzip(bindings);
        in
            list.exclude(names, list.unique(list.concat(list.map(free, exprs)) @@ free(body)))
    }

    // lookup(string, number, expr)
    (M.lookup(s, n, e)) {
        free(e)
    }

    // make_closure(expr, expr)
    (M.make_closure(fun, env)) {
        list.unique(free(fun) @@ free(env));
    }

    // make_env(list(#(string, expr)))
    (M.make_env(bindings)) {
        let #(vs, es) = list.unzip(bindings);
        in list.unique(list.concat(list.map(free, es)))
    }

    // make_vec(number, list(expr))
    (M.make_vec(n, elements)) {
        list.unique(list.concat(list.map(free, elements)))
    }

    // match_cases(expr, list(#(list(number), expr)))
    (M.match_cases(scrutinee, cases)) {
        list.unique(free(scrutinee) @@ list.concat(list.map(fn (#(nums, e)) {
            free(e)
        }, cases)))
    }

    // namespaces(list(expr))
    (M.namespaces(exprs)) {
        list.unique(list.concat(list.map(free, exprs)))
    }

    // primapp(string, expr, expr)
    (M.primapp(op, e1, e2)) {
        list.unique(free(e1) @@ free(e2))
    }

    // sequence(list(expr))
    (M.sequence(exps)) {
        list.unique(list.concat(list.map(free, exps)))
    }

    // var(string)
    (M.var(v)) { [v] }

    (e) {
        M.print_expr(e);
        puts(": ");
        error("unhandled expr type");
    }
}