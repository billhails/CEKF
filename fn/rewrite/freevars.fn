
namespace
link "minexpr.fn" as M;
link "../listutils.fn" as list;
import list operator "_|>_";

// free: expr -> list(string)
fn free {

    (M.amb_expr(e1, e2)) {
        list.unique(free(e1) @@ free(e2))
    }

    (M.apply_closure(f, args)) | (M.apply(f, args)) {
        list.unique(list.concat(free(f) @ (args |> free)))
    }

    (M.back_expr) |
    (M.bigint(_)) |
    (M.primop(_)) |
    (M.character(_)) |
    (M.env_expr) |
    (M.error_expr) |
    (M.stdint(_)) { [] }

    (M.callcc_expr(e)) {
        free(e)
    }

    (M.env_ref(e, s)) {
        free(e)
    }

    (M.cond_expr(test, branches)) {
        list.unique(free(test) @@ list.concat(branches |> fn (#(cond, res)) {
            list.unique(free(cond) @@ free(res))
        }))
    }

    (M.env_ref(e, s)) {
        free(e)
    }

    (M.if_expr(cond, then_branch, else_branch)) {
        list.unique(free(cond) @@ free(then_branch) @@ free(else_branch))
    }

    (M.lambda(params, body)) | (M.lambdac(params, body)) {
        list.exclude(params, free(body))
    }

    (M.letrec_expr(bindings, body)) {
        let
            #(names, exprs) = list.unzip(bindings);
        in
            list.exclude(names, list.unique(list.concat(exprs |> free) @@ free(body)))
    }

    (M.lookup(s, n, e)) {
        free(e)
    }

    (M.make_closure(fun, env)) {
        list.unique(free(fun) @@ free(env));
    }

    (M.make_env(bindings)) {
        let #(_, es) = list.unzip(bindings);
        in list.unique(list.concat(es |> free))
    }

    (M.make_vec(n, elements)) {
        list.unique(list.concat(elements |> free))
    }

    (M.match_cases(scrutinee, cases)) {
        list.unique(free(scrutinee) @@
        list.concat(cases |> fn (#(_, e)) { free(e) }))
    }

    (M.namespaces(exprs)) {
        list.unique(list.concat(exprs |> free))
    }

    (M.sequence(exps)) {
        list.unique(list.concat(exps |> free))
    }

    (M.var(v)) { [v] }

    (e) {
        M.print_expr(e);
        puts(": ");
        error("unhandled expr type");
    }
}