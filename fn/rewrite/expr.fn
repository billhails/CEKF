namespace
    link "../listutils.fn" as list;
    import list operator "_|>_";

    typedef expr {
        amb_expr(expr, expr) |
        apply(expr, list(expr)) |
        back_expr |
        bigint(number) |
        callcc_expr(expr) |
        character(char) |
        cond_expr(expr, list(#(expr, expr))) |
        constant(string, number) |
        constructor_info(string) |
        construct(string, number, list(expr)) |
        deconstruct(string, number, expr) |
        env_expr |
        error_expr |
        if_expr(expr, expr, expr) |
        lambda(list(string), expr) |
        let_expr(list(#(string, expr)), expr) |
        letrec_expr(list(#(string, expr)), expr) |
        letstar_expr(list(#(string, expr)), expr) |
        lookup(string, number, expr) |
        make_tuple(list(expr)) |
        make_vec(number, list(expr)) |
        match_cases(expr, list(#(list(number), expr))) |
        namespaces(list(expr)) |
        primapp(string, expr, expr) |
        print_exp(expr) |
        sequence(list(expr)) |
        stdint(number) |
        tag(expr) |
        tuple_index(number, number, expr) |
        typedefs(number, expr) |
        typeof_expr(expr) |
        var(string)
    }

    // Helper printers
    fn print_list(indices, putter, space) {
        switch (indices) {
            ([]) { "" }
            (h @ t) {
                putter(h);
                list.for_each (fn(i) { puts(space); putter(i) }, t);
                ""
            }
        };
    }

    fn print_bindings(bindings) {
        print_list(bindings, fn(#(name, expr)) {
            putc('(');
            puts(name);
            putc(' ');
            print_expr(expr);
            putc(')');
        }, " ");
    }

    fn print_let(name, bindings, body) {
        puts("(");
        puts(name);
        puts(" [");
        print_bindings(bindings);
        puts("] ");
        print_expr(body);
        puts(")");
    }

    fn print_sequence(exprs) {
        list.for_each (fn(e) { puts(" "); print_expr(e) }, exprs);
    }

    // Printer for expressions
    fn print_expr {
        (x=callcc_expr(e)) {
            puts("(call/cc ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=typeof_expr(e)) {
            puts("(typeof ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=typedefs(defs, expr)) {
            puts("(typedefs ");
            putn(defs);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=tuple_index(size, index, expr)) {
            puts("(tuple-index ");
            putn(size);
            puts(" ");
            putn(index);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=tag(e)) {
            puts("(tag ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=stdint(i)) {
            putn(i);
            x;
        }
        (x=sequence(exprs)) {
            puts("(begin");
            print_sequence(exprs);
            puts(")");
            x;
        }
        (x=print_exp(e)) {
            puts("(print ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=primapp(name, e1, e2)) {
            puts("(");
            puts(name);
            puts(" ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(")");
            x;
        }
        (x=namespaces(exprs)) {
            puts("(namespaces");
            print_sequence(exprs);
            puts(")");
            x;
        }
        (x=match_cases(exp, cases)) {
            puts("(match-cases ");
            print_expr(exp);
            list.for_each (fn {
                (#(indices, caseExpr)) {
                    puts(" ((");
                    print_list(indices, fn(i) { putn(i) }, " ");
                    puts(") ");
                    print_expr(caseExpr);
                    puts(")");
                }
            }, cases);
            puts(")");
            x;
        }
        (x=make_vec(size, elements)) {
            puts("(make-vec ");
            putn(size);
            print_sequence(elements);
            puts(")");
            x;
        }
        (x=make_tuple(elements)) {
            puts("(make-tuple");
            print_sequence(elements);
            puts(")");
            x;
        }
        (x=lookup(name, index, expr)) {
            puts("(lookup ");
            puts(name);
            puts(" ");
            putn(index);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=env_expr) {
            puts("(env)");
            x;
        }
        (x=error_expr) {
            puts("(error)");
            x;
        }
        (x=deconstruct(name, index, expr)) {
            puts("(deconstruct ");
            puts(name);
            puts(" ");
            putn(index);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=constructor_info(name)) {
            puts("(constructor-info ");
            puts(name);
            puts(")");
            x;
        }
        (x=construct(name, tg, args)) {
            puts("(construct ");
            puts(name);
            putc(' ');
            putn(tg);
            print_sequence(args);
            puts(")");
            x;
        }
        (x=constant(name, tg)) {
            puts("(constant ");
            puts(name);
            putc(' ');
            putn(tg);
            puts(")");
            x;
        }
        (x=cond_expr(test, branches)) {
            puts("(cond ");
            print_expr(test);
            list.for_each (fn {
                (#(e1, e2)) {
                    puts(" ");
                    putc('(');
                    print_expr(e1);
                    puts(" ");
                    print_expr(e2);
                    putc(')');
                }
            }, branches);
            puts(")");
            x;
        }
        (x=letrec_expr(bindings, body)) {
            print_let("letrec", bindings, body);
            x;
        }
        (x=let_expr(bindings, body)) {
            print_let("let", bindings, body);
            x;
        }
        (x=letstar_expr(bindings, body)) {
            print_let("let*", bindings, body);
            x;
        }
        (x=lambda(args, expr)) {
            puts("(Î» (");
            print_list(args, fn(name) { puts(name) }, " ");
            puts(") ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=if_expr(e1, e2, e3)) {
            puts("(if ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(" ");
            print_expr(e3);
            puts(")");
            x;
        }
        (x=apply(e1, args)) {
            puts("(");
            print_expr(e1);
            print_sequence(args);
            puts(")");
            x;
        }
        (x=bigint(i)) {
            putn(i);
            x;
        }
        (x=var(chars)) {
            puts(chars);
            x;
        }
        (x=amb_expr(e1, e2)) {
            puts("(amb ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(")");
            x;
        }
        (x=back_expr) {
            puts("(back)");
            x;
        }
        (x=character(c)) {
            putc('\'');
            putc(c);
            putc('\'');
            x;
        }
    }

    // A *very* dumb parser for basic s-expressions
    fn parse(s) {
        let
            // IR for the parser "tokenization"
            typedef sexpr {
                atom(string) |
                sexp(list(sexpr))
            }

            fn to_number(s) {
                let
                    fn to_digit {
                        ('0') { 0 }
                        ('1') { 1 }
                        ('2') { 2 }
                        ('3') { 3 }
                        ('4') { 4 }
                        ('5') { 5 }
                        ('6') { 6 }
                        ('7') { 7 }
                        ('8') { 8 }
                        ('9') { 9 }
                        (_) { error("Invalid digit") }
                    }
                    fn helper {
                        ([], acc) { acc }
                        (c @ rest, acc) {
                            let
                                digit = to_digit(c);
                            in
                                helper(rest, acc * 10 + digit);
                        }
                    }
                in
                    helper(s, 0)
            }

            fn atom_to_string {
                (atom(s)) { s }
                (_) { error("Expected atom") }
            }

            fn to_expr {
                (atom("back")) { back_expr }
                (atom("true")) { constant("true", 1) }
                (atom("false")) { constant("false", 0) }
                (atom("null")) { constant("null", 0) }
                (atom(['\'', c, '\''])) { character(c) }
                (sexp([atom("env")])) { env_expr }
                (sexp([atom("error")])) { error_expr }
                (atom(x = '0' @ rest)) | (atom(x = '1' @ rest)) | (atom(x = '2' @ rest)) |
                (atom(x = '3' @ rest)) | (atom(x = '4' @ rest)) | (atom(x = '5' @ rest)) |
                (atom(x = '6' @ rest)) | (atom(x = '7' @ rest)) | (atom(x = '8' @ rest)) |
                (atom(x = '9' @ rest)) { bigint(to_number(x))}
                (atom(s)) { var(s) }
                (sexp([atom("amb"), a, b])) { amb_expr(to_expr(a), to_expr(b)) }
                (sexp([atom("call/cc"), e])) { callcc_expr(to_expr(e)) }
                (sexp([atom("if"), e1, e2, e3])) { if_expr(to_expr(e1), to_expr(e2), to_expr(e3)) }
                (sexp(atom("cond") @ test @ branches)) { cond_expr(to_expr(test), branches |> fn {
                    (sexp([e1, e2])) { #(to_expr(e1), to_expr(e2)) }
                    (_) { error("Invalid cond branch") }
                }) }
                (sexp([atom("constant"), atom(name), atom(tg)])) { constant(name, to_number(tg)) }
                (sexp([atom("constructor_info"), atom(name)])) { constructor_info(name) }
                (sexp(atom("construct") @ atom(name) @ atom(tg) @ args)) {
                    construct(name, to_number(tg), args |> to_expr)
                }
                (sexp([atom("deconstruct"), atom(name), atom(index), e])) {
                    deconstruct(name, to_number(index), to_expr(e))
                }
                (sexp([atom("lambda"), sexp(args), body])) |
                (sexp([atom("\u03bb;"),      sexp(args), body])) {
                    lambda(args |> atom_to_string, to_expr(body))
                }
                (sexp(atom("begin") @ exprs)) { sequence(exprs |> to_expr) }
                (sexp([atom("let"), sexp(bindings), body])) {
                    let bindingsList = bindings |> fn {
                        (sexp([atom(name), expr])) { #(name, to_expr(expr)) }
                        (_) { error("Invalid let binding") }
                    };
                    in
                        let_expr(bindingsList, to_expr(body))
                }
                (sexp([atom("letrec"), sexp(bindings), body])) {
                    let bindingsList = bindings |> fn {
                        (sexp([atom(name), expr])) { #(name, to_expr(expr)) }
                        (_) { error("Invalid letrec binding") }
                    };
                    in
                        letrec_expr(bindingsList, to_expr(body))
                }
                (sexp([atom("let*"), sexp(bindings), body])) {
                    let bindingsList = bindings |> fn {
                        (sexp([atom(name), expr])) { #(name, to_expr(expr)) }
                        (_) { error("Invalid let* binding") }
                    };
                    in
                        letstar_expr(bindingsList, to_expr(body))
                }
                (sexp([atom("lookup"), atom(name), atom(index), e])) { lookup(name, to_number(index), to_expr(e)) }
                (sexp(atom("make_tuple") @ elements)) { make_tuple(elements |> to_expr) }
                (sexp(atom("make_vec") @ atom(size) @ elements)) { make_vec(to_number(size), elements |> to_expr) }
                (sexp(atom("match_cases") @ exp @ cases)) { match_cases(to_expr(exp), cases |> fn {
                    (sexp([sexp(indices), caseExpr])) {
                        let indexList = indices |> fn {
                            (atom(i)) { to_number(i) }
                            (_) { error("Invalid match_cases index") }
                        };
                        in
                            #(indexList, to_expr(caseExpr))
                    }
                    (_) { error("Invalid match_cases case") }
                }) }
                (sexp(atom("namespaces") @ exprs)) { namespaces(exprs |> to_expr) }
                (sexp([atom("+"), e1, e2])) { primapp("+", to_expr(e1), to_expr(e2)) }
                (sexp([atom("-"), e1, e2])) { primapp("-", to_expr(e1), to_expr(e2)) }
                (sexp([atom("*"), e1, e2])) { primapp("*", to_expr(e1), to_expr(e2)) }
                (sexp([atom("/"), e1, e2])) { primapp("/", to_expr(e1), to_expr(e2)) }
                (sexp([atom("%"), e1, e2])) { primapp("%", to_expr(e1), to_expr(e2)) }
                (sexp([atom("**"), e1, e2])) { primapp("**", to_expr(e1), to_expr(e2)) }
                (sexp([atom("=="), e1, e2])) { primapp("==", to_expr(e1), to_expr(e2)) }
                (sexp([atom("="), e1, e2])) { primapp("=", to_expr(e1), to_expr(e2)) }
                (sexp([atom("<"), e1, e2])) { primapp("<", to_expr(e1), to_expr(e2)) }
                (sexp([atom(">"), e1, e2])) { primapp(">", to_expr(e1), to_expr(e2)) }
                (sexp([atom("<="), e1, e2])) { primapp("<=", to_expr(e1), to_expr(e2)) }
                (sexp([atom(">="), e1, e2])) { primapp(">=", to_expr(e1), to_expr(e2)) }
                (sexp([atom("print"), e])) { print_exp(to_expr(e)) }
                (sexp([atom("tag"), e])) { tag(to_expr(e)) }
                (sexp([atom("tuple_index"), atom(size), atom(index), e])) { tuple_index(1, 1, to_expr(e)) }
                (sexp([atom("typedefs"), atom(defs), e])) { typedefs(1, to_expr(e)) }
                (sexp([atom("typeof"), e])) { typeof_expr(to_expr(e)) }
                (sexp([])) { error("Empty expression") }
                (sexp(func @ args)) { apply(to_expr(func), args |> to_expr) }
                (x) {
                    print x;
                    error("Cannot parse expression");
                }
            }

            // "Tokenizer" function
            fn parse_sexpr(s) {
                let
                    fn parse_atom {
                        ([], acc) { #(atom(list.reverse(acc)), []) }
                        (' ' @ rest, acc) { #(atom(list.reverse(acc)), rest) }
                        (')' @ rest, acc) { #(atom(list.reverse(acc)), ')' @ rest) }
                        (c @ rest, acc) { parse_atom(rest, c @ acc) }
                    }

                    fn parse_list {
                        ([], _) { error("Unexpected end of input") }
                        (')' @ rest, acc) { #(sexp(list.reverse(acc)), rest) }
                        (' ' @ rest, acc) { parse_list(rest, acc) }
                        (input, acc) {
                            let
                                #(sexpr, rest) = parse_sexpr(input);
                            in
                                parse_list(rest, sexpr @ acc)
                        }
                    }
                in
                    switch (s) {
                        ([]) { error("Unexpected end of input") }
                        ('(' @ rest) { parse_list(rest, []) }
                        (' ' @ rest) { parse_sexpr(rest) }
                        (')' @ rest) { error("Unexpected )") }
                        (c @ rest) { parse_atom(rest, [c]) }
                    }
            }
        in {
            let #(sexpr, rest) = parse_sexpr(s);
            in if (list.empty(rest)) {
                to_expr(sexpr);
            } else {
                 error("Extra input after expression: " @@ rest);
            }
        }
    }