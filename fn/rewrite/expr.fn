namespace
    link "../listutils.fn" as list;

    typedef expr {
        amb_expr(expr, expr) |
        apply(expr, list(expr)) |
        back_expr |
        bigint(number) |
        callcc_expr(expr) |
        character(char) |
        cond_expr(expr, list(#(expr, expr))) |
        constant(string) |
        constructor_info(string) |
        construct(string, list(expr)) |
        deconstruct(string, number, expr) |
        env_expr |
        error_expr |
        if_expr(expr, expr, expr) |
        lambda(list(expr), expr) |
        let_expr(expr, expr, expr) |
        letrec_expr(list(#(string, expr)), expr) |
        lookup(string, number, expr) |
        make_tuple(list(expr)) |
        make_vec(number, list(expr)) |
        match_cases(expr, list(#(list(number), expr))) |
        namespaces(list(expr)) |
        primapp(string, expr, expr) |
        print_exp(expr) |
        sequence(list(expr)) |
        stdint(number) |
        tag(expr) |
        tuple_index(number, number, expr) |
        typedefs(number, expr) |
        typeof_expr(expr) |
        var(string)
    }

    ///// Printer for expressions

    fn print_expr {
        (x=callcc_expr(e)) {
            puts("(call/cc ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=typeof_expr(e)) {
            puts("(typeof ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=typedefs(defs, expr)) {
            puts("(typedefs ");
            putn(defs);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=tuple_index(size, index, expr)) {
            puts("(tuple_index ");
            putn(size);
            puts(" ");
            putn(index);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=tag(e)) {
            puts("(tag ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=stdint(i)) {
            putn(i);
            x;
        }
        (x=sequence(exprs)) {
            puts("(begin");
            list.map (fn(e) { puts(" "); print_expr(e) }, exprs);
            puts(")");
            x;
        }
        (x=print_exp(e)) {
            puts("(print ");
            print_expr(e);
            puts(")");
            x;
        }
        (x=primapp(name, e1, e2)) {
            puts("(");
            puts(name);
            puts(" ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(")");
            x;
        }
        (x=namespaces(exprs)) {
            puts("(namespaces");
            list.map (fn(e) { puts(" "); print_expr(e) }, exprs);
            puts(")");
            x;
        }
        (x=match_cases(exp, cases)) {
            puts("(match_cases ");
            print_expr(exp);
            list.for_each (fn {
                (#(indices, caseExpr)) {
                    puts(" ((");
                    switch (indices) {
                        ([]) { "" }
                        (h @ t) {
                            putn(h);
                            list.for_each (fn(i) { puts(" "); putn(i) }, t);
                            ""
                        }
                    };
                    puts(") ");
                    print_expr(caseExpr);
                    puts(")");
                }
            }, cases);
            puts(")");
            x;
        }
        (x=make_vec(size, elements)) {
            puts("(make_vec ");
            putn(size);
            list.map (fn(e) { puts(" "); print_expr(e) }, elements);
            puts(")");
            x;
        }
        (x=make_tuple(elements)) {
            puts("(make_tuple");
            list.map (fn(e) { puts(" "); print_expr(e) }, elements);
            puts(")");
            x;
        }
        (x=lookup(name, index, expr)) {
            puts("(lookup ");
            puts(name);
            puts(" ");
            putn(index);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=env_expr) {
            puts("(env)");
            x;
        }
        (x=error_expr) {
            puts("(error)");
            x;
        }
        (x=deconstruct(name, index, expr)) {
            puts("(deconstruct ");
            puts(name);
            puts(" ");
            putn(index);
            puts(" ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=constructor_info(name)) {
            puts("(constructor_info ");
            puts(name);
            puts(")");
            x;
        }
        (x=construct(name, args)) {
            puts("(construct ");
            puts(name);
            list.map (fn(e) { puts(" "); print_expr(e) }, args);
            puts(")");
            x;
        }
        (x=constant(name)) {
            puts("(constant ");
            puts(name);
            puts(")");
            x;
        }
        (x=cond_expr(test, branches)) {
            puts("(cond ");
            print_expr(test);
            list.for_each (fn {
                (#(e1, e2)) {
                    puts(" ");
                    putc('(');
                    print_expr(e1);
                    puts(" ");
                    print_expr(e2);
                    putc(')');
                }
            }, branches);
            puts(")");
            x;
        }
        (x=letrec_expr(bindings, body)) {
            puts("(letrec (");
            list.for_each (fn {
                (#(name, expr)) {
                    putc('(');
                    puts(name);
                    putc(' ');
                    print_expr(expr);
                    putc(')');
                }
            }, bindings);
            puts(") ");
            print_expr(body);
            puts(")");
            x;
        }
        (x=lambda(args, expr)) {
            puts("(Î» (");
            switch (args) {
                ([]) { "" }
                (h @ t) {
                    print_expr(h);
                    list.for_each (fn(e) { putc(' '); print_expr(e) }, t);
                    ""
                }
            };
            puts(") ");
            print_expr(expr);
            puts(")");
            x;
        }
        (x=let_expr(e1, e2, e3)) {
            puts("(let (");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(") ");
            print_expr(e3);
            puts(")");
            x;
        }
        (x=if_expr(e1, e2, e3)) {
            puts("(if ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(" ");
            print_expr(e3);
            puts(")");
            x;
        }
        (x=apply(e1, args)) {
            puts("(");
            print_expr(e1);
            list.map (fn(e) { puts(" "); print_expr(e) }, args);
            puts(")");
            x;
        }
        (x=bigint(i)) {
            putn(i);
            x;
        }
        (x=var(chars)) {
            puts(chars);
            x;
        }
        (x=amb_expr(e1, e2)) {
            puts("(amb ");
            print_expr(e1);
            puts(" ");
            print_expr(e2);
            puts(")");
            x;
        }
        (x=back_expr) {
            puts("(back)");
            x;
        }
        (x=character(c)) {
            putc('\'');
            putc(c);
            putc('\'');
            x;
        }
    }

    // A *very* dumb parser for basic s-expressions

    // IR for the parser "tokenization"
    typedef sexpr {
        atom(string) |
        sexp(list(sexpr))
    }

    fn to_number(s) {
        let
            fn to_digit {
                ('0') { 0 }
                ('1') { 1 }
                ('2') { 2 }
                ('3') { 3 }
                ('4') { 4 }
                ('5') { 5 }
                ('6') { 6 }
                ('7') { 7 }
                ('8') { 8 }
                ('9') { 9 }
                (_) { error("Invalid digit") }
            }
            fn helper {
                ([], acc) { acc }
                (c @ rest, acc) {
                    let
                        digit = to_digit(c);
                    in
                        helper(rest, acc * 10 + digit);
                }
            }
        in
            helper(s, 0)
    }

    fn to_expr {
        (atom("back")) { back_expr }
        (atom(['\'', c, '\''])) { character(c) }
        (sexp([atom("env")])) { env_expr }
        (sexp([atom("error")])) { error_expr }
        (atom(x = '0' @ rest)) |
        (atom(x = '1' @ rest)) |
        (atom(x = '2' @ rest)) |
        (atom(x = '3' @ rest)) |
        (atom(x = '4' @ rest)) |
        (atom(x = '5' @ rest)) |
        (atom(x = '6' @ rest)) |
        (atom(x = '7' @ rest)) |
        (atom(x = '8' @ rest)) |
        (atom(x = '9' @ rest)) { bigint(to_number(x))}
        (atom(s)) { var(s) }
        (sexp([atom("amb"), a, b])) { amb_expr(to_expr(a), to_expr(b)) }
        (sexp([atom("call/cc"), e])) { callcc_expr(to_expr(e)) }
        (sexp([atom("if"), e1, e2, e3])) { if_expr(to_expr(e1), to_expr(e2), to_expr(e3)) }
        (sexp(atom("cond") @ test @ branches)) { cond_expr(to_expr(test), list.map (fn {
            (sexp([e1, e2])) { #(to_expr(e1), to_expr(e2)) }
            (_) { error("Invalid cond branch") }
        }, branches)) }
        (sexp([atom("constant"), atom(name)])) { constant(name) }
        (sexp([atom("constructor_info"), atom(name)])) { constructor_info(name) }
        (sexp(atom("construct") @ atom(name) @ args)) { construct(name, list.map(to_expr, args)) }
        (sexp([atom("deconstruct"), atom(name), atom(index), e])) { deconstruct(name, to_number(index), to_expr(e)) }
        (sexp([atom("lambda"), sexp(args), body])) { lambda(list.map(to_expr, args), to_expr(body)) }
        (sexp(atom("begin") @ exprs)) { sequence(list.map(to_expr, exprs)) }
        (sexp([atom("let"), sexp([e1, e2]), e3])) { let_expr(to_expr(e1), to_expr(e2), to_expr(e3)) }
        (sexp([atom("letrec"), sexp(bindings), body])) {
            let bindingsList = list.map (fn {
                (sexp([atom(name), expr])) { #(name, to_expr(expr)) }
                (_) { error("Invalid letrec binding") }
            }, bindings);
            in
                letrec_expr(bindingsList, to_expr(body))
        }
        (sexp([atom("lookup"), atom(name), atom(index), e])) { lookup(name, to_number(index), to_expr(e)) }
        (sexp(atom("make_tuple") @ elements)) { make_tuple(list.map(to_expr, elements)) }
        (sexp(atom("make_vec") @ atom(size) @ elements)) { make_vec(to_number(size), list.map(to_expr, elements)) }
        (sexp(atom("match_cases") @ exp @ cases)) { match_cases(to_expr(exp), list.map (fn {
            (sexp([sexp(indices), caseExpr])) {
                let indexList = list.map (fn {
                    (atom(i)) { to_number(i) }
                    (_) { error("Invalid match_cases index") }
                }, indices);
                in
                    #(indexList, to_expr(caseExpr))
            }
            (_) { error("Invalid match_cases case") }
        }, cases)) }
        (sexp(atom("namespaces") @ exprs)) { namespaces(list.map(to_expr, exprs)) }
        (sexp([atom("+"), e1, e2])) { primapp("+", to_expr(e1), to_expr(e2)) }
        (sexp([atom("-"), e1, e2])) { primapp("-", to_expr(e1), to_expr(e2)) }
        (sexp([atom("*"), e1, e2])) { primapp("*", to_expr(e1), to_expr(e2)) }
        (sexp([atom("/"), e1, e2])) { primapp("/", to_expr(e1), to_expr(e2)) }
        (sexp([atom("**"), e1, e2])) { primapp("**", to_expr(e1), to_expr(e2)) }
        (sexp([atom("=="), e1, e2])) { primapp("==", to_expr(e1), to_expr(e2)) }
        (sexp([atom("<"), e1, e2])) { primapp("<", to_expr(e1), to_expr(e2)) }
        (sexp([atom(">"), e1, e2])) { primapp(">", to_expr(e1), to_expr(e2)) }
        (sexp([atom("<="), e1, e2])) { primapp("<=", to_expr(e1), to_expr(e2)) }
        (sexp([atom(">="), e1, e2])) { primapp(">=", to_expr(e1), to_expr(e2)) }
        (sexp([atom("print"), e])) { print_exp(to_expr(e)) }
        (sexp([atom("tag"), e])) { tag(to_expr(e)) }
        (sexp([atom("tuple_index"), atom(size), atom(index), e])) { tuple_index(1, 1, to_expr(e)) }
        (sexp([atom("typedefs"), atom(defs), e])) { typedefs(1, to_expr(e)) }
        (sexp([atom("typeof"), e])) { typeof_expr(to_expr(e)) }
        (sexp(func @ args)) { apply(to_expr(func), list.map(to_expr, args)) }
        (x) { error("Cannot parse expression"); }
    }

    fn parse(s) {
        let #(sexpr, rest) = parse_sexpr(s);
        in to_expr(sexpr);
    }

    // "Tokenizer" functions

    fn parse_atom {
        ([], acc) { #(atom(list.reverse(acc)), []) }
        (' ' @ rest, acc) { #(atom(list.reverse(acc)), rest) }
        (')' @ rest, acc) { #(atom(list.reverse(acc)), ')' @ rest) }
        (c @ rest, acc) { parse_atom(rest, c @ acc) }
    }

    fn parse_list {
        ([], _) { error("Unexpected end of input") }
        (')' @ rest, acc) { #(sexp(list.reverse(acc)), rest) }
        (' ' @ rest, acc) { parse_list(rest, acc) }
        (input, acc) {
            let
                #(sexpr, rest) = parse_sexpr(input);
            in
                parse_list(rest, sexpr @ acc)
        }
    }

    fn parse_sexpr {
        ([]) { error("Unexpected end of input") }
        ('(' @ rest) { parse_list(rest, []) }
        (' ' @ rest) { parse_sexpr(rest) }
        (')' @ rest) { error("Unexpected )") }
        (c @ rest) { parse_atom(rest, [c]) }
    }