namespace
    link "expr.fn" as E;
    link "../dictutils.fn" as D;
    link "../listutils.fn" as list;

    // substitute: D.Dict(string, E.expr) -> E.expr -> E.expr
    fn substitute(c, e) {
        if (D.is_empty(c)) {
            e
        } else {
            switch (e) {
                // amb_expr(expr, expr)
                (E.amb_expr(expr1, expr2)) {
                    E.amb_expr(substitute(c, expr1), substitute(c, expr2))
                }

                // apply_closure(expr, list(expr))
                (E.apply_closure(f, args)) {
                    E.apply_closure(substitute(c, f), list.map(substitute(c), args))
                }

                // apply(expr, list(expr))
                (E.apply(fun, args)) {
                    E.apply(substitute(c, fun), list.map(substitute(c), args))
                }

                (x = E.back_expr) |
                (x = E.env_expr) |
                (x = E.error_expr) |
                (x = E.bigint(_)) |
                (x = E.character(_)) |
                (x = E.constructor_info(_)) |
                (x = E.stdint(_)) |
                (x = E.constant(_)) {
                    x
                }

                // callcc_expr(expr)
                (E.callcc_expr(e)) {
                    E.callcc_expr(substitute(c, e))
                }

                // cond_expr(expr, list(#(expr, expr)))
                (E.cond_expr(test, branches)) {
                    let #(vals, results) = list.unzip(branches);
                    in  E.cond_expr(substitute(c, test),
                                    list.zip(list.map(substitute(c), vals),
                                            list.map(substitute(c), results)))
                }

                // construct(string, list(expr))
                (E.construct(name, args)) {
                    E.construct(name, list.map(substitute(c), args))
                }

                // deconstruct(string, number, expr)
                (E.deconstruct(name, index, expr)) {
                    E.deconstruct(name, index, substitute(c, expr))
                }

                // if_expr(expr, expr, expr)
                (E.if_expr(exprc, exprt, exprf)) {
                    E.if_expr(substitute(c, exprc),
                            substitute(c, exprt),
                            substitute(c, exprf))
                }

                // lambda(list(string), expr)
                (E.lambda(params, body)) {
                    let c2 = D.delete_list(params, c);
                    in E.lambda(params, substitute(c2, body))
                }

                // lambda(list(string), expr)
                (E.lambdac(params, body)) {
                    let c2 = D.delete_list(params, c);
                    in E.lambdac(params, substitute(c2, body))
                }

                // make_closure(expr, env)
                (E.make_closure(body, env)) {
                    E.make_closure(substitute(c, body), substitute(c, env))
                }

                // make_env(list(#(string, expr)))
                (E.make_env(bindings)) {
                    E.make_env(list.map(fn (#(v, e)) { #(v, substitute(c, e)) }, bindings))
                }

                // env_ref(expr, string)
                (E.env_ref(e, s)) {
                    E.env_ref(substitute(c, e), s)
                }

                // letrec_expr(list(#(string, expr)), expr)
                (E.letrec_expr(bindings, expr)) {
                    let c2 = D.delete_list(list.map(fn (#(var, val)) { var }, bindings), c);
                    in E.letrec_expr(bindings, substitute(c2, expr)) // new environment
                }

                // let_expr(list(#(string, expr)), expr)
                (E.let_expr(bindings, expr)) {
                    let c2 = D.delete_list(list.map(fn (#(var, val)) { var }, bindings), c);
                    in E.let_expr(bindings, substitute(c2, expr))
                }

                // letstar_expr(list(#(string, expr)), expr)
                (E.letstar_expr(bindings, expr)) {
                    let c2 = D.delete_list(list.map(fn (#(var, val)) { var }, bindings), c);
                    in E.letstar_expr(bindings, substitute(c2, expr))
                }

                // lookup(string, number, expr)
                (E.lookup(name, index, expr)) {
                    e
                }

                // make_tuple(list(expr))
                (E.make_tuple(args)) {
                    E.make_tuple(list.map(substitute(c), args))
                }

                // make_vec(number, list(expr))
                (E.make_vec(size, args)) {
                    E.make_vec(size, list.map(substitute(c), args))
                }

                // match_cases(expr, list(#(list(number), expr)))
                (E.match_cases(test, cases)) {
                    let #(vals, results) = list.unzip(cases);
                    in
                        E.match_cases(substitute(c, test),
                                    list.zip(vals, list.map(substitute(c), results)))
                }

                // namespaces(list(expr))
                (E.namespaces(exprs)) {
                    E.namespaces(list.map(substitute(c), exprs))
                }

                // primapp(string, expr, expr)
                (E.primapp(p, e1, e2)) {
                    E.primapp(p, substitute(c, e1), substitute(c, e2))
                }

                // print_exp(expr)
                (E.print_exp(expr)) {
                    E.print_exp(substitute(c, expr))
                }

                // sequence(list(expr))
                (E.sequence(exprs)) {
                    E.sequence(list.map(substitute(c), exprs))
                }

                // tag(expr)
                (E.tag(expr)) {
                    E.tag(substitute(c, expr))
                }

                // tuple_index(number, number, expr)
                (E.tuple_index(size, index, expr)) {
                    E.tuple_index(size, index, substitute(c, expr))
                }

                // typedefs(list(def), expr)
                (E.typedefs(defs, expr)) {
                    E.typedefs(defs, substitute(c, expr))
                }

                // typeof_expr(expr)
                (E.typeof_expr(expr)) {
                    E.typeof_expr(substitute(c, expr))
                }

                // var(string)
                (E.var(name)) {
                    switch (D.lookup(name, c)) {
                        (nothing) { e }
                        (some(v)) { v }
                    }
                }

                (x) {
                    E.print_expr(x);
                    puts("\n");
                    error("substitute: unsupported expression")
                }
            }
        }
    }