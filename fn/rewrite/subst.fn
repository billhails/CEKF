namespace
    link "expr.fn" as E;
    link "../dictutils.fn" as D;
    link "../listutils.fn" as list;

    // subst: D.Dict(string, E.expr) -> E.expr -> E.expr
    fn substitute(c, e) {
        switch (e)  {
            (E.amb_expr(expr1, expr2)) {
                // amb_expr(expr, expr)
                E.amb_expr(substitute(c, expr1), substitute(c, expr2))
            }

            // apply_closure(expr, list(expr))
            (E.apply_closure(f, args)) {
                E.apply_closure(substitute(c, f), list.map(substitute(c), args))
            }

            (E.apply(fun, args)) {
                // apply(expr, list(expr))
                E.apply(substitute(c, fun), list.map(substitute(c), args))
            }

            (x = E.back_expr) |
            (x = E.env_expr) |
            (x = E.error_expr) |
            (x = E.bigint(_)) |
            (x = E.character(_)) |
            (x = E.constructor_info(_)) |
            (x = E.stdint(_)) |
            (x = E.constant(_)) {
                x
            }

            (E.callcc_expr(e)) {
                // callcc_expr(expr)
                E.callcc_expr(substitute(c, e))
            }

            (E.cond_expr(test, branches)) {
                // cond_expr(expr, list(#(expr, expr)))
                let #(vals, results) = list.unzip(branches);
                in  E.cond_expr(substitute(c, test),
                                list.zip(list.map(substitute(c), vals),
                                         list.map(substitute(c), results)))
            }

            (E.construct(name, args)) {
                // construct(string, list(expr))
                E.construct(name, list.map(substitute(c), args))
            }

            (E.deconstruct(name, index, expr)) {
                // deconstruct(string, number, expr)
                E.deconstruct(name, index, substitute(c, expr))
            }

            (E.if_expr(exprc, exprt, exprf)) {
                // if_expr(expr, expr, expr)
                E.if_expr(substitute(c, exprc),
                          substitute(c, exprt),
                          substitute(c, exprf))
            }

            (E.lambda(params, body)) {
                // lambda(list(string), expr)
                let c2 = D.delete_list(params, c);
                in E.lambda(params, substitute(c2, body))
            }

            (E.lambdac(params, body)) {
                // lambda(list(string), expr)
                let c2 = D.delete_list(params, c);
                in E.lambdac(params, substitute(c2, body))
            }

            (E.make_closure(body, env)) {
                // make_closure(expr, env)
                E.make_closure(substitute(c, body), substitute(c, env))
            }

            // make_env(list(#(string, expr)))
            (E.make_env(bindings)) {
                E.make_env(list.map(fn (#(v, e)) { #(v, substitute(c, e)) }, bindings))
            }

            // env_ref(expr, string)
            (E.env_ref(e, s)) {
                E.env_ref(substitute(c, e), s)
            }

            (E.letrec_expr(bindings, expr)) {
                // letrec_expr(list(#(string, expr)), expr)
                let c2 = D.delete_list(list.map(fn (#(var, val)) { var }, bindings), c);
                in E.letrec_expr(bindings, substitute(c2, expr)) // new environment
            }

            (E.let_expr(bindings, expr)) {
                // let_expr(list(#(string, expr)), expr)
                let c2 = D.delete_list(list.map(fn (#(var, val)) { var }, bindings), c);
                in E.let_expr(bindings, substitute(c2, expr))
            }

            (E.letstar_expr(bindings, expr)) {
                // letstar_expr(list(#(string, expr)), expr)
                let c2 = D.delete_list(list.map(fn (#(var, val)) { var }, bindings), c);
                in E.letstar_expr(bindings, substitute(c2, expr))
            }

            (E.lookup(name, index, expr)) {
                // lookup(string, number, expr)
                e
            }

            (E.make_tuple(args)) {
                // make_tuple(list(expr))
                E.make_tuple(list.map(substitute(c), args))
            }

            (E.make_vec(size, args)) {
                // make_vec(number, list(expr))
                E.make_vec(size, list.map(substitute(c), args))
            }

            (E.match_cases(test, cases)) {
                // match_cases(expr, list(#(list(number), expr)))
                let #(vals, results) = list.unzip(cases);
                in
                    E.match_cases(substitute(c, test),
                                  list.zip(vals, list.map(substitute(c), results)))
            }

            (E.namespaces(exprs)) {
                // namespaces(list(expr))
                E.namespaces(list.map(substitute(c), exprs))
            }

            (E.primapp(p, e1, e2)) {
                // primapp(string, expr, expr)
                E.primapp(p, substitute(c, e1), substitute(c, e2))
            }

            (E.print_exp(expr)) {
                // print_exp(expr)
                E.print_exp(substitute(c, expr))
            }

            (E.sequence(exprs)) {
                // sequence(list(expr))
                E.sequence(list.map(substitute(c), exprs))
            }

            (E.tag(expr)) {
                // tag(expr)
                E.tag(substitute(c, expr))
            }

            (E.tuple_index(size, index, expr)) {
                // tuple_index(number, number, expr)
                E.tuple_index(size, index, substitute(c, expr))
            }

            (E.typedefs(defs, expr)) {
                // typedefs(list(def), expr)
                E.typedefs(defs, substitute(c, expr))
            }

            (E.typeof_expr(expr)) {
                // typeof_expr(expr)
                E.typeof_expr(substitute(c, expr))
            }
            (E.var(name)) {
                // var(string)
                let v = D.lookup(name, c);
                in
                    switch (v) {
                        (nothing) {
                            e
                        }
                        (some(v)) {
                            v
                        }
                    }
            }

            (x) {
                E.print_expr(x);
                puts("\n");
                error("substitute: unsupported expression")
            }
        }
    }