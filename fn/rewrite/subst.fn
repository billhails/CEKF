namespace
    link "minexpr.fn" as M;
    link "../dictutils.fn" as D;
    link "../listutils.fn" as list;

    // substitute: D.Dict(string, M.expr) -> M.expr -> M.expr
    fn substitute(c, e) {
        if (D.is_empty(c)) {
            e
        } else {
            switch (e) {
                // amb_expr(expr, expr)
                (M.amb_expr(expr1, expr2)) {
                    M.amb_expr(substitute(c, expr1), substitute(c, expr2))
                }

                // apply_closure(expr, list(expr))
                (M.apply_closure(f, args)) {
                    M.apply_closure(substitute(c, f), list.map(substitute(c), args))
                }

                // apply(expr, list(expr))
                (M.apply(fun, args)) {
                    M.apply(substitute(c, fun), list.map(substitute(c), args))
                }

                (x = M.back_expr) |
                (x = M.primop(_)) |
                (x = M.env_expr) |
                (x = M.error_expr) |
                (x = M.bigint(_)) |
                (x = M.character(_)) |
                (x = M.stdint(_)) {
                    x
                }

                // callcc_expr(expr)
                (M.callcc_expr(e)) {
                    M.callcc_expr(substitute(c, e))
                }

                // cond_expr(expr, list(#(expr, expr)))
                (M.cond_expr(test, branches)) {
                    let #(vals, results) = list.unzip(branches);
                    in  M.cond_expr(substitute(c, test),
                                    list.zip(list.map(substitute(c), vals),
                                            list.map(substitute(c), results)))
                }

                // if_expr(expr, expr, expr)
                (M.if_expr(exprc, exprt, exprf)) {
                    M.if_expr(substitute(c, exprc),
                            substitute(c, exprt),
                            substitute(c, exprf))
                }

                // lambda(list(string), expr)
                (M.lambda(params, body)) {
                    let c2 = D.delete_list(params, c);
                    in M.lambda(params, substitute(c2, body))
                }

                // lambda(list(string), expr)
                (M.lambdac(params, body)) {
                    let c2 = D.delete_list(params, c);
                    in M.lambdac(params, substitute(c2, body))
                }

                // make_closure(expr, env)
                (M.make_closure(body, env)) {
                    M.make_closure(substitute(c, body), substitute(c, env))
                }

                // make_env(list(#(string, expr)))
                (M.make_env(bindings)) {
                    M.make_env(list.map(fn (#(v, e)) { #(v, substitute(c, e)) }, bindings))
                }

                // env_ref(expr, string)
                (M.env_ref(e, s)) {
                    M.env_ref(substitute(c, e), s)
                }

                // letrec_expr(list(#(string, expr)), expr)
                (M.letrec_expr(bindings, expr)) {
                    let c2 = D.delete_list(list.map(fn (#(var, val)) { var }, bindings), c);
                    in M.letrec_expr(bindings, substitute(c2, expr)) // new environment
                }

                // lookup(string, number, expr)
                (M.lookup(name, index, expr)) {
                    e
                }

                // make_vec(number, list(expr))
                (M.make_vec(size, args)) {
                    M.make_vec(size, list.map(substitute(c), args))
                }

                // match_cases(expr, list(#(list(number), expr)))
                (M.match_cases(test, cases)) {
                    let #(vals, results) = list.unzip(cases);
                    in
                        M.match_cases(substitute(c, test),
                                    list.zip(vals, list.map(substitute(c), results)))
                }

                // namespaces(list(expr))
                (M.namespaces(exprs)) {
                    M.namespaces(list.map(substitute(c), exprs))
                }

                // sequence(list(expr))
                (M.sequence(exprs)) {
                    M.sequence(list.map(substitute(c), exprs))
                }

                // var(string)
                (M.var(name)) {
                    switch (D.lookup(name, c)) {
                        (nothing) { e }
                        (just(v)) { v }
                    }
                }

                (x) {
                    M.print_expr(x);
                    puts("\n");
                    error("substitute: unsupported expression")
                }
            }
        }
    }