namespace
    fn data() {[
        ";1. Basic application",
        "(g a)",

        ";2. Simple λ application",
        "((λ (x) (h x)) (g 4))",

        ";3. Lambda definition with primitives",
        "(λ (a b) (+ a (* b 2)))",

        ";4. Lambda application with primitives - nested",
        "((λ (a b) (+ a (* b 2))) 3 4)",

        ";5. Lambda application with function call in primitive",
        "((λ (a b) (+ a (* (f b) 2))) 3 4)",

        ";6. Amb operator (non-determinism)",
        "(amb 1 2)",

        ";7. Simple call/cc - immediate escape",
        "(call/cc (λ (k) (k 5)))",

        ";8. Call/cc that doesn't escape",
        "(call/cc (λ (k) 42))",

        ";9. Call/cc with computation before escape",
        "(call/cc (λ (k) (+ 10 (k 5))))",

        ";10. Nested call/cc",
        "(call/cc (λ (k1) (call/cc (λ (k2) (k1 (k2 7))))))",

        ";11. Call/cc with amb",
        "(call/cc (λ (k) (amb (k 1) (k 2))))",

        ";12. Factorial with letrec",
        "(letrec ((fact (λ (n) (if (= n 0) 1 (* n (fact (- n 1))))))) (fact 5))",

        ";13. Multiple argument function",
        "((λ (x y z) (+ x (+ y z))) 1 2 3)",

        ";14. Nested lambdas (currying)",
        "((λ (x) (λ (y) (+ x y))) 5)",

        ";15. Application of curried function",
        "(((λ (x) (λ (y) (+ x y))) 5) 3)",

        ";16. If expression with complex branches",
        "(if (= x 0) (f 1) (g 2))",

        ";17. If with nested if",
        "(if (= x 0) (if (= y 0) 1 2) 3)",

        ";18. Sequence (begin in Racket)",
        "(begin (f 1) (g 2) (h 3))",

        ";19. Letrec with mutual recursion",
        "(letrec ((even (λ (n) (if (= n 0) true (odd (- n 1)))))"
                 "(odd (λ (n) (if (= n 0) false (even (- n 1))))))"
                "(even 5))",

        ";20. Complex amb with computation",
        "(+ (amb 1 2) (amb 3 4))",

        ";21. Nested application",
        "(f (g (h x)))",

        ";22. Multiple primitives in sequence",
        "(+ (* 2 3) (- 5 1))",

        ";23. Lambda with no arguments",
        "((λ () 42))",

        ";24. Call/cc with primitive operations",
        "(call/cc (λ (k) (if (= 1 1) (k 10) 20)))",

        ";25. Deeply nested primitives",
        "(+ 1 (+ 2 (+ 3 (+ 4 5))))",

        ";26. Deeply nested primitives with a function call",
        "(+ 1 (+ 2 (+ 3 (+ 4 (f 5)))))",

        ";27. Application with multiple complex arguments",
        "(f (g a) (h b) (i c))",

        ";28. If where branches have applications",
        "(if test (f (g x)) (h (i y)))",

        ";29. Sequence with amb",
        "(begin (amb 1 2) (amb 3 4))",

        ";30. Call/cc that passes continuation to another function",
        "(call/cc (λ (k) (f k)))",

        ";31. cond expression - like switch/case",
        "(cond x (1 (result1)) (2 (result2)) (3 (result3)))",

        ";32. cond with complex test and results",
        "(cond (f x) (1 (g 1)) (2 (h 2)))",

        ";33. construct with atomic arguments",
        "(construct pair 1 2)",

        ";34. construct with complex arguments",
        "(construct pair (f 1) (g 2))",

        ";35. nested construct",
        "(construct cons (f x) (construct cons (g y) (constant nil)))",

        ";36. deconstruct with atomic argument",
        "(deconstruct pair 0 p)",

        ";37. deconstruct with complex argument",
        "(deconstruct pair 1 (f x))",

        ";38. nested deconstruct",
        "(deconstruct pair 0 (deconstruct pair 1 (f x)))",

        ";39. let with atomic value",
        "(let ((x 42)) (f x))",

        ";40. let with complex value",
        "(let ((x (f 10))) (g x))",

        ";41. nested let",
        "(let ((x (f 1)) (y (g x))) (h x y))",

        ";42. nested let*",
        "(let* ((x (f 1)) (y (g x))) (h x y))",

        ";43. lookup with simple variable",
        "(lookup ns 0 x)",

        ";44. lookup with function call",
        "(lookup ns 0 (f x))",

        ";45. nested lookup",
        "(f (lookup ns 0 (g x)))",

        ";46. make_tuple with atomic args",
        "(make_tuple 1 2 3)",

        ";47. make_tuple with complex args",
        "(make_tuple (f 1) (g 2))",

        ";48. make_tuple with mixed args",
        "(make_tuple x (f y) 42)",

        ";49. make_vec with atomic args",
        "(make_vec 3 1 2 3)",

        ";50. make_vec with complex args",
        "(make_vec 2 (f 1) (g 2))",

        ";51. make_vec with mixed args",
        "(make_vec 3 x (f y) 42)",

        ";52. match_cases with atomic test",
        "(match_cases x ((1 2) (result1)) ((3 4 5) (result2)))",

        ";53. match_cases with complex test",
        "(match_cases (f x) ((1) (g 1)) ((2) (h 2)))",

        ";54. match_cases with complex results",
        "(match_cases x ((1) (f 1)) ((2) (g 2)))",

        ";55. namespaces with atomic expressions",
        "(namespaces x y z)",

        ";56. namespaces with complex expressions",
        "(namespaces (f 1) (g 2))",

        ";57. namespaces with mixed expressions",
        "(namespaces x (f y) z)",

        ";58. namespaces with letrec bodies returning env",
        "(namespaces (letrec ((x (λ () 1)) (y (λ () 2))) (let* ((f 1) (g f)) (env)))"
                    "(letrec ((a (λ () 3)) (b (λ () 4))) (env)))",

        ";59. print_exp with atomic argument",
        "(print x)",

        ";60. print_exp with complex argument",
        "(print (f x))",

        ";61. print_exp nested in computation",
        "(+ (print (f x)) 10)",

        ";62. tag with atomic argument",
        "(tag x)",

        ";63. tag with complex argument",
        "(tag (f x))",

        ";64. tag in cond test",
        "(cond (tag (f x)) (1 (result1)) (2 (result2)))",

        ";65. tuple_index with atomic tuple",
        "(tuple_index 3 0 t)",

        ";66. tuple_index with complex tuple",
        "(tuple_index 2 1 (f x))",

        ";67. nested tuple_index",
        "(tuple_index 2 0 (tuple_index 3 1 (f x)))",

        ";68. typedefs with simple expression",
        "(typedefs 0 x)",

        ";69. typedefs with letrec body",
        "(typedefs 0 (letrec ((f (λ (x) (g x)))) (f 42)))",

        ";70. typedefs with complex body",
        "(typedefs 0 (f (g x)))",

        ";71. typedefs wrapping letrec with env body",
        "(typedefs 0 (letrec ((x (λ () 1)) (y (λ () 2))) (env)))",

        ";72. typeof_expr with atomic argument",
        "(typeof x)",

        ";73. typeof_expr with complex argument",
        "(typeof (f x))",

        ";74. typeof_expr in conditional",
        "(if (typeof (f x)) (g 1) (h 2))",

        ";75. curried function application",
        "(letrec ((add (λ (x y) (+ x y)))) ((add 2) 3))",

        ";76. more complex curried function application",
        "(letrec ((applyf (λ (f) (f 1))) (mul (λ (x y) (* x y)))) (applyf (mul 2)))",

        ";============================================",
        ";CONSTANT FOLDING TEST CASES",
        ";============================================",

        ";--- Addition with numbers and variables ---",
        ";77. Pure constant folding",
        "(+ 3 4)",
        "(+ (+ 1 2) (+ 3 4))",

        ";78. Number + variable combinations",
        "(+ 0 x)",
        "(+ x 0)",
        "(+ 5 (+ 3 x))",
        "(+ 5 (+ x 3))",
        "(+ (+ x 3) 5)",
        "(+ (+ 3 x) 5)",

        ";79. Adding expressions with both + and -",
        "(+ 2 (- 5 x))",
        "(+ 2 (- x 5))",
        "(+ (- 3 x) 4)",
        "(+ (- x 3) 4)",

        ";80. Two compound expressions",
        "(+ (+ 2 x) (+ 3 y))",
        "(+ (+ x 2) (+ y 3))",
        "(+ (+ 2 x) (- 3 y))",
        "(+ (- 2 x) (- 3 y))",
        "(+ (- x 2) (- y 3))",
        "(+ (- x 2) (- 3 y))",

        ";81. Subtraction with numbers and variables ---",
        "(- 10 3)",
        "(- x 0)",
        "(- 0 x)",
        "(- 5 (+ 2 x))",
        "(- 5 (+ x 2))",
        "(- 5 (- 2 x))",
        "(- 5 (- x 2))",
        "(- (+ 5 x) 3)",
        "(- (+ x 5) 3)",
        "(- (- 5 x) 3)",
        "(- (- x 5) 3)",

        ";82. Two compound sub expressions",
        "(- (+ 5 x) (+ 2 y))",
        "(- (- 5 x) (+ 2 y))",
        "(- (+ 5 x) (- 2 y))",
        "(- (+ 5 x) (- y 2))",
        "(- (- 5 x) (- 2 y))",
        "(- (- x 5) (- y 2))",
        "(- (- 5 x) (- y 2))",

        ";83. Multiplication with numbers and variables ---",
        "(* 3 4)",
        "(* 0 x)",
        "(* x 0)",
        "(* 1 x)",
        "(* x 1)",
        "(* 2 (* 3 x))",
        "(* 2 (* x 3))",
        "(* (* x 2) 3)",
        "(* (* 2 x) 3)",

        ";84. Multiplication distributing over addition/subtraction",
        "(* 3 (+ x 4))",
        "(* 3 (+ 4 x))",
        "(* (+ x 4) 3)",
        "(* 3 (- x 4))",
        "(* 3 (- 4 x))",
        "(* (- x 4) 3)",
        "(* (- 4 x) 3)",

        ";85. Multiplication with division",
        "(* 6 (/ 2 x))",
        "(* 6 (/ x 2))",
        "(* (/ x 2) 6)",
        "(* (/ 2 x) 6)",

        ";86. Division with numbers and variables ---",
        "(/ 12 4)",
        "(/ x 1)",
        "(/ 0 x)",
        "(/ (/ x 2) 3)",
        "(/ (/ 6 x) 2)",
        "(/ 6 (/ 2 x))",
        "(/ 6 (/ x 2))",
        "(/ 6 (* x 2))",
        "(/ 6 (* 2 x))",
        "(/ (* 6 x) 2)",
        "(/ (* x 6) 2)",

        ";87. Division distributing over numerator addition/subtraction",
        "(/ (+ 6 x) 2)",
        "(/ (+ x 6) 2)",
        "(/ (- 6 x) 2)",
        "(/ (- x 6) 2)",

        ";88. Compound division expressions",
        "(* (/ x 2) (/ y 3))",
        "(* (/ 2 x) (/ 3 y))",
        "(/ (/ x 2) (/ y 3))",
        "(/ (/ 2 x) (/ 3 y))",

        ";89. Power with numbers and variables ---",
        "(** 2 3)",
        "(** x 0)",
        "(** x 1)",
        "(** 0 x)",
        "(** 1 x)",
        "(** (** x 2) 3)",
        "(* (** x 2) (** x 3))",
        "(** (* x 2) 3)",
        "(** (* 2 x) 3)",

        ";90. Mixed operations - deeper nesting ---",
        "(+ 1 (+ 2 (+ 3 (+ 4 x))))",
        "(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 x))))))",
        "(* 2 (* 3 (* 4 (* 5 x))))",
        "(- 10 (- 9 (- 8 (- 7 (- 6 x)))))",
        "(+ 1 (- 2 (+ 3 (- 4 (+ 5 x)))))",
        "(* 2 (+ 3 (* 4 (+ 5 (* 6 x)))))",
        "(/ (/ (/ (* 24 x) 2) 3) 4)",
        "(** (** x 2) 3)",
        "(* 2 (+ 3 (* 4 x)))",
        "(+ (* 2 3) (* 4 x))",
        "(- (* 2 (+ x 3)) 5)",
        "(/ (+ (* 2 x) 6) 2)",

        ";91. Complex expressions with multiple variables ---",
        "(+ (+ x 1) (+ y 2))",
        "(+ (* 2 x) (* 3 y))",
        "(- (* 2 (+ x 1)) (* 3 (- y 1)))",
        "(/ (+ (* 2 x) 4) 2)",

        ";92. Expressions that should fully reduce to constants ---",
        "(+ (+ 1 2) (+ 3 4))",
        "(* (+ 2 3) (- 10 4))",
        "(/ (* 3 4) (+ 1 1))",
        "(** (+ 1 1) (- 5 2))",
        "(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 6)))))",
        "(* 2 (* 3 (* 4 (* 5 1))))",
        "(- 100 (- 50 (- 25 (- 10 5))))",
        "(/ (* (+ 2 4) (- 8 2)) (** 2 2))",
        "(+ (* 2 (+ 3 4)) (- (* 5 6) (/ 20 4)))",

        ";93. Edge cases ---",
        "(+ (- x x) 5)",
        "(* (/ x x) 5)",
        "(+ x (- 0 x))",
        "(* x (/ 1 x))",

        ";94. Nested with function calls (should partially fold) ---",
        "(+ 3 (+ 4 (f x)))",
        "(* 2 (+ 3 (f x)))",
        "(+ (* 2 3) (f x))",
        "(- (+ 5 (f x)) 3)",
        "(/ (* 6 (f x)) 2)",
        "(+ 1 (+ 2 (+ 3 (+ 4 (f x)))))",
        "(* 2 (* 3 (* 4 (f x))))",
        "(+ (* 2 (+ 3 4)) (f x))",
        "(- (* 2 (+ 5 (f x))) 10)",
        "(/ (* 6 (+ 2 (f x))) 3)",
        "(+ (f x) (+ 1 (+ 2 (+ 3 4))))",
        "(* (+ 2 3) (+ (f x) 10))",

        ";95. Test eta reduction ---",
        "(λ (x) (f x))",
        "(λ (x) ((h p) x))",
        "(λ (y) ((λ (x) (g x)) y))",
        "(λ (y) ((λ (x) ((h p) x)) y))",

        ";96. NEW simplification targets ---",
        "(+ (/ x 2) (/ y 2))",
        "(- (/ x 2) (/ y 2))",
        "(/ (* k x) (* k y))",
    ]};
