namespace
    data = [
        // Basic application
        "(g a)",

        // Simple lambda application
        "((lambda (x) (h x)) (g 4))",

        // Lambda definition with primitives
        "(lambda (a b) (+ a (* b 2)))",

        // Lambda application with primitives - nested
        "((lambda (a b) (+ a (* b 2))) 3 4)",

        // Lambda application with function call in primitive
        "((lambda (a b) (+ a (* (f b) 2))) 3 4)",

        // Amb operator (non-determinism)
        "(amb 1 2)",

        // Simple call/cc - immediate escape
        "(call/cc (lambda (k) (k 5)))",

        // call/cc that doesn't escape
        "(call/cc (lambda (k) 42))",

        // call/cc with computation before escape
        "(call/cc (lambda (k) (+ 10 (k 5))))",

        // Nested call/cc
        "(call/cc (lambda (k1) (call/cc (lambda (k2) (k1 (k2 7))))))",

        // call/cc with amb
        "(call/cc (lambda (k) (amb (k 1) (k 2))))",

        // Factorial with letrec
        "(letrec ((fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))) (fact 5))",

        // Multiple argument function
        "((lambda (x y z) (+ x (+ y z))) 1 2 3)",

        // Nested lambdas (currying)
        "((lambda (x) (lambda (y) (+ x y))) 5)",

        // Application of curried function
        "(((lambda (x) (lambda (y) (+ x y))) 5) 3)",

        // If expression with complex branches
        "(if (= x 0) (f 1) (g 2))",

        // If with nested if
        "(if (= x 0) (if (= y 0) 1 2) 3)",

        // Sequence (begin in Racket)
        "(begin (f 1) (g 2) (h 3))",

        // Letrec with mutual recursion
        "(letrec ((even (lambda (n) (if (= n 0) true (odd (- n 1))))) (odd (lambda (n) (if (= n 0) false (even (- n 1)))))) (even 5))",

        // Complex amb with computation
        "(+ (amb 1 2) (amb 3 4))",

        // Nested application
        "(f (g (h x)))",

        // Multiple primitives in sequence
        "(+ (* 2 3) (- 5 1))",

        // call/cc capturing continuation in letrec
        "(letrec ((k null)) (call/cc (lambda (cont) (begin (set! k cont) 42))))",

        // Lambda with no arguments
        "((lambda () 42))",

        // call/cc with primitive operations
        "(call/cc (lambda (k) (if (= 1 1) (k 10) 20)))",

        // Deeply nested primitives
        "(+ 1 (+ 2 (+ 3 (+ 4 5))))",

        // Deeply nested primitives with a function call
        "(+ 1 (+ 2 (+ 3 (+ 4 (f 5)))))",

        // Application with multiple complex arguments
        "(f (g a) (h b) (i c))",

        // If where branches have applications
        "(if test (f (g x)) (h (i y)))",

        // Sequence with amb
        "(begin (amb 1 2) (amb 3 4))",

        // call/cc that passes continuation to another function
        "(call/cc (lambda (k) (f k)))",

        // cond expression - like switch/case
        "(cond x (1 (result1)) (2 (result2)) (3 (result3)))",

        // cond with complex test and results
        "(cond (f x) (1 (g 1)) (2 (h 2)))",

        // construct with atomic arguments
        "(construct pair 1 2)",

        // construct with complex arguments
        "(construct pair (f 1) (g 2))",

        // nested construct
        "(construct cons (f x) (construct cons (g y) (constant nil)))",

        // deconstruct with atomic argument
        "(deconstruct pair 0 p)",

        // deconstruct with complex argument
        "(deconstruct pair 1 (f x))",

        // nested deconstruct
        "(deconstruct pair 0 (deconstruct pair 1 (f x)))",

        // let with atomic value
        "(let ((x 42)) (f x))",

        // let with complex value
        "(let ((x (f 10))) (g x))",

        // nested let
        "(let ((x (f 1)) (y (g x))) (h x y))",

        // nested let*
        "(let* ((x (f 1)) (y (g x))) (h x y))",

        // lookup with simple variable
        "(lookup ns 0 x)",

        // lookup with function call
        "(lookup ns 0 (f x))",

        // nested lookup
        "(f (lookup ns 0 (g x)))",

        // make_tuple with atomic args
        "(make_tuple 1 2 3)",

        // make_tuple with complex args
        "(make_tuple (f 1) (g 2))",

        // make_tuple with mixed args
        "(make_tuple x (f y) 42)",

        // make_vec with atomic args
        "(make_vec 3 1 2 3)",

        // make_vec with complex args
        "(make_vec 2 (f 1) (g 2))",

        // make_vec with mixed args
        "(make_vec 3 x (f y) 42)",

        // match_cases with atomic test
        "(match_cases x ((1 2) (result1)) ((3 4 5) (result2)))",

        // match_cases with complex test
        "(match_cases (f x) ((1) (g 1)) ((2) (h 2)))",

        // match_cases with complex results
        "(match_cases x ((1) (f 1)) ((2) (g 2)))",

        // namespaces with atomic expressions
        "(namespaces x y z)",

        // namespaces with complex expressions
        "(namespaces (f 1) (g 2))",

        // namespaces with mixed expressions
        "(namespaces x (f y) z)",

        // namespaces with letrec bodies returning env
        "(namespaces (letrec ((x 1) (y 2)) (let* ((f 1) (g f)) (env))) (letrec ((a 3) (b 4)) (env)))",

        // print_exp with atomic argument
        "(print x)",

        // print_exp with complex argument
        "(print (f x))",

        // print_exp nested in computation
        "(+ (print (f x)) 10)",

        // tag with atomic argument
        "(tag x)",

        // tag with complex argument
        "(tag (f x))",

        // tag in cond test
        "(cond (tag (f x)) (1 (result1)) (2 (result2)))",

        // tuple_index with atomic tuple
        "(tuple_index 3 0 t)",

        // tuple_index with complex tuple
        "(tuple_index 2 1 (f x))",

        // nested tuple_index
        "(tuple_index 2 0 (tuple_index 3 1 (f x)))",

        // typedefs with simple expression
        "(typedefs 0 x)",

        // typedefs with letrec body
        "(typedefs 0 (letrec ((f (lambda (x) (g x)))) (f 42)))",

        // typedefs with complex body
        "(typedefs 0 (f (g x)))",

        // typedefs wrapping letrec with env body
        "(typedefs 0 (letrec ((x 1) (y 2)) (env)))",

        // typeof_expr with atomic argument
        "(typeof x)",

        // typeof_expr with complex argument
        "(typeof (f x))",

        // typeof_expr in conditional
        "(if (typeof (f x)) (g 1) (h 2))"
    ];