namespace

link "../listutils.fn" as list;
link "minexpr.fn" as M;
import list operator "_|>_";
import list operator "_&&_";
import list operator "_zip_";
import list operator "unzip_";
import list operator "len_";


fn arity {
    (M.lambda(params, _)) |
    (M.lambdac(params, _)) { len params }
    (_) { 0 }
}

fn curry {
    (M.amb_expr(e1, e2)) {
        M.amb_expr(curry(e1), curry(e2))
    }

    (M.apply(x=M.primop(_), args)) {
        M.apply(x, args |> curry)
    }

    (M.apply(e, [])) {
        M.apply(curry(e), [])
    }

    (M.apply(e, [a])) {
        M.apply(curry(e), [curry(a)])
    }

    (M.apply(e, a @ rest)) {
        curry(M.apply(M.apply(e, [curry(a)]), rest))
    }

    (M.callcc_expr(e)) {
        M.callcc_expr(curry(e))
    }

    (M.cond_expr(e, cases)) {
        M.cond_expr(curry(e), cases |> identity && curry)
    }

    (M.if_expr(e1, e2, e3)) {
        M.if_expr(curry(e1), curry(e2), curry(e3))
    }

    (M.lambda([], body)) {
        M.lambda([], curry(body))
    }

    (M.lambda([a], body)) {
        M.lambda([a], curry(body))
    }

    (M.lambda(a @ rest, body)) {
        M.lambda([a], curry(M.lambda(rest, body)))
    }

    (M.letrec_expr(bindings, body)) {
        let
            #(vars, pairs) = unzip bindings;
            #(exprs, _) = unzip pairs;
            arities = exprs |> arity;
            exprs = exprs |> curry;
            pairs = exprs zip arities;
            bindings = vars zip pairs;
        in
            M.letrec_expr(bindings, curry(body))
    }

    (M.lookup(name, id, e)) {
        M.lookup(name, id, curry(e))
    }

    (M.make_vec(num, exprs)) {
        M.make_vec(num, exprs |> curry)
    }

    (M.match_cases(e, cases)) {
        M.match_cases(curry(e), cases |> identity && curry)
    }

    (M.namespaces(exprs)) {
        M.namespaces(exprs |> curry)
    }

    (M.sequence(exprs)) {
        M.sequence(exprs |> curry)
    }

    (x) { x }
}