namespace

link "minexpr.fn" as M;
link "../listutils.fn" as list;
import list operators;

// (exp -> exp) -> exp -> exp
fn bottom_up(f, exp) {
    f(_transform(bottom_up, f, exp))
}

// (exp -> exp) -> exp -> exp
fn top_down(f, exp) {
    _transform(top_down, f, f(exp))
}

// ((exp -> exp) -> exp -> exp) -> (exp -> exp) -> exp -> exp
fn _transform(t, a, exp) {
    switch (exp) {

        (M.amb_expr(e1, e2)) {
            M.amb_expr(t(a, e1), t(a, e2))
        }

        (M.back_expr) |
        (M.primop(_)) |
        (M.character(_)) |
        (M.stdint(_)) |
        (M.var(_)) |
        (M.bigint(_)) { exp }


        (M.apply_closure(fun, args)) {
            M.apply_closure(t(a, fun), args |> t(a))
        }

        (M.apply(fun, args)) {
            M.apply(t(a, fun), args |> t(a))
        }

        (M.callcc_expr(e)) {
            M.callcc_expr(t(a, e))
        }

        (M.cond_expr(test, branches)) {
            M.cond_expr(t(a, test), branches |> t(a) && t(a))
        }

        (M.env_ref(e, s)) {
            M.env_ref(t(a, e), s)
        }

        (M.if_expr(test, consequent, alternative)) {
            M.if_expr(t(a, test), t(a, consequent), t(a, alternative))
        }

        (M.lambda(params, body)) {
            M.lambda(params, t(a, body))
        }

        (M.lambdac(params, body)) {
            M.lambdac(params, t(a, body))
        }

        (M.letrec_expr(bindings, body)) {
            M.letrec_expr(bindings |> identity && (t(a) && identity), t(a, body))
        }

        (M.make_closure(lam, env)) {
            M.make_closure(t(a, lam), t(a, env))
        }

        (M.make_env(bindings)) {
            M.make_env(bindings |> identity && t(a))
        }

        (M.make_vec(size, elements)) {
            M.make_vec(size, elements |> t(a))
        }

        (M.match_cases(e, cases)) {
            M.match_cases(t(a, e), cases |> identity && t(a))
        }

        (M.sequence(exps)) {
            M.sequence(exps |> t(a))
        }

        (_) {
            M.print_expr(exp);
            puts(": ");
            error("Unhandled expression type in transform")
        }
    };
}