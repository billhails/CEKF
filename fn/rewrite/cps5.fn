let
    link "expr.fn" as E;
    link "../listutils.fn" as lst;
    link "../ioutils.fn" as io;
    import io operator "$_";

    fn gensym(p) { E.var(p @@ $incr()) }

    fn isAexpr {
        (E.var(_)) |
        (E.back_expr) |
        (E.character(_)) |
        (E.constant(_)) |
        (E.constructor_info(_)) |
        (E.env_expr) |
        (E.error_expr) |
        (E.lambda(_, _)) |
        (E.stdint(_)) |
        (E.bigint(_)) { true }
        (_) { false }
    }

    fn M {
        (E.lambda(vars, body)) {
            let k = gensym("$k");
            in E.lambda(vars @@ [k], T_c(body, k))
        }
        (x) { x }
    }

    fn T_k(e, k) {
        if (isAexpr(e)) {
            k(M(e))
        } else {
            switch (e)  {
                (E.amb_expr(expr1, expr2)) {
                    let
                        rv = gensym("$rv");
                        cont = E.lambda([rv], k(rv));
                    in 
                        E.amb_expr(T_c(expr1, cont), T_c(expr2, cont))
                }

                (E.apply(_, _)) {
                    let
                        srv = gensym("$rv");
                        cont = E.lambda([srv], k(srv));
                    in
                        T_c(e, cont)
                }

                (E.callcc_expr(e)) {
                    let
                        rv = gensym("$rv");
                        cont = E.lambda([rv], k(rv));
                    in
                        T_c(E.callcc_expr(e), cont)
                }

                (E.cond_expr(test, branches)) {
                    let
                        rv = gensym("$rv");
                        cont = E.lambda([rv], k(rv));
                    in
                        T_k(test, fn (atest) {
                            E.cond_expr(atest, lst.map(fn {(#(val, result)) {
                                #(val, T_c(result, cont))
                            }}, branches))
                        })
                }

                (E.construct(name, args)) {
                    Ts_k(args, fn (sargs) {
                        k(E.construct(name, sargs))
                    })
                }

                (E.deconstruct(name, index, expr)) {
                    T_k(expr, fn (sexpr) {
                        k(E.deconstruct(name, index, sexpr))
                    })
                }

                (E.if_expr(exprc, exprt, exprf)) {
                    let
                        rv = gensym("$rv");
                        cont = E.lambda([rv], k(rv));
                    in 
                        T_k(exprc, fn(aexp) {
                            E.if_expr(aexp, T_c(exprt, cont), T_c(exprf, cont))
                        })
                }

                (E.let_expr(var, val, body)) {
                    T_k(val, fn (sval) {
                        E.let_expr(var, sval, T_k(body, k))
                    })
                }

                (E.letrec_expr(bindings, expr)) {
                    let
                        #(vars, aexps) = lst.unzip(bindings);
                    in
                        E.letrec_expr(lst.zip(vars, lst.map(M, aexps)), T_k(expr, k))
                }

                (E.lookup(name, index, expr)) {
                    E.lookup(name, index, T_k(expr, k))
                }

                (E.make_tuple(args)) {
                    Ts_k(args, fn (sargs) {
                        k(E.make_tuple(sargs))
                    })
                }

                (E.make_vec(size, args)) {
                    Ts_k(args, fn (sargs) {
                        k(E.make_vec(size, sargs))
                    })
                }

                (E.match_cases(test, cases)) {
                    let
                        rv = gensym("$rv");
                        cont = E.lambda([rv], k(rv));
                    in
                        T_k(test, fn (atest) {
                            E.match_cases(atest, lst.map(fn {(#(indices, result)) {
                                #(indices, T_c(result, cont))
                            }}, cases))
                        })
                }

                (E.namespaces(exprs)) {
                    Ts_k(exprs, fn (sexprs) {
                        k(E.namespaces(sexprs))
                    })
                }

                (E.primapp(p, e1, e2)) {
                    T_k(e1, fn (s1) {
                        T_k(e2, fn (s2) {
                            k(E.primapp(p, s1, s2))
                        })
                    })
                }

                (E.print_exp(expr)) {
                    T_k(expr, fn (sexpr) {
                        k(E.print_exp(sexpr))
                    })
                }

                (E.sequence([expr])) { T_k(expr, k) }

                (E.sequence(expr @ exprs)) {
                    T_k(expr, fn (ignored) {
                        T_k(E.sequence(exprs), k)
                    })
                }

                (E.tag(expr)) {
                    T_k(expr, fn (sexpr) {
                        k(E.tag(sexpr))
                    })
                }

                (E.tuple_index(size, index, expr)) {
                    T_k(expr, fn (sexpr) {
                        k(E.tuple_index(size, index, sexpr))
                    })
                }

                (E.typedefs(defs, expr)) {
                    E.typedefs(defs, T_k(expr, k))
                }

                (E.typeof_expr(expr)) {
                    T_k(expr, fn (sexpr) {
                        k(E.typeof_expr(sexpr))
                    })
                }

                (x) {
                    E.print_expr(x);
                    puts("\n");
                    error("T_k: unsupported expression")
                }
            }
        }
    }

    fn T_c(expr, c) {
        if (isAexpr(expr)) {
            E.apply(c, [M(expr)])
        } else {
            switch(expr) {
                (E.amb_expr(expr1, expr2)) {
                    let
                        sk = gensym("$k");
                    in 
                        E.apply(E.lambda([sk], E.amb_expr(T_c(expr1, sk), T_c(expr2, sk))), [c])
                }

                (E.apply(f, es)) {
                    T_k(f, fn(sf) {
                        Ts_k(es, fn (ses) {E.apply(sf, ses @@ [c])})
                    })
                }

                (E.callcc_expr(e)) {
                    // Transform the function e, then apply call/cc wrapper with function and continuation
                    T_k(e, fn (sf) {
                        E.apply(
                            E.parse("(lambda (f cc) (f (lambda (x i) (cc x)) cc))"),
                            [sf, c]
                        )
                    })
                }

                (E.cond_expr(test, branches)) {
                    let
                        sk = gensym("$k");
                    in
                        E.apply(E.lambda([sk], T_k(test, fn (atest) {
                            E.cond_expr(atest, lst.map(fn {(#(val, result)) {
                                #(val, T_c(result, sk))
                            }}, branches))
                        })), [c])
                }

                (E.construct(name, args)) {
                    Ts_k(args, fn (sargs) {
                        E.apply(c, [E.construct(name, sargs)])
                    })
                }

                (E.deconstruct(name, index, expr)) {
                    T_k(expr, fn (sexpr) {
                        E.apply(c, [E.deconstruct(name, index, sexpr)])
                    })
                }

                (E.if_expr(exprc, exprt, exprf)) {
                    let
                        sk = gensym("$k");
                    in 
                        E.apply(E.lambda([sk], T_k(exprc, fn (aexp) {
                            E.if_expr(aexp, T_c(exprt,sk), T_c(exprf,sk))
                        })), [c])
                }

                (E.let_expr(var, val, body)) {
                    T_k(val, fn (sval) {
                        E.let_expr(var, sval, T_c(body, c))
                    })
                }

                (E.letrec_expr(bindings, expr)) {
                    let
                        #(vars, aexps) = lst.unzip(bindings);
                    in
                        E.letrec_expr(lst.zip(vars, lst.map(M, aexps)), T_c(expr, c))
                }

                (E.lookup(name, index, expr)) {
                    E.lookup(name, index, T_c(expr, c))
                }

                (E.make_tuple(args)) {
                    Ts_k(args, fn (sargs) {
                        E.apply(c, [E.make_tuple(sargs)])
                    })
                }

                (E.make_vec(size, args)) {
                    Ts_k(args, fn (sargs) {
                        E.apply(c, [E.make_vec(size, sargs)])
                    })
                }

                (E.match_cases(test, cases)) {
                    let
                        sk = gensym("$k");
                    in
                        E.apply(E.lambda([sk], T_k(test, fn (atest) {
                            E.match_cases(atest, lst.map(fn {(#(indices, result)) {
                                #(indices, T_c(result, sk))
                            }}, cases))
                        })), [c])
                }

                (E.namespaces(exprs)) {
                    Ts_k(exprs, fn (sexprs) {
                        E.apply(c, [E.namespaces(sexprs)])
                    })
                }

                (E.primapp(p, e1, e2)) {
                    T_k(e1, fn (s1) {
                        T_k(e2, fn (s2) {
                            E.apply(c, [E.primapp(p, s1, s2)])
                        })
                    })
                }

                (E.print_exp(expr)) {
                    T_k(expr, fn (sexpr) {
                        E.apply(c, [E.print_exp(sexpr)])
                    })
                }

                (E.sequence([expr])) { T_c(expr, c) }

                (E.sequence(expr @ exprs)) {
                    T_k(expr, fn (ignored) {
                        T_c(E.sequence(exprs), c)
                    })
                }

                (E.tag(expr)) {
                    T_k(expr, fn (sexpr) {
                        E.apply(c, [E.tag(sexpr)])
                    })
                }

                (E.tuple_index(size, index, expr)) {
                    T_k(expr, fn (sexpr) {
                        E.apply(c, [E.tuple_index(size, index, sexpr)])
                    })
                }

                (E.typedefs(defs, expr)) {
                    E.typedefs(defs, T_c(expr, c))
                }

                (E.typeof_expr(expr)) {
                    T_k(expr, fn (sexpr) {
                        E.apply(c, [E.typeof_expr(sexpr)])
                    })
                }

                (x) {
                    E.print_expr(x);
                    puts("\n");
                    error("T_c: unsupported expression")
                }
            }
        }
    }

    fn Ts_k {
        ([], k) { k([]) }
        (h @ t, k) {
            T_k(h, fn (hd) {
                Ts_k(t, fn (tl) {
                    k(hd @ tl)
                })
            })
        }
    }

in
    lst.for_each(fn (str) {
        let expr = E.parse(str);
        in
            E.print_expr(expr);
            puts(" ==>\n    ");
            E.print_expr(T_c(expr, E.var("halt")));
            puts("\n\n")
    },
    [
        // Basic application
        "(g a)",
        
        // Simple lambda application
        "((lambda (x) (h x)) (g 4))",
        
        // Lambda definition with primitives
        "(lambda (a b) (+ a (* b 2)))",
        
        // Lambda application with primitives - nested
        "((lambda (a b) (+ a (* b 2))) 3 4)",
        
        // Lambda application with function call in primitive
        "((lambda (a b) (+ a (* (f b) 2))) 3 4)",
        
        // Amb operator (non-determinism)
        "(amb 1 2)",
        
        // Simple call/cc - immediate escape
        "(call/cc (lambda (k) (k 5)))",
        
        // call/cc that doesn't escape
        "(call/cc (lambda (k) 42))",
        
        // call/cc with computation before escape
        "(call/cc (lambda (k) (+ 10 (k 5))))",
        
        // Nested call/cc
        "(call/cc (lambda (k1) (call/cc (lambda (k2) (k1 (k2 7))))))",
        
        // call/cc with amb
        "(call/cc (lambda (k) (amb (k 1) (k 2))))",
        
        // Factorial with letrec
        "(letrec ((fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))) (fact 5))",
        
        // Multiple argument function
        "((lambda (x y z) (+ x (+ y z))) 1 2 3)",
        
        // Nested lambdas (currying)
        "((lambda (x) (lambda (y) (+ x y))) 5)",
        
        // Application of curried function
        "(((lambda (x) (lambda (y) (+ x y))) 5) 3)",
        
        // If expression with complex branches
        "(if (= x 0) (f 1) (g 2))",
        
        // If with nested if
        "(if (= x 0) (if (= y 0) 1 2) 3)",
        
        // Sequence (begin in Racket)
        "(sequence (f 1) (g 2) (h 3))",
        
        // Letrec with mutual recursion
        "(letrec ((even (lambda (n) (if (= n 0) true (odd (- n 1))))) (odd (lambda (n) (if (= n 0) false (even (- n 1)))))) (even 5))",
        
        // Complex amb with computation
        "(+ (amb 1 2) (amb 3 4))",
        
        // Nested application
        "(f (g (h x)))",
        
        // Multiple primitives in sequence
        "(+ (* 2 3) (- 5 1))",
        
        // call/cc capturing continuation in letrec
        "(letrec ((k null)) (call/cc (lambda (cont) (sequence (k = cont) 42))))",
        
        // Lambda with no arguments
        "((lambda () 42))",
        
        // call/cc with primitive operations
        "(call/cc (lambda (k) (if (= 1 1) (k 10) 20)))",
        
        // Deeply nested primitives
        "(+ 1 (+ 2 (+ 3 (+ 4 5))))",
        
        // Application with multiple complex arguments
        "(f (g a) (h b) (i c))",
        
        // If where branches have applications
        "(if test (f (g x)) (h (i y)))",
        
        // Sequence with amb
        "(sequence (amb 1 2) (amb 3 4))",
        
        // call/cc that passes continuation to another function
        "(call/cc (lambda (k) (f k)))",
        
        // cond expression - like switch/case
        "(cond x (1 (result1)) (2 (result2)) (3 (result3)))",
        
        // cond with complex test and results
        "(cond (f x) (1 (g 1)) (2 (h 2)))",
        
        // construct with atomic arguments
        "(construct pair 1 2)",
        
        // construct with complex arguments
        "(construct pair (f 1) (g 2))",
        
        // nested construct
        "(construct cons (f x) (construct cons (g y) (constant nil)))",
        
        // deconstruct with atomic argument
        "(deconstruct pair 0 p)",
        
        // deconstruct with complex argument
        "(deconstruct pair 1 (f x))",
        
        // nested deconstruct
        "(deconstruct pair 0 (deconstruct pair 1 (f x)))",
        
        // let with atomic value
        "(let (x 42) (f x))",
        
        // let with complex value
        "(let (x (f 10)) (g x))",
        
        // nested let
        "(let (x (f 1)) (let (y (g x)) (h x y)))",
        
        // lookup with simple variable
        "(lookup ns 0 x)",
        
        // lookup with function call
        "(lookup ns 0 (f x))",
        
        // nested lookup
        "(f (lookup ns 0 (g x)))",
        
        // make_tuple with atomic args
        "(make_tuple 1 2 3)",
        
        // make_tuple with complex args
        "(make_tuple (f 1) (g 2))",
        
        // make_tuple with mixed args
        "(make_tuple x (f y) 42)",
        
        // make_vec with atomic args
        "(make_vec 3 1 2 3)",
        
        // make_vec with complex args
        "(make_vec 2 (f 1) (g 2))",
        
        // make_vec with mixed args
        "(make_vec 3 x (f y) 42)",
        
        // match_cases with atomic test
        "(match_cases x ((1 2) (result1)) ((3 4 5) (result2)))",
        
        // match_cases with complex test
        "(match_cases (f x) ((1) (g 1)) ((2) (h 2)))",
        
        // match_cases with complex results
        "(match_cases x ((1) (f 1)) ((2) (g 2)))",
        
        // namespaces with atomic expressions
        "(namespaces x y z)",
        
        // namespaces with complex expressions
        "(namespaces (f 1) (g 2))",
        
        // namespaces with mixed expressions
        "(namespaces x (f y) z)",
        
        // namespaces with letrec bodies returning env
        "(namespaces (letrec ((x 1) (y 2)) (env)) (letrec ((a 3) (b 4)) (env)))",
        
        // print_exp with atomic argument
        "(print x)",
        
        // print_exp with complex argument
        "(print (f x))",
        
        // print_exp nested in computation
        "(+ (print (f x)) 10)",
        
        // tag with atomic argument
        "(tag x)",
        
        // tag with complex argument
        "(tag (f x))",
        
        // tag in cond test
        "(cond (tag (f x)) (1 (result1)) (2 (result2)))",
        
        // tuple_index with atomic tuple
        "(tuple_index 3 0 t)",
        
        // tuple_index with complex tuple
        "(tuple_index 2 1 (f x))",
        
        // nested tuple_index
        "(tuple_index 2 0 (tuple_index 3 1 (f x)))",
        
        // typedefs with simple expression
        "(typedefs 0 x)",
        
        // typedefs with letrec body
        "(typedefs 0 (letrec ((f (lambda (x) (g x)))) (f 42)))",
        
        // typedefs with complex body
        "(typedefs 0 (f (g x)))",
        
        // typedefs wrapping letrec with env body
        "(typedefs 0 (letrec ((x 1) (y 2)) (env)))",
        
        // typeof_expr with atomic argument
        "(typeof x)",
        
        // typeof_expr with complex argument
        "(typeof (f x))",
        
        // typeof_expr in conditional
        "(if (typeof (f x)) (g 1) (h 2))"
    ]);