namespace
    link "../listutils.fn" as list;
    link "../ioutils.fn" as io;
    link "minexpr.fn" as M;

    import io operator "$_";
    import list operator "_|>_";
    import list operator "_&&_";

    // A-Normalization algorithm

    fn genstring() { "$" @@ $incr() }
    fn gensym() { M.var(genstring()) }

    fn normalize_term (e) { normalize(e, fn (x) { x }) }

    fn normalizeBindings {
        ([], k) { k([]) }
        (#(x, val) @ rest, k) {
            normalize(val,
                fn (anfVal) {
                    normalizeBindings(rest,
                        fn (anfRest) {
                            k(#(x, anfVal) @ anfRest)
                        }
                    )
                }
            )
        }
    }

    fn normalize_name(e, k) {
        normalize(e, fn {
            (x=M.bigint(_)) |
            (x=M.var(_)) |
            (x=M.back_expr) |
            (x=M.stdint(_)) |
            (x=M.character(_)) {
                k(x)
            }
            (x) {
                let y = genstring();
                in  M.apply(M.lambda([y], k(M.var(y))), [x])
            }
        })
    }

    fn normalize {
        (M.lambda(params, body), k) {
            k(M.lambda(params, normalize_term(body)))
        }

        (x=M.bigint(_), k) |
        (x=M.primop(_), k) |
        (x=M.var(_), k) |
        (x=M.back_expr, k) |
        (x=M.stdint(_), k) |
        (x=M.character(_), k) {
            k(x)
        }

        (M.callcc_expr(e), k) {
            normalize_name(e, fn (t) {
                k(M.callcc_expr(t))
            })
        }

        // the branches of the if must be contained
        (M.if_expr(e0, e1, e2), k) {
            normalize_name(e0, fn (test) {
                k(M.if_expr(test, normalize_term(e1), normalize_term(e2)))
            })
        }

        (M.apply(M.primop(op), Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(M.apply(M.primop(op), ts))
            })
        }

        (M.apply(Fn, Ms), k) {
            normalize_name(Fn, fn (t) {
                normalize_names(Ms, fn (ts) {
                    k(M.apply(t, ts))
                })
            })
        }

        (M.sequence(Ms), k) {
            k(M.sequence(normalize_terms(Ms)))
        }

        (M.make_vec(size, Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(M.make_vec(size, ts))
            })
        }

        (M.letrec_expr(Bs, body), k) {
            normalizeBindings(Bs, fn (bs) {
                M.letrec_expr(bs, normalize(body, k))
            })
        }

        // amb expression evaluation must be contained
        (M.amb_expr(e1, e2), k) {
            k(M.amb_expr(normalize_term(e1), normalize_term(e2)))
        }

        // branches of a cond must be individually contained
        (M.cond_expr(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(M.cond_expr(t, normalize_cases(branches)))
            })
        }

        // same for M.match_cases
        (M.match_cases(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(M.match_cases(t, normalize_cases(branches)))
            })
        }

        (other, k) {
            // catch-all for unhandled expressions
            M.print_expr(other);
            puts(": ");
            error("normalize: unhandled expression");
        }
    }

    fn normalize_terms(exprs) {
        exprs |> normalize_term
    }

    fn normalize_cases(cases) {
        cases |> identity && normalize_term
    }

    fn normalize_names {
        ([], k) {
            k([])
        }
        (H @ T, k) {
            normalize_name(H, fn (t) {
                normalize_names(T, fn (ts) {
                    k(t @ ts)
                })
            })
        }
    }