let
    link "../listutils.fn" as list;
    link "desugar.fn" as DS;
    link "samples.fn" as Samples;
    link "../ioutils.fn" as io;
    link "minexpr.fn" as M;

    import io operator "$_";

    // Normalization algorithm

    fn genstring() { "$" @@ $incr() }
    fn gensym() { M.var(genstring()) }

    fn normalize_term (e) { normalize(e, fn (x) { x }) }

    fn normalizeBindings {
        ([], k) { k([]) }
        (#(x, val) @ rest, k) {
            normalize(val,
                fn (anfVal) {
                    normalizeBindings(rest,
                        fn (anfRest) {
                            k(#(x, anfVal) @ anfRest)
                        }
                    )
                }
            )
        }
    }

    fn normalize_name(e, k) {
        normalize(e, fn {
            (x=M.bigint(_)) |
            (x=M.var(_)) |
            (x=M.back_expr) |
            (x=M.constructor_info(_)) |
            (x=M.stdint(_)) |
            (x=M.env_expr) |
            (x=M.error_expr) |
            (x=M.character(_)) {
                k(x)
            }
            (x) {
                let
                    y = genstring();
                in
                    DS.desugar(M.let_expr([#(y, x)], k(M.var(y))))
            }
        })
    }

    fn normalize {

        (M.lambda(params, body), k) {
            k(M.lambda(params, normalize_term(body)))
        }

        (x=M.bigint(_), k) |
        (x=M.var(_), k) |
        (x=M.back_expr, k) |
        (x=M.stdint(_), k) |
        (x=M.constructor_info(_), k) |
        (x=M.env_expr, k) |
        (x=M.error_expr, k) |
        (x=M.character(_), k) {
            k(x)
        }

        (M.callcc_expr(e), k) {
            normalize_name(e, fn (t) {
                k(M.callcc_expr(t))
            })
        }

        // the branches of the if must be contained
        (M.if_expr(e0, e1, e2), k) {
            normalize_name(e0, fn (test) {
                k(M.if_expr(test, normalize_term(e1), normalize_term(e2)))
            })
        }

        (M.apply(Fn, Ms), k) {
            normalize_name(Fn, fn (t) {
                normalize_names(Ms, fn (ts) {
                    k(M.apply(t, ts))
                })
            })
        }

        (M.construct(name, args), k) {
            normalize_names(args, fn (ts) {
                k(M.construct(name, ts))
            })
        }

        (M.make_tuple(Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(M.make_tuple(ts))
            })
        }

        (M.sequence(Ms), k) {
            k(M.sequence(normalize_terms(Ms)))
        }

        (M.make_vec(size, Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(M.make_vec(size, ts))
            })
        }

        (M.letrec_expr(Bs, body), k) {
            normalizeBindings(Bs, fn (bs) {
                M.letrec_expr(bs, normalize(body, k))
            })
        }

        // amb expression evaluation must be contained
        (M.amb_expr(e1, e2), k) {
            k(M.amb_expr(normalize_term(e1), normalize_term(e2)))
        }

        // branches of a cond must be individually contained
        (M.cond_expr(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(M.cond_expr(t, normalize_cases(branches)))
            })
        }

        // same for M.match_cases
        (M.match_cases(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(M.match_cases(t, normalize_cases(branches)))
            })
        }

        (M.deconstruct(name, index, e0), k) {
            normalize_name(e0, fn (t) {
                k(M.deconstruct(name, index, t))
            })
        }

        // we have to treat e0 as a Cexp because it is
        // inside the scope of a namespace
        (M.lookup(name, index, e0), k) {
            k(M.lookup(name, index, (normalize_term(e0))))
        }

        // each namespace must be individually contained
        (M.namespaces(exprs), k) {
            k(M.namespaces(normalize_terms(exprs)))
        }

        // the typedefs themselves are discarded after normalization
        (M.typedefs(ignored, expr), k) {
            k(M.typedefs(ignored, normalize_term(expr)))
        }

        (M.primapp(name, e1, e2), k) {
            normalize_name(e1, fn (t1) {
                normalize_name(e2, fn (t2) {
                    k(M.primapp(name, t1, t2))
                })
            })
        }

        (M.print_exp(e0), k) {
            normalize_name(e0, fn (t) {
                k(M.print_exp(t))
            })
        }

        (M.typeof_expr(e0), k) {
            normalize_name(e0, fn (t) {
                k(M.typeof_expr(t))
            })
        }

        (M.tuple_index(size, index, e0), k) {
            normalize_name(e0, fn (t) {
                k(M.tuple_index(size, index, t))
            })
        }

        (M.tag(e0), k) {
            normalize_name(e0, fn (t) {
                k(M.tag(t))
            })
        }

        (other, k) {
            // catch-all for unhandled expressions
            M.print_expr(other);
            puts(": ");
            error("normalize: unhandled expression");
        }
    }

    fn normalize_terms(exprs) {
        list.map (fn (e) { normalize_term(e) }, exprs)
    }

    fn normalize_cases(cases) {
        list.map (fn {
            (#(key, caseExpr)) {
                #(key, normalize_term(caseExpr))
            }
        }, cases)
    }

    fn normalize_names {
        ([], k) {
            k([])
        }
        (H @ T, k) {
            normalize_name(H, fn (t) {
                normalize_names(T, fn (ts) {
                    k(t @ ts)
                })
            })
        }
    }
in
    list.for_each (fn (str) {
        let expr = M.parse(str);
        in
        M.print_expr(expr);
        puts(" ==>\n    ");
        M.print_expr(normalize_term(DS.desugar(expr)));
        puts("\n")
    },
    Samples.data);