let
    link "../listutils.fn" as list;
    link "../ioutils.fn" as io;
    link "expr.fn" as E;

    import io operator "$_";

    // Normalization algorithm

    fn gensym() { E.var("$" @@ $incr()) }

    fn normalize_term (e) { normalize(e, fn (x) { x }) }

    fn normalizeBindings {
        ([], k) { k([]) }
        (#(x, val) @ rest, k) {
            normalize(val,
                fn (anfVal) {
                    normalizeBindings(rest,
                        fn (anfRest) {
                            k(#(x, anfVal) @ anfRest)
                        }
                    )
                }
            )
        }
    }

    fn normalize_name(e, k) {
        normalize(e, fn {
            (x=E.bigint(_)) |
            (x=E.var(_)) |
            (x=E.back_expr) |
            (x=E.constant(_)) |
            (x=E.constructor_info(_)) |
            (x=E.stdint(_)) |
            (x=E.env_expr) |
            (x=E.error_expr) |
            (x=E.character(_)) {
                k(x)
            }
            (x) {
                let
                    y = gensym();
                in
                    E.let_expr(y, x, k(y))
            }
        })
    }

    fn normalize {

        (E.lambda(params, body), k) {
            k(E.lambda(params, normalize_term(body)))
        }

        (x=E.bigint(_), k) |
        (x=E.var(_), k) |
        (x=E.back_expr, k) |
        (x=E.constant(_), k) |
        (x=E.stdint(_), k) |
        (x=E.constructor_info(_), k) |
        (x=E.env_expr, k) |
        (x=E.error_expr, k) |
        (x=E.character(_), k) {
            k(x)
        }

        (E.callcc_expr(e), k) {
            normalize_name(e, fn (t) {
                k(E.callcc_expr(t))
            })
        }

        (E.let_expr(x, val, body), k) {
            normalize(val, fn (v) { E.let_expr(x, v, normalize(body, k)) })
        }

        // the branches of the if must be contained
        (E.if_expr(e0, e1, e2), k) {
            normalize_name(e0, fn (test) {
                k(E.if_expr(test, normalize_term(e1), normalize_term(e2)))
            })
        }

        (E.apply(Fn, Ms), k) {
            normalize_name(Fn, fn (t) {
                normalize_names(Ms, fn (ts) {
                    k(E.apply(t, ts))
                })
            })
        }

        (E.construct(name, args), k) {
            normalize_names(args, fn (ts) {
                k(E.construct(name, ts))
            })
        }

        (E.make_tuple(Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(E.make_tuple(ts))
            })
        }

        (E.sequence(Ms), k) {
            k(E.sequence(normalize_terms(Ms)))
        }

        (E.make_vec(size, Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(E.make_vec(size, ts))
            })
        }

        (E.letrec_expr(Bs, body), k) {
            normalizeBindings(Bs, fn (bs) {
                E.letrec_expr(bs, normalize(body, k))
            })
        }

        // amb expression evaluation must be contained
        (E.amb_expr(e1, e2), k) {
            k(E.amb_expr(normalize_term(e1), normalize_term(e2)))
        }

        // branches of a cond must be individually contained
        (E.cond_expr(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(E.cond_expr(t, normalize_cases(branches)))
            })
        }

        // same for E.match_cases
        (E.match_cases(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(E.match_cases(t, normalize_cases(branches)))
            })
        }

        (E.deconstruct(name, index, e0), k) {
            normalize_name(e0, fn (t) {
                k(E.deconstruct(name, index, t))
            })
        }

        // we have to treat e0 as a Cexp because it is
        // inside the scope of a namespace
        (E.lookup(name, index, e0), k) {
            k(E.lookup(name, index, (normalize_term(e0))))
        }

        // each namespace must be individually contained
        (E.namespaces(exprs), k) {
            k(E.namespaces(normalize_terms(exprs)))
        }

        // the typedefs themselves are discarded after normalization
        (E.typedefs(ignored, expr), k) {
            k(E.typedefs(ignored, normalize_term(expr)))
        }

        (E.primapp(name, e1, e2), k) {
            normalize_name(e1, fn (t1) {
                normalize_name(e2, fn (t2) {
                    k(E.primapp(name, t1, t2))
                })
            })
        }

        (E.print_exp(e0), k) {
            normalize_name(e0, fn (t) {
                k(E.print_exp(t))
            })
        }

        (E.typeof_expr(e0), k) {
            normalize_name(e0, fn (t) {
                k(E.typeof_expr(t))
            })
        }

        (E.tuple_index(size, index, e0), k) {
            normalize_name(e0, fn (t) {
                k(E.tuple_index(size, index, t))
            })
        }

        (E.tag(e0), k) {
            normalize_name(e0, fn (t) {
                k(E.tag(t))
            })
        }
    }

    fn normalize_terms(exprs) {
        list.map (fn (e) { normalize_term(e) }, exprs)
    }

    fn normalize_cases(cases) {
        list.map (fn {
            (#(key, caseExpr)) {
                #(key, normalize_term(caseExpr))
            }
        }, cases)
    }

    fn normalize_names {
        ([], k) {
            k([])
        }
        (H @ T, k) {
            normalize_name(H, fn (t) {
                normalize_names(T, fn (ts) {
                    k(t @ ts)
                })
            })
        }
    }
in
    {
        let
            // test data
            lamexp = E.parse("(lambda (x y) (f x (f y)))");
        
            letexp = E.parse("(let (a (compute (value 10))) (use (f a)))");
        
            // (let (a (compute (value 10))) (let (b (compute (value a))) (use (f b))))
            letexp2 = E.parse("(let (a (compute (value 10))) "
                                    "(let (b (compute (value a))) "
                                        "(use (f b))))");
        
            ifexp = E.parse("(if (is_zero 0) (lambda (x) (f x)) (let (y 42) (f y)))");
        
            primexp = E.parse("(+ 5 (* 10 2))");
        
        in
            list.for_each (fn (expr) {
                E.print_expr(expr);
                puts(" ==>\n    ");
                E.print_expr(normalize_term(expr));
                puts("\n")
            },
            [
                lamexp,
                E.parse("(call/cc k)"),
                E.parse("(call/cc (f 10))"),
                E.parse("42"),
                E.parse("z"),
                letexp,
                letexp2,
                ifexp,

                E.apply(
                    E.var("f"),
                    [primexp, primexp, primexp]
                ),

                E.parse("((lambda (x) (h x 3)) (g 4))"),
                E.parse("((lambda (x) (h x (y 3))) (g 4))"),
                E.parse("(letrec ((f (g 42 (h 7)))) f)"),
                E.parse("(amb (choose (value 1)) (choose (value 2)))"),
                E.parse("back"),
                E.parse("'a'"),
                E.parse("(cond (test_cond 5) ((1) (result1 10)) ((2) (result2 (f 20))))"),
                E.parse("(match_cases (test_case 5) ((1) (result1 10)) ((2 3) (result2 (f 20))) )"),
                E.parse("(constant nil)"),

                E.parse("(construct pair 1 (construct pair 2 (constant nil)))"),
                E.construct("pair", [E.bigint(1), E.construct("pair", [E.bigint(2), E.constant("nil")])]),

                E.constructor_info("MyConstructor"),

                E.deconstruct("pair", 0, E.construct("pair", [E.bigint(1), E.constant("nil")])),

                E.env_expr,

                E.error_expr,

                E.lookup("ns", 0, E.apply(E.var("f"), [E.apply(E.var("g"), [E.bigint(10)])])),

                E.make_tuple([E.bigint(1), E.var("x"), E.apply(E.var("h"), [E.bigint(3)])]),

                E.make_vec(3, [E.bigint(1), E.var("x"), E.apply(E.var("h"), [E.bigint(3)])]),

                E.namespaces([
                    E.let_expr(
                        E.var("a"),
                        E.bigint(10),
                        E.apply(E.var("use_a"), [E.var("a")])
                    ),
                    E.if_expr(
                        E.apply(E.var("check"), [E.var("a")]),
                        E.apply(E.var("true_branch"), []),
                        E.apply(E.var("false_branch"), [])
                    )
                ]),

                E.primapp("+", E.bigint(5),
                            E.primapp("*", E.bigint(10),
                                        E.apply(E.var("f"), [E.bigint(2)]))),

                E.primapp("+", E.bigint(5),
                            E.primapp("*", E.bigint(10),
                                        E.apply(E.var("f"), [E.apply(E.var("g"), [E.bigint(2)])]))),

                E.print_exp(E.apply(E.var("display"), [E.bigint(7)])),

                E.sequence([E.bigint(1), E.var("x"), E.apply(E.var("f"), [E.apply(E.var("h"), [E.bigint(3)])])]),

                E.stdint(10),

                E.tag(E.apply(E.var("sometype"), [E.bigint(7)])),

                E.tuple_index(1, 0, E.apply(E.var("sometuple"), [E.bigint(7)])),

                E.typedefs(0,
                    E.letrec_expr(
                        [#("f", E.apply(E.var("g"), [E.bigint(42), E.apply(E.var("h"), [E.bigint(7)])]))],
                        E.env_expr
                    )
                ),

                E.typeof_expr(E.apply(E.var("somevalue"), [E.bigint(99)])),

                // (if (let (x (f 1))
                //          (g x)) 10 20) ==>
                // (let (x (f 1))
                //      (let ($1 (g x))
                //           (if $1 10 20)))
                E.if_expr(
                    E.let_expr(
                        E.var("x"),
                        E.apply(E.var("f"), [E.bigint(1)]),
                        E.apply(E.var("g"), [E.var("x")])
                    ),
                    E.bigint(10),
                    E.bigint(20)
                )
            ]);
}