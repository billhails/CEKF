let
    link "../listutils.fn" as list;
    link "../ioutils.fn" as io;
    link "expr.fn" as E;

    import io operator "$_";

    // Normalization algorithm

    fn gensym() { E.var("$" @@ $incr()) }

    fn normalize_term (e) { normalize(e, fn (x) { x }) }

    fn normalizeBindings {
        ([], k) { k([]) }
        (#(x, val) @ rest, k) {
            normalize(val,
                fn (anfVal) {
                    normalizeBindings(rest,
                        fn (anfRest) {
                            k(#(x, anfVal) @ anfRest)
                        }
                    )
                }
            )
        }
    }

    fn normalize_name(e, k) {
        normalize(e, fn {
            (x=E.bigint(_)) |
            (x=E.var(_)) |
            (x=E.back_expr) |
            (x=E.constant(_)) |
            (x=E.constructor_info(_)) |
            (x=E.stdint(_)) |
            (x=E.env_expr) |
            (x=E.error_expr) |
            (x=E.character(_)) {
                k(x)
            }
            (x) {
                let
                    y = gensym();
                in
                    E.let_expr(y, x, k(y))
            }
        })
    }

    fn normalize {

        (E.lambda(params, body), k) {
            k(E.lambda(params, normalize_term(body)))
        }

        (x=E.bigint(_), k) |
        (x=E.var(_), k) |
        (x=E.back_expr, k) |
        (x=E.constant(_), k) |
        (x=E.stdint(_), k) |
        (x=E.constructor_info(_), k) |
        (x=E.env_expr, k) |
        (x=E.error_expr, k) |
        (x=E.character(_), k) {
            k(x)
        }

        (E.callcc_expr(e), k) {
            normalize_name(e, fn (t) {
                k(E.callcc_expr(t))
            })
        }

        (E.let_expr(x, val, body), k) {
            normalize(val, fn (v) { E.let_expr(x, v, normalize(body, k)) })
        }

        // the branches of the if must be contained
        (E.if_expr(e0, e1, e2), k) {
            normalize_name(e0, fn (test) {
                k(E.if_expr(test, normalize_term(e1), normalize_term(e2)))
            })
        }

        (E.apply(Fn, Ms), k) {
            normalize_name(Fn, fn (t) {
                normalize_names(Ms, fn (ts) {
                    k(E.apply(t, ts))
                })
            })
        }

        (E.construct(name, args), k) {
            normalize_names(args, fn (ts) {
                k(E.construct(name, ts))
            })
        }

        (E.make_tuple(Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(E.make_tuple(ts))
            })
        }

        (E.sequence(Ms), k) {
            k(E.sequence(normalize_terms(Ms)))
        }

        (E.make_vec(size, Ms), k) {
            normalize_names(Ms, fn (ts) {
                k(E.make_vec(size, ts))
            })
        }

        (E.letrec_expr(Bs, body), k) {
            normalizeBindings(Bs, fn (bs) {
                E.letrec_expr(bs, normalize(body, k))
            })
        }

        // amb expression evaluation must be contained
        (E.amb_expr(e1, e2), k) {
            k(E.amb_expr(normalize_term(e1), normalize_term(e2)))
        }

        // branches of a cond must be individually contained
        (E.cond_expr(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(E.cond_expr(t, normalize_cases(branches)))
            })
        }

        // same for E.match_cases
        (E.match_cases(e0, branches), k) {
            normalize_name(e0, fn (t) {
                k(E.match_cases(t, normalize_cases(branches)))
            })
        }

        (E.deconstruct(name, index, e0), k) {
            normalize_name(e0, fn (t) {
                k(E.deconstruct(name, index, t))
            })
        }

        // we have to treat e0 as a Cexp because it is
        // inside the scope of a namespace
        (E.lookup(name, index, e0), k) {
            k(E.lookup(name, index, (normalize_term(e0))))
        }

        // each namespace must be individually contained
        (E.namespaces(exprs), k) {
            k(E.namespaces(normalize_terms(exprs)))
        }

        // the typedefs themselves are discarded after normalization
        (E.typedefs(ignored, expr), k) {
            k(E.typedefs(ignored, normalize_term(expr)))
        }

        (E.primapp(name, e1, e2), k) {
            normalize_name(e1, fn (t1) {
                normalize_name(e2, fn (t2) {
                    k(E.primapp(name, t1, t2))
                })
            })
        }

        (E.print_exp(e0), k) {
            normalize_name(e0, fn (t) {
                k(E.print_exp(t))
            })
        }

        (E.typeof_expr(e0), k) {
            normalize_name(e0, fn (t) {
                k(E.typeof_expr(t))
            })
        }

        (E.tuple_index(size, index, e0), k) {
            normalize_name(e0, fn (t) {
                k(E.tuple_index(size, index, t))
            })
        }

        (E.tag(e0), k) {
            normalize_name(e0, fn (t) {
                k(E.tag(t))
            })
        }
    }

    fn normalize_terms(exprs) {
        list.map (fn (e) { normalize_term(e) }, exprs)
    }

    fn normalize_cases(cases) {
        list.map (fn {
            (#(key, caseExpr)) {
                #(key, normalize_term(caseExpr))
            }
        }, cases)
    }

    fn normalize_names {
        ([], k) {
            k([])
        }
        (H @ T, k) {
            normalize_name(H, fn (t) {
                normalize_names(T, fn (ts) {
                    k(t @ ts)
                })
            })
        }
    }
in
    list.for_each (fn (str) {
        let expr = E.parse(str);
        in
        E.print_expr(expr);
        puts(" ==>\n    ");
        E.print_expr(normalize_term(expr));
        puts("\n")
    },
    [
        "(lambda (x y) (f x (f y)))",
        "(call/cc k)",
        "(call/cc (f 10))",
        "42",
        "z",
        "(let (a (compute (value 10))) (use (f a)))",
        "(let (a (compute (value 10))) (let (b (compute (value a))) (use (f b))))",
        "(if (is_zero 0) (lambda (x) (f x)) (let (y 42) (f y)))",
        "(f (+ 5 (* 10 2)) (+ 5 (* 10 2)) (+ 5 (* 10 2)))",
        "((lambda (x) (h x 3)) (g 4))",
        "((lambda (x) (h x (y 3))) (g 4))",
        "(letrec ((f (g 42 (h 7)))) f)",
        "(amb (choose (value 1)) (choose (value 2)))",
        "back",
        "'a'",
        "(cond (test_cond 5) ((1) (result1 10)) ((2) (result2 (f 20))))",
        "(match_cases (test_case 5) ((1) (result1 10)) ((2 3) (result2 (f 20))) )",
        "(constant nil)",
        "(construct pair 1 (construct pair 2 (constant nil)))",
        "(constructor_info MyConstructor)",
        "(deconstruct pair 0 (construct pair 1 (constant nil)))",
        "(env)",
        "(error)",
        "(lookup ns 0 (f (g 10)))",
        "(make_tuple 1 x (h 3))",
        "(make_vec 3 1 x (h 3))",
        "(namespaces (let (a 10) (use_a a)) (if (check a) (true_branch) (false_branch())))",
        "(+ 5 (* 10 (f 2)))",
        "(+ 5 (* 10 (f (g 2))))",
        "(print (display 7))",
        "(sequence 1 x (f (h 3)))",
        "10",
        "(tag (sometype 7))",
        "(tuple_index 1 0 (sometuple 7))",
        "(typedefs 0 (letrec ((f (g 42 (h 7)))) f))",
        "(type_of (somevalue 99))",
        "(if (let (x (f 1)) (g x)) 10 20)",
    ]);