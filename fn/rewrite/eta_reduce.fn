namespace

// Î·-reduction

link "minexpr.fn" as M;
link "env.fn" as Env;
link "subst.fn" as SUBST;
link "occurs_in.fn" as O;
link "../listutils.fn" as list;
link "../dictutils.fn" as DICT;
import list operator "_|>_";
import list operator "_&&_";
import list operator "_any_";

fn subst (expr, var, arg) {
    SUBST.substitute(DICT.make([var], [arg]), expr)
}

fn makeVar (s) {
    M.var(s)
}

fn reduce {
    (M.amb_expr(expr1, expr2)) {
        M.amb_expr(reduce(expr1), reduce(expr2))
    }

    (M.apply(fun, args)) {
        M.apply(reduce(fun), args |> reduce)
    }

    (x = M.back_expr) |
    (x = M.primop(_)) |
    (x = M.env_expr) |
    (x = M.error_expr) |
    (x = M.bigint(_)) |
    (x = M.character(_)) |
    (x = M.var(_)) |
    (x = M.stdint(_)) {
        x
    }

    (M.callcc_expr(e)) {
        M.callcc_expr(reduce(e))
    }

    (M.cond_expr(test, branches)) {
        M.cond_expr(reduce(test), branches |> reduce && reduce)
    }

    (M.if_expr(exprc, exprt, exprf)) {
        M.if_expr(reduce(exprc),
                reduce(exprt),
                reduce(exprf))
    }

    (M.lambda(params, body)) {
        switch (body) {
            (M.apply(f, args)) {
                let pvars = params |> makeVar;
                in
                    if (pvars == args and not pvars any (O.occurs_in flip f)) {
                        f
                    } else {
                        M.lambda(params, reduce(body))
                    }
            }
            (_) {
                M.lambda(params, reduce(body))
            }
        }
    }

    (M.letrec_expr(bindings, expr)) {
        M.letrec_expr(bindings |> identity && (reduce && identity), reduce(expr))
    }

    (M.lookup(name, index, expr)) {
        M.lookup(name, index, reduce(expr))
    }

    (M.make_vec(size, args)) {
        M.make_vec(size, args |> reduce)
    }

    (M.match_cases(test, cases)) {
        M.match_cases(reduce(test), cases |> identity && reduce)
    }

    (M.namespaces(exprs)) {
        M.namespaces(exprs |> reduce)
    }

    (M.sequence(exprs)) {
        M.sequence(exprs |> reduce)
    }

    (x) {
        M.print_expr(x);
        puts("\n");
        error("reduce: unsupported expression")
    }
}