namespace

link "listutils.fn" as list;

// see https://matt.might.net/papers/germane2014deletion.pdf

typedef Color { R | B | BB }
typedef Dict(#t, #u) { E | EE | D(Color, Dict(#t, #u), #(#t, #u), Dict(#t, #u)) }

print Dict(pt, pu, d) {
    let
        fn pd {
            (E) | (EE) { [] }
            (D(_, l, #(t, u), r)) {
                pd(l);
                puts("  ");
                pt(t);
                puts(": ");
                pu(u);
                puts("\n");
                pd(r);
                []
            }
            (D(_, _, _, _)) {
                []
            }
        }
    in
        puts("{\n");
        pd(d);
        puts("}");
        d;
}

fn is_empty(d) {
    switch (d) {
        (E) | (EE) { true }
        (_)        { false }
    }
}

fn empty() {
    E
}

fn foreach {
    (_, E) | (_, EE) { nothing }
    (f, D(_, l, #(t, u), r)) {
        foreach(f, l);
        f(t, u);
        foreach(f, r);
        nothing;
    }
}

fn map {
    (_, E) | (_, EE) { E }
    (f, D(color, l, #(k, v), r)) {
        D(color, map(f, l), #(k, f(v)), map(f, r))
    }
}

export operator "_|>_" left 8 fn (d, f) { map(f, d) };

fn keys (d) {
    let fn h {
        (E, lst) | (EE, lst) { lst }
        (D(_, l, #(k, _), r), lst) {
            h(l, k @ h(r, lst))
        }
    }
    in h(d, [])
}

fn values (d) {
    let fn h {
        (E, lst) | (EE, lst) { lst }
        (D(_, l, #(_, v), r), lst) {
            h(l, v @ h(r, lst))
        }
    }
    in h(d, [])
}

fn size {
    (E) | (EE) { 0 }
    (D(_, l, #(_, _), r)) {
        1 + size(l) + size(r)
    }
}

fn balance {
    (B, D(R, D(R, a, x, b), y, c), z, d)  |
    (B, D(R, a, x, D(R, b, y, c)), z, d)  |
    (B, a, x, D(R, D(R, b, y, c), z, d))  |
    (B, a, x, D(R, b, y, D(R, c, z, d)))  { D(R, D(B, a, x, b), y, D(B, c, z, d)) }
    (BB, D(R, a, x, D(R, b, y, c)), z, d) |
    (BB, D(R, a, x, D(R, b, y, c)), z, d) { D(B, D(B, a, x, b), y, D(B, c, z, d)) }
    (color, a, b, c)                      { D(color, a, b, c) }
}

// #t -> Dict(#t, #u) -> Maybe(#u)
fn lookup {
    (_, E) | (_, EE) { nothing }
    (k, D(_, _, #(k, y), _)) { just(y) }
    (k, D(_, a, #(y, _), b)) {
        if (k < y) {
            lookup(k, a)
        } else {
            lookup(k, b)
        }
    }
}

fn insert(k, v, s) {
    let
        fn blacken {
            (D(R, t=D(R, _, _, _), y, c)) { D(B, t, y, c) }
            (D(R, a, k, t=D(R, _, _, _))) { D(B, a, k, t) }
            (t) { t }
        }
        fn ins {
            (k, EE) | (k, E) { D(R, E, #(k, v), E) }
            (k, D(c, a, #(k, _), b)) { D(c, a, #(k, v), b) }
            (k, D(color, a, s=#(y, _), b)) {
                if (k < y) {
                    balance(color, ins(k, a), s, b)
                } else {
                    balance(color, a, s, ins(k, b))
                }
            }
        }
    in
        blacken(ins(k, s))
}

fn delete(k, s) {
    let
        fn del {
            (_, EE, throw) | (_, E, throw) { throw(s) }
            (k, D(R, E, #(k, _), E), _) { E }
            (k, D(B, E, #(k, _), E), _) { EE }
            (_, D(B, E, _, E), throw) { throw(s) }
            (k, D(B, D(R, E, y, E), #(k, _), E), _) { D(B, E, y, E) }
            (k, D(B, D(R, E, y, E), #(z, zv), E), throw) {
                if (k < z) {
                    D(B, del(k, D(R, E, y, E), throw), #(z, zv), E)
                } else {
                    throw(s)
                }
            }
            (k, D(c, a, #(k, _), b), _) {
                rotate(c, a, leftmost_successor(b), del_leftmost_successor(b))
            }
            (k, D(c, a, s=#(y, _), b), throw) {
                if (k < y) {
                    rotate(c, del(k, a, throw), s, b)
                } else {
                    rotate(c, a, s, del(k, b, throw))
                }
            }
        }

        fn redden {
            (D(B, a=D(B, _, _, _), y, b=D(B, _, _, _))) { D(R, a, y, b) }
            (a) { a }
        }

        fn rotate {
            (R, D(BB, a, x, b), y, D(B, c, z, d)) { balance(B, D(R, D(B, a, x, b), y, c), z, d) }
            (R, EE, y, D(B, c, z, d)) { balance(B, D(R, E, y, c), z, d) }
            (R, D(B, a, x, b), y, D(BB, c, z, d)) { balance(B, a, x, D(R, b, y, D(B, c, z, d))) }
            (R, D(B, a, x, b), y, EE) { balance(B, a, x, D(R, b, y, E)) }
            (B, D(BB, a, x, b), y, D(B, c, z, d)) { balance(BB, D(R, D(B, a, x, b), y, c), z, d) }
            (B, EE, y, D(B, c, z, d)) { balance(BB, D(R, E, y, c), z, d) }
            (B, D(B, a, x, b), y, D(BB, c, z, d)) { balance(BB, a, x, D(R, b, y, D(B, c, z, d))) }
            (B, D(B, a, x, b), y, EE) { balance(BB, a, x, D(R, b, y, E)) }
            (B, D(BB, a, w, b), x, D(R, D(B, c, y, d), z, e)) { D(B, balance(B, D(R, D(B, a, w, b), x, c), y, d), z, e) }
            (B, EE, x, D(R, D(B, c, y, d), z, e)) { D(B, balance(B, D(R, E, x, c), y, d), z, e) }
            (B, D(R, a, w, D(B, b, x, c)), y, D(BB, d, z, e)) { D(B, a, w, balance(B, b, x, D(R, c, y, D(B, d, z, e)))) }
            (B, D(R, a, w, D(B, b, x, c)), y, EE) { D(B, a, w, balance(B, b, x, D(R, c, y, E))) }
            (color, a, x, b) { D(color, a, x, b) }
        }

        unsafe fn leftmost_successor {
            (D(_, E, x, E))             |
            (D(B, E, x, D(R, E, _, E))) { x }
            (D(_, a, _, _))             { leftmost_successor(a) }
        }

        unsafe fn del_leftmost_successor {
            (D(R, E, _, E))             { E }
            (D(B, E, _, E))             { EE }
            (D(B, E, _, D(R, E, y, E))) { D(B, E, y, E) }
            (D(c, a, x, b))             { rotate(c, del_leftmost_successor(a), x, b) }
        }
    in
        here fn (throw) { del(k, redden(s), throw) }
}

fn make (keys, values) {
    add_lists(keys, values, E)
}

fn add_lists (keys, values, dict) {
    list.foldl(fn (#(k, v), d) { insert(k, v, d) }, dict, list.zip(keys, values))
}

fn delete_list (keys, dict) {
    list.foldl(fn (k, d) { delete(k, d) }, dict, keys)
}