let
///////////////////////////////////////////////////////////////////////////
// PRELIMINARIES
///////////////////////////////////////////////////////////////////////////
    link "ioutils.fn" as io;
    link "dictionary.fn" as dict;
    link "listutils.fn" as lst;

    infix left 80 "=>" fn (arg, fun) { fun(arg) };
    infix left 80 "?" fn (l, n) { lst.nth(n, l) };
    infix left 80 "??" fn (l, n) { lst.nths(n, l) };
    infix left 80 "|>" fn (l, f) { lst.map(f, l) };
    infix left 80 ".." lst.range;
    prefix 85 "$" io.to_string;

    typedef pattern {
        wildcard |
        variable(string) |
        const(number) |
        ctor(string, list(pattern)) |
        tuple(list(pattern)) |
        tagged(string, pattern)
    }

    print pattern(p) {
        let
            fn i {
                ([]) { "" }
                (p @ []) { h(p) }
                (p @ t) { h(p); puts(", "); i(t) }
            }
            fn h {
                (wildcard) { puts("_") }
                (variable(name)) { puts('$' @ name) }
                (const(n)) { puts($n) }
                (ctor(tag, pats)) {
                    puts(tag);
                    if (lst.length(pats) > 0) {
                        puts("("); i(pats); puts(")")
                    } else { "" }
                }
                (tuple(pats)) {
                    puts("#("); i(pats); puts(")")
                }
                (tagged(tag, p)) { puts(tag); putc('='); h(p) }
            }
        in h(p); p
    }

    typedef code {
        expression(string) |
        case(string, list(code)) |
        rule(pattern, code) |
        letrec(list(#(string, code)), code) |
        lambda(list(string), code) |
        apply(string, list(string))
    }

    alias substs = dict.Dict(string, string);
    alias refcounts = dict.Dict(string, number);

    typedef Arc { arc(pattern, list(string), tpmc) }

    typedef tpmc { 
        final(string, list(string), number, substs) |
        test(string, string, list(string), number, list(Arc))
    }

    // typedef Check { check(pattern -> list(string)) }

    print tpmc(state) {
        let fn h {
            (final(stamp, free, refcount, substs)) {
                puts("FINAL stamp:");
                puts(stamp);
                puts(" refcount:");
                putn(refcount);
                puts(" free:");
                print(free);
                puts(" substs:");
                print(substs);
                ""
            }
            (test(stamp, var, free, refcount, arcs)) {
                let fn a {
                    (arc(pat, free, s) @ t) {
                        puts("ARC pat::");
                        print(pat);
                        puts(" free:");
                        print(free);
                        puts(" => state:");
                        h(s);
                        puts(";\n");
                        a(t)
                    }
                    ([]) { "" }
                } in
                    puts("TEST stamp:");
                    puts(stamp);
                    puts(" var:");
                    puts(var);
                    puts(" free:");
                    print(free);
                    puts(" refcount:");
                    putn(refcount);
                    puts(" arcs:[\n");
                    a(arcs);
                    puts("]\n");
            }
        }
        in h(state);
        state;
    }

    // makeTag: string -> number -> string
    fn makeTag (base, n) { base @@ "$" @@ $n }

    // makeLabel: tpmc -> string
    fn makeLabel {
        (final(stamp, _, _, _)) { stamp }
        (test(_, var, _, _, arcs)) {
            let fn arcLabel (arc(pat, _, s)) {
                    $pat @@ "=>" @@ makeLabel(s)
                }
            in
                var @@
                    "[" @@
                    lst.join(",", arcs |> arcLabel) @@
                    "]";
        }
    }

///////////////////////////////////////////////////////////////////////////
// STAGE 1 RENAMING
///////////////////////////////////////////////////////////////////////////

    // rename: list(#(list(pattern), string)) ->
    //                  #(list(list(pattern)), list(tpmc))
    fn rename(rows) {
        let
            // renameRow: #(list(pattern), string) ->
            //                     #(list(pattern), tpmc)
            fn renameRow (#(row, target)) {
                mapTag("x", 0, dict.E, row) => fn(#(pats, substs)) {
                    #(pats, final(target, [], 1, substs))
                }
            }
        in
            rows |> renameRow => lst.unzip
    }

    // mapTag: string -> number -> substs ->
    //                  list(pattern) -> #(list(pattern), substs)
    fn mapTag {
        (_, _, d, []) { #([], d) }
        (base, n, d, pat @ pats) {
            let
                // tag: string -> pattern -> substs -> #(pattern, substs)
                fn tag {
                    (base, wildcard, d) { #(tagged(base, wildcard), d) }
                    (base, variable(name), d) {
                        #(tagged(base, wildcard),
                          dict.insert(name, base, d))
                    }
                    (base, c = const(_), d) { #(tagged(base, c), d) }
                    (base, ctor(name, pats), d) {
                        mapTag(base, 0, d, pats) => fn (#(pats, d)) {
                            #(tagged(base, ctor(name, pats)), d)
                        }
                    }
                    (base, tuple(pats), d) {
                        mapTag(base, 0, d, pats) => fn (#(pats, d)) {
                            #(tagged(base, tuple(pats)), d)
                        }
                    }
                    (_, tagged(t, _), _) { error("already tagged: " @@ t) }
                }
            in
                tag(makeTag(base, n), pat, d) => fn (#(pat, d)) {
                    mapTag(base, n + 1, d, pats) => fn (#(pats, d)) {
                        #(pat @ pats, d)
                    }
                }
        }
    }

///////////////////////////////////////////////////////////////////////////
// STAGE 2 Generate the DFA
///////////////////////////////////////////////////////////////////////////

    // match: #(list(list(pattern)), list(tpmc)) -> tpmc
    fn match (#(M, S)) {
        if (lst.all(simple, M?0)) {
            variableRule(S)
        } else {
            patternRule(M, S)
        }
    }

    // variableRule: list(tpmc) -> tpmc
    fn variableRule(S) { S?0 }

    // patternRule: list(list(pattern)) -> list(tpmc) -> tpmc
    fn patternRule (M, S) {
    let
        // find the first index of a column in M that has a
        // constructor in its top position
        index = lst.indices(fn (x) { not simple(x) }, M ? 0) ? 0;
        // let N be that column in M
        N = M |> lst.nth(index);
        // let M-N be a matrix of all the columns in M except N
        M_N = M |> lst.except_nth(index);
        // for each constructor c in N
        arcs = lst.filter_not(simple, N) |> fn (c) {
        let
            // let {i_1 .. i_j} be the row-indices of the patterns
            // in N that match c
            i1_ij = rowsThatMatch(c, N);
            // let {pat_1 .. pat_j} be the patterns in the column
            // corresponding to those indices 
            pat1_patj = N ?? i1_ij;
            // let n be the arity of the constructor c
            n = arity(c);
            // For each pat_i, its n sub-patterns are extracted;
            // if pat_i is a wildcard, n wildcards are produced
            // instead, each tagged with the right path variable.
            // This results in a pattern matrix A with n columns
            // and j rows.
            A = pat1_patj |> unsafe fn {
                (tagged(_, ctor(_, pats))) |
                (tagged(_, tuple(pats))) { pats }
                (tagged(tag, _)) {
                    makeTags(tag, n)
                }
            };
            // This matrix A is then appended to the result of
            // selecting, from each column in the rest of the
            // original matrix, those rows whose indices are in
            // {i_1 .. i_j}.
            B = M_N ?? i1_ij;
            C = lst.zipWith(append, B, A);
            // Finally the indices are used to select the
            // corresponding final states X that go with these
            // rows.
            X = S ?? i1_ij;
        in
            // The arc for the constructor c is now defined as
            // (c’,state), where c’ is c with any immediate
            // sub-patterns replaced by their path variables
            // (thus c’ is a simple pattern), and state is the
            // result of recursively applying match to the new
            // matrix and the new sequence of final states.
            arc(simplify(c, n), [], match(#(C, X)))
        };
        // deduplicate
        uarcs = lst.unique(arcs);
    in 
        // Finally, the possibility for matching failure is considered.
        if (arcsAreExhaustive(uarcs)) {
            // If the set of constructors is exhaustive, then no more
            // arcs are computed.
            let var = varName(N?0);
            in test("L_" @@ var, var, [], 1, uarcs)
        } else {
            // Otherwise, a default arc (_,state) is the last arc.
            let var = varName(N?0);
            in test("LD_" @@ var, var, [], 1, uarcs @@ [makeDefaultArc(N, M_N, S)])
        }
    }

    // varName: pattern -> string
    fn varName {
        (tagged(x, _)) { x }
        (err) { error("varName:" @@ $err) }
    }

    // makeErrorArc: list(pattern) => Arc
    fn makeErrorArc {
        (tagged(x, _) @ _) {
            arc(tagged(x, wildcard), [], final("error", [], 1, dict.E))
        }
        (_) { error("makeErrorArc") }
    }

    // makeDefaultArc: list(pattern) -> list(list(pattern)) ->
    //                                        list(tpmc) -> Arc
    fn makeDefaultArc (N, M_N, S) {
        // If there are any wildcard patterns in the selected
        // column, then their rows are selected from the rest
        // of the matrix and the final states, and the state
        // is the result of applying match to the new matrix
        // and states. Otherwise, the error state is used
        // after its reference count has been incremented.
        switch (lst.indices(patternIsWildcard, N)) {
            ([]) { makeErrorArc(N) }
            (wildcards) {
                let M_Ns = M_N ?? wildcards;
                    Ss = S ?? wildcards;
                in
                    arc(tagged(varName(N?0), wildcard),
                        [], match(#(M_Ns, Ss)))
            }
        }
    }

    // patternIsWildcard: pattern -> bool
    fn patternIsWildcard {
        (tagged(_, wildcard)) { true }
        (_) { false }
    }

    // arcsAreExhaustive: list(Arc) -> bool
    fn arcsAreExhaustive {
        ([]) { false }
        (arcs = arc(tagged(_, ctor(c, _)), _, _) @ _) {
            ctorsAreExhaustive(arcs)
        }
        (arc(tagged(_, const(_)), _, _) @ _) { false }
        (_) { true }
    }

    // ctorsAreExhaustive: list(Arc) -> bool
    fn ctorsAreExhaustive {
        (arc(tagged(_, ctor("cons", _)), _, _) @ arcs) {
            lst.any(fn {
                (arc(tagged(_, ctor("nil", _)), _, _)) { true }
                (_) { false }
            },
            arcs)
        }
        (arc(tagged(_, ctor("nil", _)), _, _) @ arcs) {
            lst.any(fn {
                (arc(tagged(_, ctor("cons", _)), _, _)) { true }
                (_) { false }
            },
            arcs)
        }
        (_) { false }
    }

    // simplify: pattern -> number -> pattern
    fn simplify {
        (tagged(tag, ctor(name, _)), n) {
            tagged(tag, ctor(name, makeTags(tag, n)))
        }
        (tagged(tag, tuple(_)), n) {
            tagged(tag, tuple(makeTags(tag, n)))
        }
        (x, _) { x }
    }

    // makeTags: string -> number -> list(pattern)
    fn makeTags(tag, n) {
        0 .. n - 1 |> makeTag(tag) |> fn (t) { tagged(t, wildcard) }
    }

    // arity: pattern -> number
    fn arity {
        (tagged(_, ctor(_, l))) |
        (tagged(_, tuple(l))) { lst.length(l) }
        (tagged(_, const(_))) { 0 }
        (x) { error("arity failed on " @@ $x) }
    }

    // rowsThatMatch: pattern -> list(pattern) -> list(pattern)
    fn rowsThatMatch(c, N) {
        let
            fn ctorMatches {
                (tagged(_, const(n)), tagged(_, const(n))) { true }
                (tagged(_, ctor(s, _)), tagged(_, ctor(s, _))) { true }
                (tagged(_, tuple(_)), tagged(_, tuple(_))) { true }
                (_, tagged(_, wildcard)) { true }
                (_, _) { false }
            }
            fn helper {
                (_, []) { [] }
                (n, pat @ pats) {
                    if (ctorMatches(c, pat)) {
                        n @ helper(n + 1, pats)
                    } else {
                        helper(n + 1, pats)
                    }
                }
            }
        in helper(0, N)
    }

    // simple: pattern -> bool
    fn simple {
        (tagged(_, ctor(_, _))) { false }
        (tagged(_, tuple(_))) { false }
        (tagged(_, const(_))) { false }
        (_) { true }
    }

///////////////////////////////////////////////////////////////////////////
// STAGE 3 Optimize the DFA
///////////////////////////////////////////////////////////////////////////

    // countStates: tpmc -> #(tpmc, refcounts)
    fn countStates (dfa) {
        let
            // collectStates: tpmc -> refcounts -> refcounts
            fn collectStates {
                (s = final(_, _, _, _), d) {
                    let label = makeLabel(s);
                    in switch (dict.lookup(label, d)) {
                            (some(rc)) { dict.insert(label, rc + 1, d) }
                            (nothing) { dict.insert(label, 1, d) }
                        }
                }
                (s = test(_, var, free, _, arcs), d) {
                    let fn collectArcs {
                        ([], d) { d }
                        (arc(_, _, s) @ arcs, d) {
                            collectArcs(arcs, d) => collectStates(s)
                        }
                    }
                    in collectArcs(arcs, d) => fn (d) {
                        let label = makeLabel(s);
                        in switch (dict.lookup(label, d)) {
                            (some(rc)) { dict.insert(label, rc + 1, d); }
                            (nothing) { dict.insert(label, 1, d); }
                        }
                    }
                }
            }
        in #(dfa, collectStates(dfa, dict.E))
    }

    // transferRefCountsToStates: #(tpmc, refcounts) -> tpmc
    fn transferRefCountsToStates (#(state, rcs)) {
        let
            fn getRc(s) {
                switch(dict.lookup(makeLabel(s), rcs)) {
                    (some(n)) { n }
                    (nothing) { 0 }
                };
            }
            fn h {
                (s = final(stamp, free, _, substs)) {
                    final(stamp, free, getRc(s), substs)
                }
                (s = test(stamp, var, free, _, st)) {
                    test(stamp, var, free, getRc(s), st |> i)
                }
            }
            fn i (arc(pat, free, state)) {
                arc(pat, free, h(state))
            }
        in h(state)
    }

///////////////////////////////////////////////////////////////////////////
// STAGE 4 Generate Intermediate Code
///////////////////////////////////////////////////////////////////////////

    // step 4.1 calculate free variables
    // calculateFreeVariables: tpmc -> tpmc
    fn calculateFreeVariables (dfa) {
        let
            // calculateFree: dfa -> dfa
            fn calculateFree {
                (final(stamp, _, rc, substs)) {
                    final(stamp, dict.values(substs), rc, substs)
                }
                (test(stamp, var, _, rc, arcs)) {
                    let freeArcs = arcs |> calculateFreeArc;
                        freeVars = (var @
                            ((freeArcs |> fn (arc(_, f, _)) { f }) =>
                                lst.concat)) => lst.unique;
                    in test(stamp, var, freeVars, rc, freeArcs)
                }
            }
            // calculateFreeArc: Arc -> Arc
            fn calculateFreeArc (arc(pat, _, s)) {
                let s2 = calculateFree(s);
                    fn arcFree (pat, s3) {
                        // varsInPat: pattern -> list(string)
                        let
                            unsafe fn varsInPat {
                                (tagged(x, ctor(_, args))) {
                                    x @ ((args |> varsInPat) =>
                                            lst.concat)
                                }
                                (tagged(x, tuple(args))) {
                                    x @ ((args |> varsInPat) =>
                                            lst.concat)
                                }
                                (tagged(x, _)) { [x] }
                            }
                            // freeVarsInState: tpmc -> list(string)
                            fn freeVarsInState {
                                (final(_, f, _, _)) |
                                (test(_, _, f, _, _)) { f }
                            }
                        in lst.exclude(varsInPat(pat),
                                       freeVarsInState(s3))
                    }
                in arc(pat, arcFree(pat, s2), s2)
            }
        in calculateFree(dfa)
    }

    // Stage 4.2 Translate the DFA to intermediate code
    // translate: tpmc -> code
    fn translate (tpmc) {
        let
            fn collectArcs {
                ([], d) { d }
                (arc(_, _, s) @ arcs, d) {
                    collectArcs(arcs, d) => collectLambdas(s)
                }
            }
            fn collectLambdas {
                (s = final(_, free, rc, _), d) {
                    if (rc > 1) {
                        dict.insert(makeLabel(s), s, d)
                    } else {
                        d
                    }
                }
                (s = test(_, _, _, rc, arcs), d) {
                    collectArcs(arcs, d) => fn (d) {
                        if (rc > 1) {
                            dict.insert(makeLabel(s), s, d)
                        } else {
                            d
                        }
                    }
                }
            }
            fn translateState {
                (final(stamp, free, rc, _)) {
                    if (rc > 1) {
                        apply(stamp, free)
                    } else {
                        expression(stamp);
                    }
                }
                (test(stamp, var, free, rc, arcs)) {
                    if (rc > 1) {
                        apply(stamp, free)
                    } else {
                        case(var, arcs |> translateArc)
                    }
                }
            }
            fn translateArc(arc(pat, _, state)) {
                rule(pat, translateState(state))
            }
            fn translateLambdas(lambdas) {
                dict.values(lambdas) |> fn {
                    (final(stamp, free, _, _)) {
                        #(stamp, lambda(free, expression(stamp)))
                    }
                    (test(stamp, var, free, _, arcs)) {
                        #(stamp, lambda(free, case(var, arcs |> translateArc)))
                    }
                }
            }
            fn wrapLetRec(body, lambdas) {
                letrec(translateLambdas(lambdas), body)
            }
        in collectLambdas(tpmc, dict.E) => wrapLetRec(translateState(tpmc))
    }

///////////////////////////////////////////////////////////////////////////
// Input
///////////////////////////////////////////////////////////////////////////

    input = [
        #(
            [
                variable("base"),
                const(1),
                tuple([variable("d"), const(3)]),
                ctor("cons", [variable("pat"), variable("pats")])
            ],
            "Exp.1"
        ),
        #(
            [
                wildcard,
                wildcard,
                tuple([variable("d"), wildcard]),
                ctor("nil", [])
            ],
            "Exp.2"
        )
    ];
in
///////////////////////////////////////////////////////////////////////////
// Test
///////////////////////////////////////////////////////////////////////////
    print input => rename => match => countStates =>
          transferRefCountsToStates => calculateFreeVariables => translate

// letrec(
//     [
//         #("Exp.2", lambda(["x$2$0"], expression("Exp.2"))),
//         #("error", lambda([], expression("error")))
//     ],
//     case("x$1", [
//         rule(x$1=1,
//             case("x$2", [
//                 rule(x$2=#(x$2$0=_, x$2$1=_),
//                     case("x$3", [
//                         rule(x$3=cons(x$3$0=_, x$3$1=_),
//                             case("x$2$1", [
//                                 rule(x$2$1=3, expression("Exp.1")),
//                                 rule(x$2$1=_, apply("error", []))
//                             ])
//                         ),
//                         rule(x$3=nil, apply("Exp.2", ["x$2$0"]))
//                     ])
//                 )
//             ])
//         ),
//         rule(x$1=_,
//             case("x$2", [
//                 rule(x$2=#(x$2$0=_, x$2$1=_),
//                     case("x$3", [
//                         rule(x$3=nil, apply("Exp.2", ["x$2$0"])),
//                         rule(x$3=_, apply("error", []))
//                     ])
//                 )
//             ])
//         )
//     ])
// )

// TEST stamp:LD_x$1 var:x$1 free:["x$1", "x$0", "x$2", "x$3"] refcount:1
//   arcs:[
//     ARC pat:x$1=1 free:["x$2", "x$3", "x$0"]
//       => state:TEST stamp:L_x$2 var:x$2 free:["x$2", "x$3", "x$0"] refcount:1
//         arcs:[
//           ARC pat::x$2=#(x$2$0=_, x$2$1=_) free:["x$3", "x$0"]
//             => state:TEST stamp:L_x$3 var:x$3 free:["x$3", "x$2$1", "x$0", "x$2$0"] refcount:2
//               arcs:[
//                 ARC pat::x$3=cons(x$3$0=_, x$3$1=_) free:["x$2$1", "x$0", "x$2$0"]
//                   => state:TEST stamp:LD_x$2$1 var:x$2$1 free:["x$2$1", "x$0", "x$2$0", "x$3$0", "x$3$1"] refcount:2
//                     arcs:[
//                       ARC pat::x$2$1=3 free:["x$0", "x$2$0", "x$3$0", "x$3$1"]
//                         => state:FINAL stamp:Exp.1 refcount:2 free:["x$0", "x$2$0", "x$3$0", "x$3$1"] substs:{
//                           "base": "x$0"
//                           "d": "x$2$0"
//                           "pat": "x$3$0"
//                           "pats": "x$3$1"
//                         };
//                       ARC pat::x$2$1=_ free:[]
//                         => state:FINAL stamp:error refcount:3 free:[] substs:{};
//                     ];
//                 ARC pat::x$3=nil free:["x$2$0"]
//                   => state:FINAL stamp:Exp.2 refcount:3 free:["x$2$0"] substs:{
//                     "d": "x$2$0"
//                   };
//               ];
//           ARC pat::x$2=#(x$2$0=_, x$2$1=_) free:["x$3", "x$0"]
//             => state:TEST stamp:L_x$3 var:x$3 free:["x$3", "x$2$1", "x$0", "x$2$0"] refcount:2
//               arcs:[
//                 ARC pat::x$3=cons(x$3$0=_, x$3$1=_) free:["x$2$1", "x$0", "x$2$0"]
//                   => state:TEST stamp:LD_x$2$1 var:x$2$1 free:["x$2$1", "x$0", "x$2$0", "x$3$0", "x$3$1"] refcount:2
//                     arcs:[
//                       ARC pat::x$2$1=3 free:["x$0", "x$2$0", "x$3$0", "x$3$1"]
//                         => state:FINAL stamp:Exp.1 refcount:2 free:["x$0", "x$2$0", "x$3$0", "x$3$1"] substs:{
//                           "base": "x$0"
//                           "d": "x$2$0"
//                           "pat": "x$3$0"
//                           "pats": "x$3$1"
//                         };
//                     ARC pat::x$2$1=_ free:[]
//                       => state:FINAL stamp:error refcount:3 free:[] substs:{};
//                  ];
//                ARC pat::x$3=nil free:["x$2$0"]
//                  => state:FINAL stamp:Exp.2 refcount:3 free:["x$2$0"] substs:{
//                   "d": "x$2$0"
//                 };
//              ];
//         ];
//     ARC pat::x$1=_ free:["x$2", "x$3"]
//       => state:TEST stamp:L_x$2 var:x$2 free:["x$2", "x$3"] refcount:1
//         arcs:[
//           ARC pat::x$2=#(x$2$0=_, x$2$1=_) free:["x$3"]
//             => state:TEST stamp:LD_x$3 var:x$3 free:["x$3", "x$2$0"] refount:3
//               arcs:[
//                 ARC pat::x$3=nil free:["x$2$0"]
//                   => state:FINAL stamp:Exp.2 free:["x$2$0"] substs:{
//                     "d": "x$2$0"
//                   };
//                 ARC pat::x$3=_ free:[]
//                   => state:FINAL stamp:error free:[] substs:{};
//              ];];]
