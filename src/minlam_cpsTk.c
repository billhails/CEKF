/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2025  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 * Generated from src/lambda.yaml by tools/generate.py
 */

#include "common.h"
#include "memory.h"
#include "minlam.h"
#include "symbol.h"

#include "cps_kont.h"
#include "cps_kont_impl.h"
#include "minlam_cps.h"
#include "minlam_functions.h"

#ifdef DEBUG_LAMBDA_CPSTK
#include "debugging_on.h"
#else
#include "debugging_off.h"
#endif

// Forward declarations
static MinExp *cpsTkMinPrimApp(MinPrimApp *node, CpsKont *k);
static MinExp *cpsTkMinSequence(MinExprList *node, CpsKont *k);
static MinExp *cpsTkMinApply(MinExp *node, CpsKont *k);
static MinExp *cpsTkMakeVec(MinExprList *node, CpsKont *k);
static MinExp *cpsTkMinIff(MinIff *node, CpsKont *k);
static MinExp *cpsTkMinCond(MinCond *node, CpsKont *k);
static MinExp *cpsTkMinMatch(MinMatch *node, CpsKont *k);
static MinExp *cpsTkMinLetRec(MinLetRec *node, CpsKont *k);
static MinExp *cpsTkMinAmb(MinAmb *node, CpsKont *k);
static MinExp *cpsTkMinExp(MinExp *node, CpsKont *k);

// utilities
static MinExp *INVOKE(CpsKont *k, MinExp *arg) {
    return k->wrapper(arg, k->env);
}

bool isAexpr(MinExp *exp) {
    switch (exp->type) {
    case MINEXP_TYPE_VAR:
    case MINEXP_TYPE_BACK:
    case MINEXP_TYPE_CHARACTER:
    case MINEXP_TYPE_LAM:
    case MINEXP_TYPE_STDINT:
    case MINEXP_TYPE_BIGINTEGER:
        return true;
    default:
        return false;
    }
}

MinExp *makeVar(ParserInfo PI, char *prefix) {
    return newMinExp_Var(PI, genSymDollar(prefix));
}

MinExprList *appendMinArg(MinExprList *args, MinExp *exp) {
    if (args == NULL)
        return newMinExprList(CPI(exp), exp, NULL);
    MinExprList *next = appendMinArg(args->next, exp);
    int save = PROTECT(next);
    MinExprList *this = newMinExprList(CPI(args), args->exp, next);
    UNPROTECT(save);
    return this;
}

SymbolList *appendMinVar(ParserInfo PI, SymbolList *args, HashSymbol *var) {
    if (args == NULL)
        return newSymbolList(PI, var, NULL);
    SymbolList *next = appendMinVar(PI, args->next, var);
    int save = PROTECT(next);
    SymbolList *this = newSymbolList(CPI(args), args->symbol, next);
    UNPROTECT(save);
    return this;
}

/*
    fn Ts_k {
        ([], k) { k([]) }
        (h @ t, k) {
            T_k(h, fn (hd) {
                Ts_k(t, fn (tl) {
                    k(hd @ tl)
                })
            })
        }
    }
 */
MinExp *cpsTs_k(MinExp *exp, CpsKont *k) {
    ENTER(cpsTs_k);
    if (getMinExp_Args(exp) == NULL) {
        return INVOKE(k, exp);
    }
    CpsKont *k1 = makeKont_TkS1(getMinExp_Args(exp)->next, k);
    int save = PROTECT(k1);
    MinExp *result =
        cpsTk(getMinExp_Args(exp)->exp, k1); // T_k(h, fn (hd) { ...k...t... })
    LEAVE(cpsTs_k);
    UNPROTECT(save);
    return result;
}

MinExp *TkS1Kont(MinExp *hd, TkS1KontEnv *env) {
    ENTER(TkS1Kont);
    CpsKont *k2 = makeKont_TkS2(env->k, hd);
    int save = PROTECT(k2);
    MinExp *args = newMinExp_Args(CPI(hd), env->t);
    PROTECT(args);
    MinExp *result = cpsTs_k(args, k2); // Ts_k(t, fn (tl) { ...k...hd... })
    LEAVE(TkS1Kont);
    UNPROTECT(save);
    return result;
}

MinExp *TkS2Kont(MinExp *tl, TkS2KontEnv *env) {
    ENTER(TkS2Kont);
    MinExp *args = makeMinExp_Args(CPI(env->hd), env->hd, getMinExp_Args(tl));
    int save = PROTECT(args);
    MinExp *result = INVOKE(env->k, args);
    UNPROTECT(save);
    LEAVE(TkS2Kont);
    return result;
}

/*
    fn kToC(k) {
        let rv = gensym("$rv");
        in E.lambda([rv], k(rv))
    }
*/
static MinExp *kToC(ParserInfo PI, CpsKont *k) {
    MinExp *rv = makeVar(PI, "rv");
    int save = PROTECT(rv);
    MinExp *body = INVOKE(k, rv);
    PROTECT(body);
    SymbolList *args = newSymbolList(PI, getMinExp_Var(rv), NULL);
    PROTECT(args);
    MinExp *cont = makeMinExp_Lam(PI, args, body);
    UNPROTECT(save);
    return cont;
}

// Visitor implementations

/*
    (E.primapp(p, e1, e2)) {
        T_k(e1, fn (s1) {
            T_k(e2, fn (s2) {
                k(E.primapp(p, s1, s2))
            })
        })
    }
*/
static MinExp *cpsTkMinPrimApp(MinPrimApp *node, CpsKont *k) {
    ENTER(cpsTkMinPrimApp);
    CpsKont *k1 = makeKont_TkPrimApp1(k, node->exp2, node->type);
    int save = PROTECT(k1);
    MinExp *result = cpsTk(node->exp1, k1);
    UNPROTECT(save);
    LEAVE(cpsTkMinPrimApp);
    return result;
}

MinExp *TkPrimApp1Kont(MinExp *s1, TkPrimApp1KontEnv *env) {
    ENTER(TkPrimApp1Kont);
    CpsKont *k = makeKont_TkPrimApp2(env->k, s1, env->p);
    int save = PROTECT(k);
    MinExp *result = cpsTk(env->e2, k);
    UNPROTECT(save);
    LEAVE(TkPrimApp1Kont);
    return result;
}

MinExp *TkPrimApp2Kont(MinExp *s2, TkPrimApp2KontEnv *env) {
    ENTER(TkPrimApp2Kont);
    MinExp *primapp = makeMinExp_Prim(CPI(env->s1), env->p, env->s1, s2);
    int save = PROTECT(primapp);
    MinExp *result = INVOKE(env->k, primapp);
    UNPROTECT(save);
    LEAVE(TkPrimApp2Kont);
    return result;
}

/*
    (E.sequence([expr])) { T_k(expr, k) }
    (E.sequence(expr @ exprs)) {
        T_k(expr, fn (ignored) {
            T_k(E.sequence(exprs), k)
        })
    }
*/
static MinExp *cpsTkMinSequence(MinExprList *node, CpsKont *k) {
    ENTER(cpsTkMinSequence);
#ifdef SAFETY_CHECKS
    if (node == NULL) {
        cant_happen("NULL node in cpsTkMinSequence");
    }
#endif
    MinExp *result = NULL;
    int save = PROTECT(NULL);
    if (node->next == NULL) {
        result = cpsTk(node->exp, k);
    } else {
        CpsKont *k1 = makeKont_TkSequence(k, node->next);
        PROTECT(k1);
        result = cpsTk(node->exp, k1);
    }
    UNPROTECT(save);
    LEAVE(cpsTkMinSequence);
    return result;
}

MinExp *TkSequenceKont(MinExp *ignored, TkSequenceKontEnv *env) {
    ENTER(TkSequenceKont);
    MinExp *sequence = newMinExp_Sequence(CPI(ignored), env->exprs);
    int save = PROTECT(sequence);
    MinExp *result = cpsTk(sequence, env->k);
    UNPROTECT(save);
    LEAVE(TkSequenceKont);
    return result;
}

/*
    (E.apply(_, _)) {
        let
            c = kToC(k)
        in
            T_c(e, c)
    }
*/
static MinExp *cpsTkMinApply(MinExp *node, CpsKont *k) {
    ENTER(cpsTkMinApply);
    if (node == NULL) {
        LEAVE(cpsTkMinApply);
        return NULL;
    }

    MinExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    MinExp *result = cpsTc(node, c);
    UNPROTECT(save);
    LEAVE(cpsTkMinApply);
    return result;
}

/*
    (E.make_vec(size, args)) {
        Ts_k(args, fn (sargs) {
            k(E.make_vec(size, sargs))
        })
    }
*/
static MinExp *cpsTkMakeVec(MinExprList *node, CpsKont *k) {
    ENTER(cpsTkMakeVec);
    CpsKont *k1 = makeKont_TkMakeVec(k);
    int save = PROTECT(k1);
    MinExp *args = newMinExp_Args(CPI(node), node);
    PROTECT(args);
    MinExp *result = cpsTs_k(args, k1);
    UNPROTECT(save);
    LEAVE(cpsTkMakeVec);
    return result;
}

MinExp *TkMakeVecKont(MinExp *sargs, TkMakeVecKontEnv *env) {
    ENTER(TkMakeVecKont);
    MinExp *make_vec = newMinExp_MakeVec(CPI(sargs), getMinExp_Args(sargs));
    int save = PROTECT(make_vec);
    MinExp *result = INVOKE(env->k, make_vec);
    UNPROTECT(save);
    LEAVE(TkMakeVecKont);
    return result;
}

/*
    (E.if_expr(exprc, exprt, exprf)) {
        let
            c = kToC(k);
        in
            T_k(exprc, fn(aexp) {
                E.if_expr(aexp, T_c(exprt, c), T_c(exprf, c))
            })
    }
*/
static MinExp *cpsTkMinIff(MinIff *node, CpsKont *k) {
    ENTER(cpsTkMinIff);
    if (node == NULL) {
        LEAVE(cpsTkMinIff);
        return NULL;
    }
    MinExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkIff(c, node->consequent, node->alternative);
    PROTECT(k2);
    MinExp *result = cpsTk(node->condition, k2);
    UNPROTECT(save);
    LEAVE(cpsTkMinIff);
    return result;
}

MinExp *TkIffKont(MinExp *aexp, TkIffKontEnv *env) {
    ENTER(TkIffKont);
    MinExp *consequent = cpsTc(env->exprt, env->c);
    int save = PROTECT(consequent);
    MinExp *alternative = cpsTc(env->exprf, env->c);
    PROTECT(alternative);
    MinExp *result = makeMinExp_Iff(CPI(aexp), aexp, consequent, alternative);
    UNPROTECT(save);
    LEAVE(TkIffKont);
    return result;
}

static MinIntCondCases *mapIntCondCases(MinIntCondCases *cases, MinExp *c) {
    if (cases == NULL)
        return NULL;
    MinIntCondCases *next = mapIntCondCases(cases->next, c);
    int save = PROTECT(next);
    MinExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    MinIntCondCases *this =
        newMinIntCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return this;
}

static MinCharCondCases *mapCharCondCases(MinCharCondCases *cases, MinExp *c) {
    if (cases == NULL)
        return NULL;
    MinCharCondCases *next = mapCharCondCases(cases->next, c);
    int save = PROTECT(next);
    MinExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    MinCharCondCases *this =
        newMinCharCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return this;
}

/*
    (E.cond_expr(test, branches)) {
        let
            c = kToC(k);
        in
            T_k(test, fn (atest) {
                E.cond_expr(atest, list.map(fn {(#(val, result)) {
                    #(val, T_c(result, c))
                }}, branches))
            })
    }
*/
static MinExp *cpsTkMinCond(MinCond *node, CpsKont *k) {
    ENTER(cpsTkMinCond);
    if (node == NULL) {
        LEAVE(cpsTkMinCond);
        return NULL;
    }
    MinExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkCond(c, node->cases);
    PROTECT(k2);
    MinExp *result = cpsTk(node->value, k2);
    UNPROTECT(save);
    LEAVE(cpsTkMinCond);
    return result;
}

MinExp *TkCondKont(MinExp *atest, TkCondKontEnv *env) {
    ENTER(TkCondKont);
    MinCondCases *cases = NULL;
    int save = PROTECT(NULL);
    switch (env->branches->type) {
    case MINCONDCASES_TYPE_INTEGERS: {
        MinIntCondCases *int_cases =
            mapIntCondCases(getMinCondCases_Integers(env->branches), env->c);
        PROTECT(int_cases);
        cases = newMinCondCases_Integers(CPI(atest), int_cases);
        PROTECT(cases);
    } break;
    case MINCONDCASES_TYPE_CHARACTERS: {
        MinCharCondCases *char_cases =
            mapCharCondCases(getMinCondCases_Characters(env->branches), env->c);
        PROTECT(char_cases);
        cases = newMinCondCases_Characters(CPI(atest), char_cases);
        PROTECT(cases);
    } break;
    default:
        cant_happen("Unknown MinCondCases type %s in TkCondKont",
                    minCondCasesTypeName(env->branches->type));
    }
    MinExp *result = makeMinExp_Cond(CPI(atest), atest, cases);
    LEAVE(TkCondKont);
    UNPROTECT(save);
    return result;
}

/*
    (E.match_cases(test, cases)) {
        let
            c = kToC(k);
        in
            T_k(test, fn (atest) {
                E.match_cases(atest, list.map(fn {(#(indices, result)) {
                    #(indices, T_c(result, c))
                }}, cases))
            })
    }
*/
static MinExp *cpsTkMinMatch(MinMatch *node, CpsKont *k) {
    ENTER(cpsTkMinMatch);
    MinExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkMatch(c, node->cases);
    PROTECT(k2);
    MinExp *result = cpsTk(node->index, k2);
    UNPROTECT(save);
    LEAVE(cpsTkMinMatch);
    return result;
}

MinMatchList *mapTcOverMatchCases(MinMatchList *cases, MinExp *c) {
    if (cases == NULL)
        return NULL;
    MinMatchList *next = mapTcOverMatchCases(cases->next, c);
    int save = PROTECT(next);
    MinExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    MinMatchList *this =
        newMinMatchList(CPI(cases), cases->matches, body, next);
    UNPROTECT(save);
    return this;
}

MinExp *TkMatchKont(MinExp *atest, TkMatchKontEnv *env) {
    ENTER(TkMatchKont);
    MinMatchList *cases = mapTcOverMatchCases(env->cases, env->c);
    int save = PROTECT(cases);
    MinExp *result = makeMinExp_Match(CPI(atest), atest, cases);
    UNPROTECT(save);
    LEAVE(TkMatchKont);
    return result;
}

void cpsUnzipMinBindings(MinBindings *bindings, SymbolList **vars,
                         MinExprList **exps) {
    if (bindings == NULL) {
        *vars = NULL;
        *exps = NULL;
        return;
    }
    cpsUnzipMinBindings(bindings->next, vars, exps);
    *vars = newSymbolList(CPI(bindings), bindings->var, *vars);
    PROTECT(*vars);
    *exps = newMinExprList(CPI(bindings), bindings->val, *exps);
    PROTECT(*exps);
}

MinExp *cpsNestLets(MinBindings *bindings, MinExp *body) {
    if (bindings == NULL) {
        return body;
    }
    MinExp *rest = cpsNestLets(bindings->next, body);
    int save = PROTECT(rest);
    SymbolList *farg = newSymbolList(CPI(bindings), bindings->var, NULL);
    PROTECT(farg);
    MinExp *lambda = makeMinExp_Lam(CPI(bindings), farg, rest);
    PROTECT(lambda);
    MinExprList *aarg = newMinExprList(CPI(bindings), bindings->val, NULL);
    PROTECT(aarg);
    MinExp *apply = makeMinExp_Apply(CPI(bindings), lambda, aarg);
    UNPROTECT(save);
    return apply;
}

MinBindings *mapMOverBindings(MinBindings *bindings) {
    if (bindings == NULL)
        return NULL;
    MinBindings *next = mapMOverBindings(bindings->next);
    int save = PROTECT(next);
    MinExp *val = cpsM(bindings->val);
    PROTECT(val);
    MinBindings *this = newMinBindings(CPI(bindings), bindings->var, val, next);
    this->arity = bindings->arity;
    UNPROTECT(save);
    return this;
}

/*
    (E.letrec_expr(bindings, expr)) {
        let
            #(vars, aexps) = list.unzip(bindings);
        in
            E.letrec_expr(list.zip(vars, list.map(M, aexps)), T_k(expr, k))
    }
*/
static MinExp *cpsTkMinLetRec(MinLetRec *node, CpsKont *k) {
    ENTER(cpsTkMinLetRec);
    MinBindings *bindings = mapMOverBindings(node->bindings);
    int save = PROTECT(bindings);
    MinExp *body = cpsTkMinExp(node->body, k);
    PROTECT(body);
    MinExp *result = makeMinExp_LetRec(CPI(node), bindings, body);
    UNPROTECT(save);
    LEAVE(cpsTkMinLetRec);
    return result;
}

/*
    (E.amb_expr(expr1, expr2)) {
        let
            c = kToC(k);
        in
            E.amb_expr(T_c(expr1, c), T_c(expr2, c))
    }
*/
static MinExp *cpsTkMinAmb(MinAmb *node, CpsKont *k) {
    MinExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    MinExp *exp1 = cpsTc(node->left, c);
    PROTECT(exp1);
    MinExp *exp2 = cpsTc(node->right, c);
    PROTECT(exp2);
    MinExp *result = makeMinExp_Amb(CPI(node), exp1, exp2);
    UNPROTECT(save);
    return result;
}

/*
    (E.callCC_expr(e)) {
        let
            c = kToC(k);
        in
            T_c(E.callCC_expr(e), c)
    }
*/
static MinExp *cpsTkCallCC(MinExp *node, CpsKont *k) {
    ENTER(cpsTkCallCC);
    MinExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    MinExp *result = cpsTc(node, c);
    UNPROTECT(save);
    LEAVE(cpsTkCallCC);
    return result;
}

static MinExp *cpsTkMinExp(MinExp *node, CpsKont *k) {
    if (node == NULL)
        return NULL;

    if (isAexpr(node)) {
        MinExp *expr = cpsM(node);
        int save = PROTECT(expr);
        MinExp *result = INVOKE(k, expr);
        UNPROTECT(save);
        return result;
    }

    switch (node->type) {
    case MINEXP_TYPE_AMB:
        return cpsTkMinAmb(getMinExp_Amb(node), k);
    case MINEXP_TYPE_APPLY:
        return cpsTkMinApply(node, k);
    case MINEXP_TYPE_CALLCC:
        return cpsTkCallCC(getMinExp_CallCC(node), k);
    case MINEXP_TYPE_COND:
        return cpsTkMinCond(getMinExp_Cond(node), k);
    case MINEXP_TYPE_IFF:
        return cpsTkMinIff(getMinExp_Iff(node), k);
    case MINEXP_TYPE_LETREC:
        return cpsTkMinLetRec(getMinExp_LetRec(node), k);
    case MINEXP_TYPE_MAKEVEC:
        return cpsTkMakeVec(getMinExp_MakeVec(node), k);
    case MINEXP_TYPE_MATCH:
        return cpsTkMinMatch(getMinExp_Match(node), k);
    case MINEXP_TYPE_PRIM:
        return cpsTkMinPrimApp(getMinExp_Prim(node), k);
    case MINEXP_TYPE_SEQUENCE:
        return cpsTkMinSequence(getMinExp_Sequence(node), k);
    default:
        cant_happen("unrecognized MinExp type %s [%s %d]",
                    minExpTypeName(node->type), CPI(node).fileName,
                    CPI(node).lineNo);
    }
}

MinExp *cpsTk(MinExp *node, CpsKont *k) { return cpsTkMinExp(node, k); }
