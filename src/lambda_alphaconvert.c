/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2025  Bill Hails
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 * Generated from src/lambda.yaml by tools/generate.py
 */

#include "lambda.h"
#include "common.h"
#include "memory.h"
#include "symbol.h"
#include "lambda_pp.h"

#include "lambda_alphaconvert.h"

// Forward declarations
static LamMacroSet *visitLamMacroSet(LamMacroSet *node, LamAlphaEnv *context);
static LamMacroArgsSet *visitLamMacroArgsSet(LamMacroArgsSet *node, LamAlphaEnv *context);
static LamInfoTable *visitLamInfoTable(LamInfoTable *node, LamAlphaEnv *context);
static LamAliasTable *visitLamAliasTable(LamAliasTable *node, LamAlphaEnv *context);
static LamExpTable *visitLamExpTable(LamExpTable *node, LamAlphaEnv *context);
static LamLam *visitLamLam(LamLam *node, LamAlphaEnv *context);
static LamVarList *visitLamVarList(LamVarList *node, LamAlphaEnv *context);
static LamPrimApp *visitLamPrimApp(LamPrimApp *node, LamAlphaEnv *context);
static LamSequence *visitLamSequence(LamSequence *node, LamAlphaEnv *context);
static LamArgs *visitLamArgs(LamArgs *node, LamAlphaEnv *context);
static LamApply *visitLamApply(LamApply *node, LamAlphaEnv *context);
static LamLookUp *visitLamLookUp(LamLookUp *node, LamAlphaEnv *context);
static LamLookUpSymbol *visitLamLookUpSymbol(LamLookUpSymbol *node, LamAlphaEnv *context);
static LamConstant *visitLamConstant(LamConstant *node, LamAlphaEnv *context);
static LamConstruct *visitLamConstruct(LamConstruct *node, LamAlphaEnv *context);
static LamDeconstruct *visitLamDeconstruct(LamDeconstruct *node, LamAlphaEnv *context);
static LamTupleIndex *visitLamTupleIndex(LamTupleIndex *node, LamAlphaEnv *context);
static LamMakeVec *visitLamMakeVec(LamMakeVec *node, LamAlphaEnv *context);
static LamIff *visitLamIff(LamIff *node, LamAlphaEnv *context);
static LamCond *visitLamCond(LamCond *node, LamAlphaEnv *context);
static LamIntCondCases *visitLamIntCondCases(LamIntCondCases *node, LamAlphaEnv *context);
static LamCharCondCases *visitLamCharCondCases(LamCharCondCases *node, LamAlphaEnv *context);
static LamMatch *visitLamMatch(LamMatch *node, LamAlphaEnv *context);
static LamMatchList *visitLamMatchList(LamMatchList *node, LamAlphaEnv *context);
static LamIntList *visitLamIntList(LamIntList *node, LamAlphaEnv *context);
static LamLetStar *visitLamLetStar(LamLetStar *node, LamAlphaEnv *context);
static LamLet *visitLamLet(LamLet *node, LamAlphaEnv *context);
static LamBindings *visitLetBindings(LamBindings *node, LamAlphaEnv *context);
static LamBindings *visitLetStarBindings(LamBindings *node, LamAlphaEnv *context);
static LamLetRec *visitLamLetRec(LamLetRec *node, LamAlphaEnv *context);
static LamContext *visitLamContext(LamContext *node, LamAlphaEnv *context);
static LamAmb *visitLamAmb(LamAmb *node, LamAlphaEnv *context);
static LamPrint *visitLamPrint(LamPrint *node, LamAlphaEnv *context);
static LamTypeOf *visitLamTypeOf(LamTypeOf *node, LamAlphaEnv *context);
static LamTypeDefs *visitLamTypeDefs(LamTypeDefs *node, LamAlphaEnv *context);
static LamTypeDefList *visitLamTypeDefList(LamTypeDefList *node, LamAlphaEnv *context);
static LamTypeDef *visitLamTypeDef(LamTypeDef *node, LamAlphaEnv *context);
static LamTypeConstructorList *visitLamTypeConstructorList(LamTypeConstructorList *node, LamAlphaEnv *context);
static LamTypeSig *visitLamTypeSig(LamTypeSig *node, LamAlphaEnv *context);
static LamTypeTags *visitLamTypeTags(LamTypeTags *node, LamAlphaEnv *context);
static LamTypeSigArgs *visitLamTypeSigArgs(LamTypeSigArgs *node, LamAlphaEnv *context);
static LamTypeConstructor *visitLamTypeConstructor(LamTypeConstructor *node, LamAlphaEnv *context);
static LamTypeConstructorArgs *visitLamTypeConstructorArgs(LamTypeConstructorArgs *node, LamAlphaEnv *context);
static LamTypeFunction *visitLamTypeFunction(LamTypeFunction *node, LamAlphaEnv *context);
static LamTypeConstructorInfo *visitLamTypeConstructorInfo(LamTypeConstructorInfo *node, LamAlphaEnv *context);
static LamExp *visitLamExp(LamExp *node, LamAlphaEnv *context);
static LamLookUpOrSymbol *visitLamLookUpOrSymbol(LamLookUpOrSymbol *node, LamAlphaEnv *context);
static LamCondCases *visitLamCondCases(LamCondCases *node, LamAlphaEnv *context);
static LamTypeConstructorType *visitLamTypeConstructorType(LamTypeConstructorType *node, LamAlphaEnv *context);
static LamInfo *visitLamInfo(LamInfo *node, LamAlphaEnv *context);
static LamNameSpaceArray *visitLamNameSpaceArray(LamNameSpaceArray *node, LamAlphaEnv *context);

int alpha_flag = 0;
char *alpha_conversion_function = NULL;

static void addNameToContext(HashSymbol *name, LamAlphaEnv *context) {
#ifdef SAFETY_CHECKS
    if (context == NULL) {
        cant_happen("addNameToContext called with NULL context");
    }
#endif
    HashSymbol *newName = genSymDollar(name->name);
    setLamAlphaTable(context->alphaTable, name, newName);
}

static HashSymbol *getNameFromContext(ParserInfo PI, HashSymbol *name, LamAlphaEnv *context) {
    struct HashSymbol *mappedName = NULL;
    while (context != NULL) {
        if (getLamAlphaTable(context->alphaTable, name, &mappedName)) {
            return mappedName;
        }
        context = context->next;
    }
    cant_happen("undefined variable %s [%s +%d]", name->name, PI.fileName, PI.lineNo);
}

static void pushNameSpaceEnv(LamAlphaEnv *context) {
    for (LamAlphaEnv *current = context; current != NULL; current = current->next) {
        if (current->nameSpaces != NULL) {
            pushLamAlphaEnvArray(current->nameSpaces, context);
            return;
        }
    }
    cant_happen("pushNameSpaceEnv called but no nameSpace array found in context");
}

static LamAlphaEnv *findAlphaNameSpaceEnv(LamAlphaEnv *context, Index index) {
    for (LamAlphaEnv *current = context; current != NULL; current = current->next) {
        if (current->nameSpaces != NULL) {
            if (index < current->nameSpaces->size) {
                return current->nameSpaces->entries[index];
            } else {
                cant_happen("findAlphaNameSpaceEnv: index %u out of bounds (size %u)", index, current->nameSpaces->size);
            }
        }
    }
    cant_happen("findAlphaNameSpaceEnv called but no nameSpace array found in context");
}

// Visitor implementations
static LamMacroSet *visitLamMacroSet(LamMacroSet *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    (void)context;  // Hash set has no values to visit
    // Iterate over keys (uncomment if you need to inspect/log them)
    // Index i = 0;
    // HashSymbol *key;
    // while ((key = iterateLamMacroSet(node, &i)) != NULL) {
    //     // Inspect/log key here
    // }
    return node;
}

__attribute__((unused))
static LamMacroArgsSet *visitLamMacroArgsSet(LamMacroArgsSet *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    (void)context;  // Hash set has no values to visit
    // Iterate over keys (uncomment if you need to inspect/log them)
    // Index i = 0;
    // HashSymbol *key;
    // while ((key = iterateLamMacroArgsSet(node, &i)) != NULL) {
    //     // Inspect/log key here
    // }
    return node;
}

static LamInfoTable *visitLamInfoTable(LamInfoTable *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamInfoTable *result = newLamInfoTable();
    int save = PROTECT(result);

    // Iterate over all entries
    Index i = 0;
    struct LamInfo * value;
    HashSymbol *key;
    while ((key = iterateLamInfoTable(node, &i, &value)) != NULL) {
        struct LamInfo * new_value = visitLamInfo(value, context);
        PROTECT(new_value);
        changed = changed || (new_value != value);
        setLamInfoTable(result, key, new_value);
    }

    if (changed) {
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamAliasTable *visitLamAliasTable(LamAliasTable *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamAliasTable *result = newLamAliasTable();
    int save = PROTECT(result);

    // Iterate over all entries
    Index i = 0;
    struct LamTypeConstructorType * value;
    HashSymbol *key;
    while ((key = iterateLamAliasTable(node, &i, &value)) != NULL) {
        struct LamTypeConstructorType * new_value = visitLamTypeConstructorType(value, context);
        PROTECT(new_value);
        changed = changed || (new_value != value);
        setLamAliasTable(result, key, new_value);
    }

    if (changed) {
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

__attribute__((unused))
static LamExpTable *visitLamExpTable(LamExpTable *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExpTable *result = newLamExpTable();
    int save = PROTECT(result);

    // Iterate over all entries
    Index i = 0;
    struct LamExp * value;
    HashSymbol *key;
    while ((key = iterateLamExpTable(node, &i, &value)) != NULL) {
        struct LamExp * new_value = visitLamExp(value, context);
        PROTECT(new_value);
        changed = changed || (new_value != value);
        setLamExpTable(result, key, new_value);
    }

    if (changed) {
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamLam *visitLamLam(LamLam *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    context = newLamAlphaEnv(context);
    int save = PROTECT(context);

    bool changed = false;
    LamVarList *new_args = visitLamVarList(node->args, context);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);
    LamExp *new_exp = visitLamExp(node->exp, context);
    PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        LamLam *result = newLamLam(CPI(node), new_args, new_exp);
        result->isMacro = node->isMacro;
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamVarList *visitLamVarList(LamVarList *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    LamVarList *new_next = visitLamVarList(node->next, context);
    int save = PROTECT(new_next);

    addNameToContext(node->var, context);

    LamVarList *result = newLamVarList(CPI(node), getNameFromContext(CPI(node), node->var, context), new_next);
    UNPROTECT(save);
    return result;
}

static LamPrimApp *visitLamPrimApp(LamPrimApp *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through type (type: LamPrimOp, not memory-managed)
    LamExp *new_exp1 = visitLamExp(node->exp1, context);
    int save = PROTECT(new_exp1);
    changed = changed || (new_exp1 != node->exp1);
    LamExp *new_exp2 = visitLamExp(node->exp2, context);
    PROTECT(new_exp2);
    changed = changed || (new_exp2 != node->exp2);

    if (changed) {
        // Create new node with modified fields
        LamPrimApp *result = newLamPrimApp(CPI(node), node->type, new_exp1, new_exp2);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamSequence *visitLamSequence(LamSequence *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_exp = visitLamExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamSequence *new_next = visitLamSequence(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamSequence *result = newLamSequence(CPI(node), new_exp, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamArgs *visitLamArgs(LamArgs *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_exp = visitLamExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamArgs *new_next = visitLamArgs(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamArgs *result = newLamArgs(CPI(node), new_exp, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamApply *visitLamApply(LamApply *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_function = visitLamExp(node->function, context);
    int save = PROTECT(new_function);
    if (new_function == NULL) {
        cant_happen("visitLamApply: function is NULL");
    }
    changed = changed || (new_function != node->function);
    LamArgs *new_args = visitLamArgs(node->args, context);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamApply *result = newLamApply(CPI(node), new_function, new_args);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamLookUp *visitLamLookUp(LamLookUp *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through nsId (type: int, not memory-managed)
    // Pass through nsSymbol (type: HashSymbol, not memory-managed)
    LamAlphaEnv *nsContext = findAlphaNameSpaceEnv(context, node->nsId);
    LamExp *new_exp = visitLamExp(node->exp, nsContext);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        LamLookUp *result = newLamLookUp(CPI(node), node->nsId, node->nsSymbol, new_exp);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamLookUpSymbol *visitLamLookUpSymbol(LamLookUpSymbol *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    // Pass through nsId (type: int, not memory-managed)
    // Pass through nsSymbol (type: HashSymbol, not memory-managed)
    // Pass through symbol (type: HashSymbol, not memory-managed)

    (void)context;  // Unused parameter - all fields are pass-through
    return node;
}

static LamConstant *visitLamConstant(LamConstant *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through tag (type: int, not memory-managed)

    (void)context;  // Unused parameter - all fields are pass-through
    return node;
}

static LamConstruct *visitLamConstruct(LamConstruct *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through tag (type: int, not memory-managed)
    LamArgs *new_args = visitLamArgs(node->args, context);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamConstruct *result = newLamConstruct(CPI(node), node->name, node->tag, new_args);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamDeconstruct *visitLamDeconstruct(LamDeconstruct *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through nsId (type: int, not memory-managed)
    // Pass through vec (type: int, not memory-managed)
    LamExp *new_exp = visitLamExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        LamDeconstruct *result = newLamDeconstruct(CPI(node), node->name, node->nsId, node->vec, new_exp);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTupleIndex *visitLamTupleIndex(LamTupleIndex *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through vec (type: int, not memory-managed)
    // Pass through size (type: int, not memory-managed)
    LamExp *new_exp = visitLamExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        LamTupleIndex *result = newLamTupleIndex(CPI(node), node->vec, node->size, new_exp);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamMakeVec *visitLamMakeVec(LamMakeVec *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through nArgs (type: int, not memory-managed)
    LamArgs *new_args = visitLamArgs(node->args, context);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamMakeVec *result = newLamMakeVec(CPI(node), node->nArgs, new_args);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamIff *visitLamIff(LamIff *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_condition = visitLamExp(node->condition, context);
    int save = PROTECT(new_condition);
    changed = changed || (new_condition != node->condition);
    LamExp *new_consequent = visitLamExp(node->consequent, context);
    PROTECT(new_consequent);
    changed = changed || (new_consequent != node->consequent);
    LamExp *new_alternative = visitLamExp(node->alternative, context);
    PROTECT(new_alternative);
    changed = changed || (new_alternative != node->alternative);

    if (changed) {
        // Create new node with modified fields
        LamIff *result = newLamIff(CPI(node), new_condition, new_consequent, new_alternative);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamCond *visitLamCond(LamCond *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_value = visitLamExp(node->value, context);
    int save = PROTECT(new_value);
    changed = changed || (new_value != node->value);
    LamCondCases *new_cases = visitLamCondCases(node->cases, context);
    PROTECT(new_cases);
    changed = changed || (new_cases != node->cases);

    if (changed) {
        // Create new node with modified fields
        LamCond *result = newLamCond(CPI(node), new_value, new_cases);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamIntCondCases *visitLamIntCondCases(LamIntCondCases *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through constant (type: MaybeBigInt, not memory-managed)
    LamExp *new_body = visitLamExp(node->body, context);
    int save = PROTECT(new_body);
    changed = changed || (new_body != node->body);
    LamIntCondCases *new_next = visitLamIntCondCases(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamIntCondCases *result = newLamIntCondCases(CPI(node), node->constant, new_body, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamCharCondCases *visitLamCharCondCases(LamCharCondCases *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through constant (type: character, not memory-managed)
    LamExp *new_body = visitLamExp(node->body, context);
    int save = PROTECT(new_body);
    changed = changed || (new_body != node->body);
    LamCharCondCases *new_next = visitLamCharCondCases(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamCharCondCases *result = newLamCharCondCases(CPI(node), node->constant, new_body, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamMatch *visitLamMatch(LamMatch *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_index = visitLamExp(node->index, context);
    int save = PROTECT(new_index);
    changed = changed || (new_index != node->index);
    LamMatchList *new_cases = visitLamMatchList(node->cases, context);
    PROTECT(new_cases);
    changed = changed || (new_cases != node->cases);

    if (changed) {
        // Create new node with modified fields
        LamMatch *result = newLamMatch(CPI(node), new_index, new_cases);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamMatchList *visitLamMatchList(LamMatchList *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamIntList *new_matches = visitLamIntList(node->matches, context);
    int save = PROTECT(new_matches);
    changed = changed || (new_matches != node->matches);
    LamExp *new_body = visitLamExp(node->body, context);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);
    LamMatchList *new_next = visitLamMatchList(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamMatchList *result = newLamMatchList(CPI(node), new_matches, new_body, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamIntList *visitLamIntList(LamIntList *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through item (type: int, not memory-managed)
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through nsId (type: int, not memory-managed)
    LamIntList *new_next = visitLamIntList(node->next, context);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamIntList *result = newLamIntList(CPI(node), node->item, node->name, node->nsId, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamLet *visitLamLet(LamLet *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;
    context = newLamAlphaEnv(context);
    int save = PROTECT(context);
    bool changed = false;
    LamBindings *new_bindings = visitLetBindings(node->bindings, context);
    PROTECT(new_bindings);
    changed = changed || (new_bindings != node->bindings);
    LamExp *new_body = visitLamExp(node->body, context);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);
    if (changed) {
        // Create new node with modified fields
        LamLet *result = newLamLet(CPI(node), new_bindings, new_body);
        UNPROTECT(save);
        return result;
    }
    UNPROTECT(save);
    return node;
}

static LamBindings *visitLetBindings(LamBindings *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;
    LamExp *new_val = visitLamExp(node->val, context);
    int save = PROTECT(new_val);
    LamBindings *new_next = visitLetBindings(node->next, context);
    PROTECT(new_next);
    addNameToContext(node->var, context);
    // Create new node with modified fields
    LamBindings *result = newLamBindings(CPI(node), getNameFromContext(CPI(node), node->var, context), new_val, new_next);
    UNPROTECT(save);
    return result;
}

static LamLetStar *visitLamLetStar(LamLetStar *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;
    context = newLamAlphaEnv(context);
    int save = PROTECT(context);
    bool changed = false;
    LamBindings *new_bindings = visitLetStarBindings(node->bindings, context);
    PROTECT(new_bindings);
    changed = changed || (new_bindings != node->bindings);
    LamExp *new_body = visitLamExp(node->body, context);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);
    if (changed) {
        // Create new node with modified fields
        LamLetStar *result = newLamLetStar(CPI(node), new_bindings, new_body);
        UNPROTECT(save);
        return result;
    }
    UNPROTECT(save);
    return node;
}

static LamBindings *visitLetStarBindings(LamBindings *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;
    LamExp *new_val = visitLamExp(node->val, context);
    int save = PROTECT(new_val);
    addNameToContext(node->var, context);
    LamBindings *new_next = visitLetStarBindings(node->next, context);
    PROTECT(new_next);
    // Create new node with modified fields
    LamBindings *result = newLamBindings(CPI(node), getNameFromContext(CPI(node), node->var, context), new_val, new_next);
    UNPROTECT(save);
    return result;
}

static LamBindings *visitLetRecValues(LamBindings *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;
    LamExp *new_val = visitLamExp(node->val, context);
    int save = PROTECT(new_val);
    if (alpha_conversion_function != NULL &&
        strcmp(alpha_conversion_function, node->var->name) == 0) {
            ppLamExp(new_val);
            eprintf("\n");
    }
    LamBindings *new_next = visitLetRecValues(node->next, context);
    PROTECT(new_next);
    LamBindings *result = newLamBindings(CPI(node), getNameFromContext(CPI(node), node->var, context), new_val, new_next);
    UNPROTECT(save);
    return result;
}

static void visitLetRecVariables(LamBindings *node, LamAlphaEnv *context) {
    if (node == NULL) return;
    visitLetRecVariables(node->next, context);
    addNameToContext(node->var, context);
}

static LamLetRec *visitLamLetRec(LamLetRec *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    context = newLamAlphaEnv(context);
    int save = PROTECT(context);

    visitLetRecVariables(node->bindings, context);
    LamBindings *new_bindings = visitLetRecValues(node->bindings, context);
    PROTECT(new_bindings);
    LamExp *new_body = visitLamExp(node->body, context);
    PROTECT(new_body);

    // Create new node with modified fields
    LamLetRec *result = newLamLetRec(CPI(node), new_bindings, new_body);
    UNPROTECT(save);
    return result;
}

static LamContext *visitLamContext(LamContext *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamInfoTable *new_frame = visitLamInfoTable(node->frame, context);
    int save = PROTECT(new_frame);
    changed = changed || (new_frame != node->frame);
    LamAliasTable *new_aliases = visitLamAliasTable(node->aliases, context);
    PROTECT(new_aliases);
    changed = changed || (new_aliases != node->aliases);
    LamMacroSet *new_macros = visitLamMacroSet(node->macros, context);
    PROTECT(new_macros);
    changed = changed || (new_macros != node->macros);
    LamContext *new_parent = visitLamContext(node->parent, context);
    PROTECT(new_parent);
    changed = changed || (new_parent != node->parent);

    if (changed) {
        // Create new node with modified fields
        LamContext *result = newLamContext(CPI(node), new_parent);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamAmb *visitLamAmb(LamAmb *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_left = visitLamExp(node->left, context);
    int save = PROTECT(new_left);
    changed = changed || (new_left != node->left);
    LamExp *new_right = visitLamExp(node->right, context);
    PROTECT(new_right);
    changed = changed || (new_right != node->right);

    if (changed) {
        // Create new node with modified fields
        LamAmb *result = newLamAmb(CPI(node), new_left, new_right);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamPrint *visitLamPrint(LamPrint *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_exp = visitLamExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamExp *new_printer = visitLamExp(node->printer, context);
    PROTECT(new_printer);
    changed = changed || (new_printer != node->printer);

    if (changed) {
        // Create new node with modified fields
        LamPrint *result = newLamPrint(CPI(node), new_exp);
        result->printer = new_printer;
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeOf *visitLamTypeOf(LamTypeOf *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamExp *new_exp = visitLamExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamExp *new_typeString = visitLamExp(node->typeString, context);
    PROTECT(new_typeString);
    changed = changed || (new_typeString != node->typeString);

    if (changed) {
        // Create new node with modified fields
        LamTypeOf *result = newLamTypeOf(CPI(node), new_exp);
        result->typeString = new_typeString;
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeDefs *visitLamTypeDefs(LamTypeDefs *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamTypeDefList *new_typeDefs = visitLamTypeDefList(node->typeDefs, context);
    int save = PROTECT(new_typeDefs);
    changed = changed || (new_typeDefs != node->typeDefs);
    LamExp *new_body = visitLamExp(node->body, context);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);

    if (changed) {
        // Create new node with modified fields
        LamTypeDefs *result = newLamTypeDefs(CPI(node), new_typeDefs, new_body);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeDefList *visitLamTypeDefList(LamTypeDefList *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamTypeDef *new_typeDef = visitLamTypeDef(node->typeDef, context);
    int save = PROTECT(new_typeDef);
    changed = changed || (new_typeDef != node->typeDef);
    LamTypeDefList *new_next = visitLamTypeDefList(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeDefList *result = newLamTypeDefList(CPI(node), new_typeDef, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeDef *visitLamTypeDef(LamTypeDef *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamTypeSig *new_type = visitLamTypeSig(node->type, context);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeConstructorList *new_constructors = visitLamTypeConstructorList(node->constructors, context);
    PROTECT(new_constructors);
    changed = changed || (new_constructors != node->constructors);

    if (changed) {
        // Create new node with modified fields
        LamTypeDef *result = newLamTypeDef(CPI(node), new_type, new_constructors);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeConstructorList *visitLamTypeConstructorList(LamTypeConstructorList *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamTypeConstructor *new_constructor = visitLamTypeConstructor(node->constructor, context);
    int save = PROTECT(new_constructor);
    changed = changed || (new_constructor != node->constructor);
    LamTypeConstructorList *new_next = visitLamTypeConstructorList(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorList *result = newLamTypeConstructorList(CPI(node), new_constructor, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeSig *visitLamTypeSig(LamTypeSig *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSigArgs *new_args = visitLamTypeSigArgs(node->args, context);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeSig *result = newLamTypeSig(CPI(node), node->name, new_args);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeTags *visitLamTypeTags(LamTypeTags *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through tag (type: HashSymbol, not memory-managed)
    LamTypeTags *new_next = visitLamTypeTags(node->next, context);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeTags *result = newLamTypeTags(CPI(node), node->tag, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeSigArgs *visitLamTypeSigArgs(LamTypeSigArgs *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSigArgs *new_next = visitLamTypeSigArgs(node->next, context);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeSigArgs *result = newLamTypeSigArgs(CPI(node), node->name, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeConstructor *visitLamTypeConstructor(LamTypeConstructor *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSig *new_type = visitLamTypeSig(node->type, context);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeConstructorArgs *new_args = visitLamTypeConstructorArgs(node->args, context);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructor *result = newLamTypeConstructor(CPI(node), node->name, new_type, new_args);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeConstructorArgs *visitLamTypeConstructorArgs(LamTypeConstructorArgs *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamTypeConstructorType *new_arg = visitLamTypeConstructorType(node->arg, context);
    int save = PROTECT(new_arg);
    changed = changed || (new_arg != node->arg);
    LamTypeConstructorArgs *new_next = visitLamTypeConstructorArgs(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorArgs *result = newLamTypeConstructorArgs(CPI(node), new_arg, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeFunction *visitLamTypeFunction(LamTypeFunction *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamLookUpOrSymbol *new_name = visitLamLookUpOrSymbol(node->name, context);
    int save = PROTECT(new_name);
    changed = changed || (new_name != node->name);
    LamTypeConstructorArgs *new_args = visitLamTypeConstructorArgs(node->args, context);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeFunction *result = newLamTypeFunction(CPI(node), new_name, new_args);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamTypeConstructorInfo *visitLamTypeConstructorInfo(LamTypeConstructorInfo *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through nsId (type: int, not memory-managed)
    LamTypeConstructor *new_type = visitLamTypeConstructor(node->type, context);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeTags *new_tags = visitLamTypeTags(node->tags, context);
    PROTECT(new_tags);
    changed = changed || (new_tags != node->tags);
    // Pass through needsVec (type: bool, not memory-managed)
    // Pass through arity (type: int, not memory-managed)
    // Pass through size (type: int, not memory-managed)
    // Pass through index (type: int, not memory-managed)

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorInfo *result = newLamTypeConstructorInfo(CPI(node), node->name, node->nsId, new_type, new_tags, node->needsVec, node->arity, node->size, node->index);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static LamExp *visitLamExp(LamExp *node, LamAlphaEnv *context) {
    if (node == NULL) {
        cant_happen("visitLamExp called with NULL");
        return NULL;
    }

    LamExp *result = node;
    int save = PROTECT(result);

    switch (node->type) {
        case LAMEXP_TYPE_AMB: {
            // LamAmb
            LamAmb *variant = getLamExp_Amb(node);
            LamAmb *new_variant = visitLamAmb(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Amb(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_APPLY: {
            // LamApply
            LamApply *variant = getLamExp_Apply(node);
            LamApply *new_variant = visitLamApply(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Apply(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_ARGS: {
            // LamArgs
            LamArgs *variant = getLamExp_Args(node);
            LamArgs *new_variant = visitLamArgs(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Args(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_BACK: {
            // void_ptr
            break;
        }
        case LAMEXP_TYPE_BIGINTEGER: {
            // MaybeBigInt
            break;
        }
        case LAMEXP_TYPE_BINDINGS: {
            // LamBindings
            cant_happen("LamExp of type BINDINGS should not occur in the wild");
            break;
        }
        case LAMEXP_TYPE_CALLCC: {
            // LamExp
            LamExp *variant = getLamExp_CallCC(node);
            LamExp *new_variant = visitLamExp(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_CallCC(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_CHARACTER: {
            // character
            break;
        }
        case LAMEXP_TYPE_COND: {
            // LamCond
            LamCond *variant = getLamExp_Cond(node);
            LamCond *new_variant = visitLamCond(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Cond(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_CONSTANT: {
            // LamConstant
            LamConstant *variant = getLamExp_Constant(node);
            LamConstant *new_variant = visitLamConstant(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Constant(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_CONSTRUCT: {
            // LamConstruct
            LamConstruct *variant = getLamExp_Construct(node);
            LamConstruct *new_variant = visitLamConstruct(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Construct(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_CONSTRUCTOR: {
            // LamTypeConstructorInfo
            LamTypeConstructorInfo *variant = getLamExp_Constructor(node);
            LamTypeConstructorInfo *new_variant = visitLamTypeConstructorInfo(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Constructor(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_DECONSTRUCT: {
            // LamDeconstruct
            LamDeconstruct *variant = getLamExp_Deconstruct(node);
            LamDeconstruct *new_variant = visitLamDeconstruct(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Deconstruct(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_ENV: {
            // void_ptr
            // the `(env)` directive is a way of capturing the current
            // environment from the "body" of a nameSpace.
            // It is a generated instruction and cannot be written
            // directly in source code.
            // It must be the only expression in the nameSpace body and
            // it can only appear there. It is an instruction
            // that the current environment should be
            // associated with the current nameSpace at this point.
            pushNameSpaceEnv(context);
            break;
        }
        case LAMEXP_TYPE_ERROR: {
            // void_ptr
            break;
        }
        case LAMEXP_TYPE_IFF: {
            // LamIff
            LamIff *variant = getLamExp_Iff(node);
            LamIff *new_variant = visitLamIff(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Iff(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LAM: {
            // LamLam
            LamLam *variant = getLamExp_Lam(node);
            LamLam *new_variant = visitLamLam(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Lam(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LET: {
            // LamLet
            LamLet *variant = getLamExp_Let(node);
            LamLet *new_variant = visitLamLet(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Let(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LETSTAR: {
            // LamLetStar
            LamLetStar *variant = getLamExp_LetStar(node);
            LamLetStar *new_variant = visitLamLetStar(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_LetStar(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LETREC: {
            // LamLetRec
            LamLetRec *variant = getLamExp_LetRec(node);
            LamLetRec *new_variant = visitLamLetRec(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_LetRec(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LOOKUP: {
            // LamLookUp
            LamLookUp *variant = getLamExp_LookUp(node);
            LamLookUp *new_variant = visitLamLookUp(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_LookUp(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_MAKETUPLE: {
            // LamArgs
            LamArgs *variant = getLamExp_MakeTuple(node);
            LamArgs *new_variant = visitLamArgs(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_MakeTuple(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_MAKEVEC: {
            // LamMakeVec
            LamMakeVec *variant = getLamExp_MakeVec(node);
            LamMakeVec *new_variant = visitLamMakeVec(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_MakeVec(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_MATCH: {
            // LamMatch
            LamMatch *variant = getLamExp_Match(node);
            LamMatch *new_variant = visitLamMatch(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Match(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_NAMESPACES: {
            // LamNameSpaceArray
            LamNameSpaceArray *variant = getLamExp_NameSpaces(node);
            LamNameSpaceArray *new_variant = visitLamNameSpaceArray(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_NameSpaces(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_PRIM: {
            // LamPrimApp
            LamPrimApp *variant = getLamExp_Prim(node);
            LamPrimApp *new_variant = visitLamPrimApp(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Prim(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_PRINT: {
            // LamPrint
            LamPrint *variant = getLamExp_Print(node);
            LamPrint *new_variant = visitLamPrint(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Print(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_SEQUENCE: {
            // LamSequence
            LamSequence *variant = getLamExp_Sequence(node);
            LamSequence *new_variant = visitLamSequence(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Sequence(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_STDINT: {
            // int
            break;
        }
        case LAMEXP_TYPE_TAG: {
            // LamExp
            LamExp *variant = getLamExp_Tag(node);
            LamExp *new_variant = visitLamExp(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Tag(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TUPLEINDEX: {
            // LamTupleIndex
            LamTupleIndex *variant = getLamExp_TupleIndex(node);
            LamTupleIndex *new_variant = visitLamTupleIndex(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_TupleIndex(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TYPEDEFS: {
            // LamTypeDefs
            LamTypeDefs *variant = getLamExp_Typedefs(node);
            LamTypeDefs *new_variant = visitLamTypeDefs(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Typedefs(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TYPEOF: {
            // LamTypeOf
            LamTypeOf *variant = getLamExp_TypeOf(node);
            LamTypeOf *new_variant = visitLamTypeOf(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_TypeOf(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_VAR: {
            // HashSymbol
            result = newLamExp_Var(CPI(node), getNameFromContext(CPI(node), getLamExp_Var(node), context));
            break;
        }
        default:
            cant_happen("unrecognized LamExp type %s", lamExpTypeName(node->type));
    }

    UNPROTECT(save);
    return result;
}

static LamLookUpOrSymbol *visitLamLookUpOrSymbol(LamLookUpOrSymbol *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    int save = PROTECT(NULL);
    LamLookUpOrSymbol *result = node;

    switch (node->type) {
        case LAMLOOKUPORSYMBOL_TYPE_SYMBOL: {
            // HashSymbol
            break;
        }
        case LAMLOOKUPORSYMBOL_TYPE_LOOKUP: {
            // LamLookUpSymbol
            LamLookUpSymbol *variant = getLamLookUpOrSymbol_LookUp(node);
            LamLookUpSymbol *new_variant = visitLamLookUpSymbol(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamLookUpOrSymbol_LookUp(CPI(node), new_variant);
            }
            break;
        }
        default:
            cant_happen("unrecognized LamLookUpOrSymbol type %d", node->type);
    }

    UNPROTECT(save);
    return result;
}

static LamCondCases *visitLamCondCases(LamCondCases *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    int save = PROTECT(NULL);
    LamCondCases *result = node;

    switch (node->type) {
        case LAMCONDCASES_TYPE_INTEGERS: {
            // LamIntCondCases
            LamIntCondCases *variant = getLamCondCases_Integers(node);
            LamIntCondCases *new_variant = visitLamIntCondCases(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamCondCases_Integers(CPI(node), new_variant);
            }
            break;
        }
        case LAMCONDCASES_TYPE_CHARACTERS: {
            // LamCharCondCases
            LamCharCondCases *variant = getLamCondCases_Characters(node);
            LamCharCondCases *new_variant = visitLamCharCondCases(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamCondCases_Characters(CPI(node), new_variant);
            }
            break;
        }
        default:
            cant_happen("unrecognized LamCondCases type %d", node->type);
    }

    UNPROTECT(save);
    return result;
}

static LamTypeConstructorType *visitLamTypeConstructorType(LamTypeConstructorType *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    int save = PROTECT(NULL);
    LamTypeConstructorType *result = node;

    switch (node->type) {
        case LAMTYPECONSTRUCTORTYPE_TYPE_INTEGER: {
            // void_ptr
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_CHARACTER: {
            // void_ptr
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_VAR: {
            // HashSymbol
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_FUNCTION: {
            // LamTypeFunction
            LamTypeFunction *variant = getLamTypeConstructorType_Function(node);
            LamTypeFunction *new_variant = visitLamTypeFunction(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamTypeConstructorType_Function(CPI(node), new_variant);
            }
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_TUPLE: {
            // LamTypeConstructorArgs
            LamTypeConstructorArgs *variant = getLamTypeConstructorType_Tuple(node);
            LamTypeConstructorArgs *new_variant = visitLamTypeConstructorArgs(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamTypeConstructorType_Tuple(CPI(node), new_variant);
            }
            break;
        }
        default:
            cant_happen("unrecognized LamTypeConstructorType type %d", node->type);
    }

    UNPROTECT(save);
    return result;
}

static LamInfo *visitLamInfo(LamInfo *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    int save = PROTECT(NULL);
    LamInfo *result = node;

    switch (node->type) {
        case LAMINFO_TYPE_TYPECONSTRUCTORINFO: {
            // LamTypeConstructorInfo
            LamTypeConstructorInfo *variant = getLamInfo_TypeConstructorInfo(node);
            LamTypeConstructorInfo *new_variant = visitLamTypeConstructorInfo(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamInfo_TypeConstructorInfo(CPI(node), new_variant);
            }
            break;
        }
        case LAMINFO_TYPE_NAMESPACEINFO: {
            // LamContext
            LamContext *variant = getLamInfo_NameSpaceInfo(node);
            LamContext *new_variant = visitLamContext(variant, context);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamInfo_NameSpaceInfo(CPI(node), new_variant);
            }
            break;
        }
        case LAMINFO_TYPE_NSID: {
            // int
            break;
        }
        default:
            cant_happen("unrecognized LamInfo type %d", node->type);
    }

    UNPROTECT(save);
    return result;
}

static LamNameSpaceArray *visitLamNameSpaceArray(LamNameSpaceArray *node, LamAlphaEnv *context) {
    if (node == NULL) return NULL;

    bool changed = false;
    LamNameSpaceArray *result = newLamNameSpaceArray();
    int save = PROTECT(result);
    context->nameSpaces = newLamAlphaEnvArray();

    // Iterate over all elements
    for (Index i = 0; i < node->size; i++) {
        struct LamExp * element = peeknLamNameSpaceArray(node, i);
        struct LamExp * new_element = visitLamExp(element, context);
        PROTECT(new_element);
        changed = changed || (new_element != element);
        pushLamNameSpaceArray(result, new_element);
    }

    if (changed) {
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static void addBuiltInsToLamAlphaEnv(LamAlphaEnv *env, BuiltIns *b) {
    for (Index i = 0; i < b->size; i++) {
        // Bind only internal names; external names are provided by wrappers.
        setLamAlphaTable(env->alphaTable, b->entries[i]->internalName, b->entries[i]->internalName);
    }
}

LamExp *alphaConvertLamExp(LamExp *exp, BuiltIns *builtIns) {
    LamAlphaEnv *env = newLamAlphaEnv(NULL);
    int save = PROTECT(env);
    addBuiltInsToLamAlphaEnv(env, builtIns);
    LamExp *result = visitLamExp(exp, env);
    UNPROTECT(save);
    return result;
}