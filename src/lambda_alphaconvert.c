/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2025  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 * Generated from src/lambda.yaml by tools/generate.py
 */

#include "common.h"
#include "memory.h"
#include "minlam.h"
#include "minlam_pp.h"
#include "symbol.h"
#include "utils.h"

#include "lambda_alphaconvert.h"

// Forward declarations
static MinLam *visitMinLam(MinLam *node, MinAlphaEnv *context);
static MinVarList *visitMinVarList(MinVarList *node, MinAlphaEnv *context);
static MinPrimApp *visitMinPrimApp(MinPrimApp *node, MinAlphaEnv *context);
static MinExprList *visitMinSequence(MinExprList *node, MinAlphaEnv *context);
static MinExprList *visitMinArgs(MinExprList *node, MinAlphaEnv *context);
static MinApply *visitMinApply(MinApply *node, MinAlphaEnv *context);
static MinLookUp *visitMinLookUp(MinLookUp *node, MinAlphaEnv *context);
static MinExprList *visitMinMakeVec(MinExprList *node, MinAlphaEnv *context);
static MinIff *visitMinIff(MinIff *node, MinAlphaEnv *context);
static MinCond *visitMinCond(MinCond *node, MinAlphaEnv *context);
static MinIntCondCases *visitMinIntCondCases(MinIntCondCases *node,
                                             MinAlphaEnv *context);
static MinCharCondCases *visitMinCharCondCases(MinCharCondCases *node,
                                               MinAlphaEnv *context);
static MinMatch *visitMinMatch(MinMatch *node, MinAlphaEnv *context);
static MinMatchList *visitMinMatchList(MinMatchList *node,
                                       MinAlphaEnv *context);
static MinIntList *visitMinIntList(MinIntList *node, MinAlphaEnv *context);
static MinLetRec *visitMinLetRec(MinLetRec *node, MinAlphaEnv *context);
static MinAmb *visitMinAmb(MinAmb *node, MinAlphaEnv *context);
static MinExp *visitMinExp(MinExp *node, MinAlphaEnv *context);
static MinCondCases *visitMinCondCases(MinCondCases *node,
                                       MinAlphaEnv *context);
static MinNameSpaceArray *visitMinNameSpaceArray(MinNameSpaceArray *node,
                                                 MinAlphaEnv *context);

int alpha_flag = 0;
char *alpha_conversion_function = NULL;

static void addUniqueNameToContext(HashSymbol *name, MinAlphaEnv *context) {
#ifdef SAFETY_CHECKS
    if (context == NULL) {
        cant_happen("NULL context");
    }
#endif
    HashSymbol *newName = genSymDollar(name->name);
    setSymbolMap(context->alphaTable, name, newName);
}

static HashSymbol *getNameFromContext(ParserInfo PI, HashSymbol *name,
                                      MinAlphaEnv *context) {
    struct HashSymbol *mappedName = NULL;
    while (context != NULL) {
        if (getSymbolMap(context->alphaTable, name, &mappedName)) {
            return mappedName;
        }
        context = context->next;
    }
    cant_happen("undefined variable %s [%s +%d]", name->name, PI.fileName,
                PI.lineNo);
}

static void pushNameSpaceEnv(MinAlphaEnv *context) {
    for (MinAlphaEnv *current = context; current != NULL;
         current = current->next) {
        if (current->nameSpaces != NULL) {
            pushMinAlphaEnvArray(current->nameSpaces, context);
            return;
        }
    }
    cant_happen("no nameSpace array found in context");
}

static MinAlphaEnv *findAlphaNameSpaceEnv(MinAlphaEnv *context, Index index) {
    for (MinAlphaEnv *current = context; current != NULL;
         current = current->next) {
        if (current->nameSpaces != NULL) {
            if (index < current->nameSpaces->size) {
                return current->nameSpaces->entries[index];
            } else {
                cant_happen("index %u out of bounds (size %u)", index,
                            current->nameSpaces->size);
            }
        }
    }
    cant_happen("no nameSpace array found in context");
}

static MinLam *visitMinLam(MinLam *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    context = newMinAlphaEnv(context);
    int save = PROTECT(context);

    bool changed = false;
    MinVarList *args = visitMinVarList(node->args, context);
    PROTECT(args);
    changed = changed || (args != node->args);
    MinExp *new_exp = visitMinExp(node->exp, context);
    PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        MinLam *result = newMinLam(CPI(node), args, new_exp);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinVarList *visitMinVarList(MinVarList *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    MinVarList *next = visitMinVarList(node->next, context);
    int save = PROTECT(next);

    addUniqueNameToContext(node->var, context);

    MinVarList *result = newMinVarList(
        CPI(node), getNameFromContext(CPI(node), node->var, context), next);
    UNPROTECT(save);
    return result;
}

static MinPrimApp *visitMinPrimApp(MinPrimApp *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    // Pass through type (type: MinPrimOp, not memory-managed)
    MinExp *new_exp1 = visitMinExp(node->exp1, context);
    int save = PROTECT(new_exp1);
    changed = changed || (new_exp1 != node->exp1);
    MinExp *new_exp2 = visitMinExp(node->exp2, context);
    PROTECT(new_exp2);
    changed = changed || (new_exp2 != node->exp2);

    if (changed) {
        // Create new node with modified fields
        MinPrimApp *result =
            newMinPrimApp(CPI(node), node->type, new_exp1, new_exp2);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinExprList *visitMinSequence(MinExprList *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinExp *new_exp = visitMinExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    MinExprList *new_next = visitMinSequence(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        MinExprList *result = newMinExprList(CPI(node), new_exp, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinExprList *visitMinArgs(MinExprList *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinExp *new_exp = visitMinExp(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    MinExprList *new_next = visitMinArgs(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        MinExprList *result = newMinExprList(CPI(node), new_exp, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinApply *visitMinApply(MinApply *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinExp *new_function = visitMinExp(node->function, context);
    int save = PROTECT(new_function);
    if (new_function == NULL) {
        cant_happen("visitMinApply: function is NULL");
    }
    changed = changed || (new_function != node->function);
    MinExprList *new_args = visitMinArgs(node->args, context);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        MinApply *result = newMinApply(CPI(node), new_function, new_args);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinLookUp *visitMinLookUp(MinLookUp *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinAlphaEnv *nsContext = findAlphaNameSpaceEnv(context, node->nsId);
    MinExp *new_exp = visitMinExp(node->exp, nsContext);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        MinLookUp *result = newMinLookUp(CPI(node), node->nsId, new_exp);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinExprList *visitMinMakeVec(MinExprList *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    return visitMinArgs(node, context);
}

static MinIff *visitMinIff(MinIff *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinExp *new_condition = visitMinExp(node->condition, context);
    int save = PROTECT(new_condition);
    changed = changed || (new_condition != node->condition);
    MinExp *new_consequent = visitMinExp(node->consequent, context);
    PROTECT(new_consequent);
    changed = changed || (new_consequent != node->consequent);
    MinExp *new_alternative = visitMinExp(node->alternative, context);
    PROTECT(new_alternative);
    changed = changed || (new_alternative != node->alternative);

    if (changed) {
        // Create new node with modified fields
        MinIff *result = newMinIff(CPI(node), new_condition, new_consequent,
                                   new_alternative);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinCond *visitMinCond(MinCond *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinExp *new_value = visitMinExp(node->value, context);
    int save = PROTECT(new_value);
    changed = changed || (new_value != node->value);
    MinCondCases *new_cases = visitMinCondCases(node->cases, context);
    PROTECT(new_cases);
    changed = changed || (new_cases != node->cases);

    if (changed) {
        // Create new node with modified fields
        MinCond *result = newMinCond(CPI(node), new_value, new_cases);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinIntCondCases *visitMinIntCondCases(MinIntCondCases *node,
                                             MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    // Pass through constant (type: MaybeBigInt, not memory-managed)
    MinExp *new_body = visitMinExp(node->body, context);
    int save = PROTECT(new_body);
    changed = changed || (new_body != node->body);
    MinIntCondCases *new_next = visitMinIntCondCases(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        MinIntCondCases *result =
            newMinIntCondCases(CPI(node), node->constant, new_body, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinCharCondCases *visitMinCharCondCases(MinCharCondCases *node,
                                               MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    // Pass through constant (type: character, not memory-managed)
    MinExp *new_body = visitMinExp(node->body, context);
    int save = PROTECT(new_body);
    changed = changed || (new_body != node->body);
    MinCharCondCases *new_next = visitMinCharCondCases(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        MinCharCondCases *result =
            newMinCharCondCases(CPI(node), node->constant, new_body, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinMatch *visitMinMatch(MinMatch *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinExp *new_index = visitMinExp(node->index, context);
    int save = PROTECT(new_index);
    changed = changed || (new_index != node->index);
    MinMatchList *new_cases = visitMinMatchList(node->cases, context);
    PROTECT(new_cases);
    changed = changed || (new_cases != node->cases);

    if (changed) {
        // Create new node with modified fields
        MinMatch *result = newMinMatch(CPI(node), new_index, new_cases);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinMatchList *visitMinMatchList(MinMatchList *node,
                                       MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinIntList *new_matches = visitMinIntList(node->matches, context);
    int save = PROTECT(new_matches);
    changed = changed || (new_matches != node->matches);
    MinExp *new_body = visitMinExp(node->body, context);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);
    MinMatchList *new_next = visitMinMatchList(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        MinMatchList *result =
            newMinMatchList(CPI(node), new_matches, new_body, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinIntList *visitMinIntList(MinIntList *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    // Pass through item (type: int, not memory-managed)
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through nsId (type: int, not memory-managed)
    MinIntList *new_next = visitMinIntList(node->next, context);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        MinIntList *result = newMinIntList(CPI(node), node->item, new_next);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinBindings *visitLetRecValues(MinBindings *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;
    MinExp *new_val = visitMinExp(node->val, context);
    int save = PROTECT(new_val);
    if (alpha_conversion_function != NULL &&
        strcmp(alpha_conversion_function, node->var->name) == 0) {
        ppMinExp(new_val);
        eprintf("\n");
    }
    MinBindings *new_next = visitLetRecValues(node->next, context);
    PROTECT(new_next);
    MinBindings *result = newMinBindings(
        CPI(node), getNameFromContext(CPI(node), node->var, context), new_val,
        new_next);
    UNPROTECT(save);
    return result;
}

static void visitLetRecVariables(MinBindings *node, MinAlphaEnv *context) {
    if (node == NULL)
        return;
    visitLetRecVariables(node->next, context);
    addUniqueNameToContext(node->var, context);
}

static MinLetRec *visitMinLetRec(MinLetRec *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    context = newMinAlphaEnv(context);
    int save = PROTECT(context);

    visitLetRecVariables(node->bindings, context);
    MinBindings *new_bindings = visitLetRecValues(node->bindings, context);
    PROTECT(new_bindings);
    MinExp *new_body = visitMinExp(node->body, context);
    PROTECT(new_body);

    // Create new node with modified fields
    MinLetRec *result = newMinLetRec(CPI(node), new_bindings, new_body);
    UNPROTECT(save);
    return result;
}

static MinAmb *visitMinAmb(MinAmb *node, MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinExp *new_left = visitMinExp(node->left, context);
    int save = PROTECT(new_left);
    changed = changed || (new_left != node->left);
    MinExp *new_right = visitMinExp(node->right, context);
    PROTECT(new_right);
    changed = changed || (new_right != node->right);

    if (changed) {
        // Create new node with modified fields
        MinAmb *result = newMinAmb(CPI(node), new_left, new_right);
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static MinExp *visitMinExp(MinExp *node, MinAlphaEnv *context) {
    if (node == NULL) {
        return NULL;
    }

    MinExp *result = node;
    int save = PROTECT(result);

    switch (node->type) {
    case MINEXP_TYPE_AMB: {
        // MinAmb
        MinAmb *variant = getMinExp_Amb(node);
        MinAmb *new_variant = visitMinAmb(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Amb(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_APPLY: {
        // MinApply
        MinApply *variant = getMinExp_Apply(node);
        MinApply *new_variant = visitMinApply(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Apply(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_ARGS: {
        // MinExprList
        MinExprList *variant = getMinExp_Args(node);
        MinExprList *new_variant = visitMinArgs(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Args(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_BACK: {
        // void_ptr
        break;
    }
    case MINEXP_TYPE_BIGINTEGER: {
        // MaybeBigInt
        break;
    }
    case MINEXP_TYPE_BINDINGS: {
        // MinBindings
        cant_happen("MinExp of type BINDINGS should not occur in the wild");
        break;
    }
    case MINEXP_TYPE_CALLCC: {
        // MinExp
        MinExp *variant = getMinExp_CallCC(node);
        MinExp *new_variant = visitMinExp(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_CallCC(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_CHARACTER: {
        // character
        break;
    }
    case MINEXP_TYPE_COND: {
        // MinCond
        MinCond *variant = getMinExp_Cond(node);
        MinCond *new_variant = visitMinCond(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Cond(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_ENV: {
        // void_ptr
        // the `(env)` directive is a way of capturing the current
        // environment from the "body" of a nameSpace.
        // It is a generated instruction and cannot be written
        // directly in source code.
        // It must be the only expression in the nameSpace body and
        // it can only appear there. It is an instruction
        // that the current environment should be
        // associated with the current nameSpace at this point.
        pushNameSpaceEnv(context);
        break;
    }
    case MINEXP_TYPE_ERROR: {
        // void_ptr
        break;
    }
    case MINEXP_TYPE_IFF: {
        // MinIff
        MinIff *variant = getMinExp_Iff(node);
        MinIff *new_variant = visitMinIff(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Iff(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_LAM: {
        // MinLam
        MinLam *variant = getMinExp_Lam(node);
        MinLam *new_variant = visitMinLam(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Lam(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_LETREC: {
        // MinLetRec
        MinLetRec *variant = getMinExp_LetRec(node);
        MinLetRec *new_variant = visitMinLetRec(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_LetRec(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_LOOKUP: {
        // MinLookUp
        MinLookUp *variant = getMinExp_LookUp(node);
        MinLookUp *new_variant = visitMinLookUp(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_LookUp(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_MAKEVEC: {
        // MinMakeVec
        MinExprList *variant = getMinExp_MakeVec(node);
        MinExprList *new_variant = visitMinMakeVec(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_MakeVec(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_MATCH: {
        // MinMatch
        MinMatch *variant = getMinExp_Match(node);
        MinMatch *new_variant = visitMinMatch(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Match(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_NAMESPACES: {
        // MinNameSpaceArray
        MinNameSpaceArray *variant = getMinExp_NameSpaces(node);
        MinNameSpaceArray *new_variant =
            visitMinNameSpaceArray(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_NameSpaces(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_PRIM: {
        // MinPrimApp
        MinPrimApp *variant = getMinExp_Prim(node);
        MinPrimApp *new_variant = visitMinPrimApp(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Prim(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_SEQUENCE: {
        // MinExprList
        MinExprList *variant = getMinExp_Sequence(node);
        MinExprList *new_variant = visitMinSequence(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinExp_Sequence(CPI(node), new_variant);
        }
        break;
    }
    case MINEXP_TYPE_STDINT: {
        // int
        break;
    }
    case MINEXP_TYPE_VAR: {
        // HashSymbol
        result = newMinExp_Var(
            CPI(node),
            getNameFromContext(CPI(node), getMinExp_Var(node), context));
        break;
    }
    default:
        cant_happen("unrecognized MinExp type %s", minExpTypeName(node->type));
    }

    UNPROTECT(save);
    return result;
}

static MinCondCases *visitMinCondCases(MinCondCases *node,
                                       MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    int save = PROTECT(NULL);
    MinCondCases *result = node;

    switch (node->type) {
    case MINCONDCASES_TYPE_INTEGERS: {
        // MinIntCondCases
        MinIntCondCases *variant = getMinCondCases_Integers(node);
        MinIntCondCases *new_variant = visitMinIntCondCases(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinCondCases_Integers(CPI(node), new_variant);
        }
        break;
    }
    case MINCONDCASES_TYPE_CHARACTERS: {
        // MinCharCondCases
        MinCharCondCases *variant = getMinCondCases_Characters(node);
        MinCharCondCases *new_variant = visitMinCharCondCases(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newMinCondCases_Characters(CPI(node), new_variant);
        }
        break;
    }
    default:
        cant_happen("unrecognized MinCondCases type %d", node->type);
    }

    UNPROTECT(save);
    return result;
}

static MinNameSpaceArray *visitMinNameSpaceArray(MinNameSpaceArray *node,
                                                 MinAlphaEnv *context) {
    if (node == NULL)
        return NULL;

    bool changed = false;
    MinNameSpaceArray *result = newMinNameSpaceArray();
    int save = PROTECT(result);
    context->nameSpaces = newMinAlphaEnvArray();

    // Iterate over all elements
    for (Index i = 0; i < node->size; i++) {
        struct MinExp *element = peeknMinNameSpaceArray(node, i);
        struct MinExp *new_element = visitMinExp(element, context);
        PROTECT(new_element);
        changed = changed || (new_element != element);
        pushMinNameSpaceArray(result, new_element);
    }

    if (changed) {
        UNPROTECT(save);
        return result;
    }

    UNPROTECT(save);
    return node;
}

static void addBuiltInsToMinAlphaEnv(MinAlphaEnv *env, BuiltIns *b) {
    for (Index i = 0; i < b->size; i++) {
        // Bind only internal names; external names are provided by wrappers.
        setSymbolMap(env->alphaTable, b->entries[i]->internalName,
                     b->entries[i]->internalName);
    }
}

MinExp *alphaConvertMinExp(MinExp *exp, BuiltIns *builtIns) {
    MinAlphaEnv *env = newMinAlphaEnv(NULL);
    int save = PROTECT(env);
    addBuiltInsToMinAlphaEnv(env, builtIns);
    MinExp *result = visitMinExp(exp, env);
    UNPROTECT(save);
    return result;
}