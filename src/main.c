/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "common.h"
#include "ast.h"
#include "debug_ast.h"
#include "parser.h"
#include "analysis.h"
#include "exp.h"
#include "memory.h"
#include "step.h"
#include "debug.h"
#include "bytecode.h"

#ifdef DEBUG_RUN_TESTS
#if DEBUG_RUN_TESTS == 1

/**
 * these test examples were generated by giving ../tools/makeTree.py each of
 * the scheme files in ../scm then pasting the output here and formatting
 * with `indent --linux`
 */

Exp *makeTestExpAmb()
{
	/* back.scm */
	return
	    newExp(EXP_TYPE_LET,
		   EXP_VAL_LET(newExpLet
			       (newAexpVar("x"),
				newExp(EXP_TYPE_CEXP,
				       EXP_VAL_CEXP(newCexp
						    (CEXP_TYPE_AMB,
						     CEXP_VAL_AMB(newCexpAmb
								  (newExp
								   (EXP_TYPE_AEXP,
								    EXP_VAL_AEXP
								    (newAexp
								     (AEXP_TYPE_FALSE,
								      AEXP_VAL_FALSE
								      ()))),
								   newExp
								   (EXP_TYPE_AEXP,
								    EXP_VAL_AEXP
								    (newAexp
								     (AEXP_TYPE_TRUE,
								      AEXP_VAL_TRUE
								      ())))))))),
				newExp(EXP_TYPE_CEXP,
				       EXP_VAL_CEXP(newCexp
						    (CEXP_TYPE_COND,
						     CEXP_VAL_COND(newCexpCond
								   (newAexp
								    (AEXP_TYPE_VAR,
								     AEXP_VAL_VAR
								     (newAexpVar
								      ("x"))),
								    newExp
								    (EXP_TYPE_AEXP,
								     EXP_VAL_AEXP
								     (newAexp
								      (AEXP_TYPE_INT,
								       AEXP_VAL_INT
								       (5)))),
								    newExp
								    (EXP_TYPE_CEXP,
								     EXP_VAL_CEXP
								     (newCexp
								      (CEXP_TYPE_BACK,
								       CEXP_VAL_BACK
								       ())))))))))));
}

Exp *makeTestExpCallCC()
{
	/* callcc.scm */
	return
	    newExp(EXP_TYPE_LET,
		   EXP_VAL_LET(newExpLet
			       (newAexpVar("a"),
				newExp(EXP_TYPE_CEXP,
				       EXP_VAL_CEXP(newCexp
						    (CEXP_TYPE_CALLCC,
						     CEXP_VAL_CALLCC(newAexp
								     (AEXP_TYPE_LAM,
								      AEXP_VAL_LAM
								      (newAexpLam
								       (newAexpVarList
									(NULL,
									 newAexpVar
									 ("ret")),
									newExp
									(EXP_TYPE_LET,
									 EXP_VAL_LET
									 (newExpLet
									  (newAexpVar
									   ("b"),
									   newExp
									   (EXP_TYPE_CEXP,
									    EXP_VAL_CEXP
									    (newCexp
									     (CEXP_TYPE_APPLY,
									      CEXP_VAL_APPLY
									      (newCexpApply
									       (newAexp
										(AEXP_TYPE_VAR,
										 AEXP_VAL_VAR
										 (newAexpVar
										  ("ret"))),
										newAexpList
										(NULL,
										 newAexp
										 (AEXP_TYPE_INT,
										  AEXP_VAL_INT
										  (5)))))))),
									   newExp
									   (EXP_TYPE_CEXP,
									    EXP_VAL_CEXP
									    (newCexp
									     (CEXP_TYPE_COND,
									      CEXP_VAL_COND
									      (newCexpCond
									       (newAexp
										(AEXP_TYPE_VAR,
										 AEXP_VAL_VAR
										 (newAexpVar
										  ("b"))),
										newExp
										(EXP_TYPE_AEXP,
										 EXP_VAL_AEXP
										 (newAexp
										  (AEXP_TYPE_INT,
										   AEXP_VAL_INT
										   (6)))),
										newExp
										(EXP_TYPE_AEXP,
										 EXP_VAL_AEXP
										 (newAexp
										  (AEXP_TYPE_INT,
										   AEXP_VAL_INT
										   (7))))))))))))))))))),
				newExp(EXP_TYPE_AEXP,
				       EXP_VAL_AEXP(newAexp
						    (AEXP_TYPE_VAR,
						     AEXP_VAL_VAR(newAexpVar
								  ("a"))))))));
}

Exp *makeTestExpCallCC2()
{
	/* callcc2.scm */
	return
	    newExp(EXP_TYPE_LET,
		   EXP_VAL_LET(newExpLet
			       (newAexpVar("x"),
				newExp(EXP_TYPE_CEXP,
				       EXP_VAL_CEXP(newCexp
						    (CEXP_TYPE_CALLCC,
						     CEXP_VAL_CALLCC(newAexp
								     (AEXP_TYPE_LAM,
								      AEXP_VAL_LAM
								      (newAexpLam
								       (newAexpVarList
									(NULL,
									 newAexpVar
									 ("ret")),
									newExp
									(EXP_TYPE_LET,
									 EXP_VAL_LET
									 (newExpLet
									  (newAexpVar
									   ("y"),
									   newExp
									   (EXP_TYPE_CEXP,
									    EXP_VAL_CEXP
									    (newCexp
									     (CEXP_TYPE_CALLCC,
									      CEXP_VAL_CALLCC
									      (newAexp
									       (AEXP_TYPE_VAR,
										AEXP_VAL_VAR
										(newAexpVar
										 ("ret"))))))),
									   newExp
									   (EXP_TYPE_CEXP,
									    EXP_VAL_CEXP
									    (newCexp
									     (CEXP_TYPE_COND,
									      CEXP_VAL_COND
									      (newCexpCond
									       (newAexp
										(AEXP_TYPE_VAR,
										 AEXP_VAL_VAR
										 (newAexpVar
										  ("y"))),
										newExp
										(EXP_TYPE_AEXP,
										 EXP_VAL_AEXP
										 (newAexp
										  (AEXP_TYPE_LAM,
										   AEXP_VAL_LAM
										   (newAexpLam
										    (newAexpVarList
										     (NULL,
										      newAexpVar
										      ("x")),
										     newExp
										     (EXP_TYPE_AEXP,
										      EXP_VAL_AEXP
										      (newAexp
										       (AEXP_TYPE_INT,
											AEXP_VAL_INT
											(6))))))))),
										newExp
										(EXP_TYPE_AEXP,
										 EXP_VAL_AEXP
										 (newAexp
										  (AEXP_TYPE_LAM,
										   AEXP_VAL_LAM
										   (newAexpLam
										    (newAexpVarList
										     (NULL,
										      newAexpVar
										      ("x")),
										     newExp
										     (EXP_TYPE_AEXP,
										      EXP_VAL_AEXP
										      (newAexp
										       (AEXP_TYPE_INT,
											AEXP_VAL_INT
											(7)))))))))))))))))))))))),
				newExp(EXP_TYPE_CEXP,
				       EXP_VAL_CEXP(newCexp
						    (CEXP_TYPE_APPLY,
						     CEXP_VAL_APPLY(newCexpApply
								    (newAexp
								     (AEXP_TYPE_VAR,
								      AEXP_VAL_VAR
								      (newAexpVar
								       ("x"))),
								     newAexpList
								     (NULL,
								      newAexp
								      (AEXP_TYPE_TRUE,
								       AEXP_VAL_TRUE
								       ()))))))))));
}


Exp *makeTestExpFib(int depth)
{
	/* fib.scm */
	return
	    newExp(EXP_TYPE_CEXP,
		   EXP_VAL_CEXP(newCexp
				(CEXP_TYPE_LETREC,
				 CEXP_VAL_LETREC(newCexpLetRec
						 (newLetRecBindings
						  (NULL, newAexpVar("fib"),
						   newAexp(AEXP_TYPE_LAM,
							   AEXP_VAL_LAM
							   (newAexpLam
							    (newAexpVarList
							     (NULL,
							      newAexpVar("n")),
							     newExp
							     (EXP_TYPE_CEXP,
							      EXP_VAL_CEXP
							      (newCexp
							       (CEXP_TYPE_COND,
								CEXP_VAL_COND
								(newCexpCond
								 (newAexp
								  (AEXP_TYPE_PRIM,
								   AEXP_VAL_PRIM
								   (newAexpPrimApp
								    (AEXP_PRIM_LT,
								     newAexp
								     (AEXP_TYPE_VAR,
								      AEXP_VAL_VAR
								      (newAexpVar
								       ("n"))),
								     newAexp
								     (AEXP_TYPE_INT,
								      AEXP_VAL_INT
								      (2))))),
								  newExp
								  (EXP_TYPE_AEXP,
								   EXP_VAL_AEXP
								   (newAexp
								    (AEXP_TYPE_INT,
								     AEXP_VAL_INT
								     (1)))),
								  newExp
								  (EXP_TYPE_LET,
								   EXP_VAL_LET
								   (newExpLet
								    (newAexpVar
								     ("fib1"),
								     newExp
								     (EXP_TYPE_CEXP,
								      EXP_VAL_CEXP
								      (newCexp
								       (CEXP_TYPE_APPLY,
									CEXP_VAL_APPLY
									(newCexpApply
									 (newAexp
									  (AEXP_TYPE_VAR,
									   AEXP_VAL_VAR
									   (newAexpVar
									    ("fib"))),
									  newAexpList
									  (NULL,
									   newAexp
									   (AEXP_TYPE_PRIM,
									    AEXP_VAL_PRIM
									    (newAexpPrimApp
									     (AEXP_PRIM_SUB,
									      newAexp
									      (AEXP_TYPE_VAR,
									       AEXP_VAL_VAR
									       (newAexpVar
										("n"))),
									      newAexp
									      (AEXP_TYPE_INT,
									       AEXP_VAL_INT
									       (1))))))))))),
								     newExp
								     (EXP_TYPE_LET,
								      EXP_VAL_LET
								      (newExpLet
								       (newAexpVar
									("fib2"),
									newExp
									(EXP_TYPE_CEXP,
									 EXP_VAL_CEXP
									 (newCexp
									  (CEXP_TYPE_APPLY,
									   CEXP_VAL_APPLY
									   (newCexpApply
									    (newAexp
									     (AEXP_TYPE_VAR,
									      AEXP_VAL_VAR
									      (newAexpVar
									       ("fib"))),
									     newAexpList
									     (NULL,
									      newAexp
									      (AEXP_TYPE_PRIM,
									       AEXP_VAL_PRIM
									       (newAexpPrimApp
										(AEXP_PRIM_SUB,
										 newAexp
										 (AEXP_TYPE_VAR,
										  AEXP_VAL_VAR
										  (newAexpVar
										   ("n"))),
										 newAexp
										 (AEXP_TYPE_INT,
										  AEXP_VAL_INT
										  (2))))))))))),
									newExp
									(EXP_TYPE_AEXP,
									 EXP_VAL_AEXP
									 (newAexp
									  (AEXP_TYPE_PRIM,
									   AEXP_VAL_PRIM
									   (newAexpPrimApp
									    (AEXP_PRIM_ADD,
									     newAexp
									     (AEXP_TYPE_VAR,
									      AEXP_VAL_VAR
									      (newAexpVar
									       ("fib1"))),
									     newAexp
									     (AEXP_TYPE_VAR,
									      AEXP_VAL_VAR
									      (newAexpVar
									       ("fib2"))))))))))))))))))))))),
						  newExp(EXP_TYPE_CEXP,
							 EXP_VAL_CEXP(newCexp
								      (CEXP_TYPE_APPLY,
								       CEXP_VAL_APPLY
								       (newCexpApply
									(newAexp
									 (AEXP_TYPE_VAR,
									  AEXP_VAL_VAR
									  (newAexpVar
									   ("fib"))),
									 newAexpList
									 (NULL,
									  newAexp
									  (AEXP_TYPE_INT,
									   AEXP_VAL_INT
									   (depth)))))))))))));
}

Exp *makeTestExpCons()
{
	/* cons.scm */
	return newExp(EXP_TYPE_LET,
		      EXP_VAL_LET(newExpLet
				  (newAexpVar("a"),
				   newExp(EXP_TYPE_AEXP,
					  EXP_VAL_AEXP(newAexp
						       (AEXP_TYPE_PRIM,
							AEXP_VAL_PRIM
							(newAexpPrimApp
							 (AEXP_PRIM_CONS,
							  newAexp(AEXP_TYPE_INT,
								  AEXP_VAL_INT
								  (1)),
							  newAexp
							  (AEXP_TYPE_PRIM,
							   AEXP_VAL_PRIM
							   (newAexpPrimApp
							    (AEXP_PRIM_CONS,
							     newAexp
							     (AEXP_TYPE_INT,
							      AEXP_VAL_INT(2)),
							     newAexp
							     (AEXP_TYPE_PRIM,
							      AEXP_VAL_PRIM
							      (newAexpPrimApp
							       (AEXP_PRIM_CONS,
								newAexp
								(AEXP_TYPE_INT,
								 AEXP_VAL_INT
								 (3)),
								newAexp
								(AEXP_TYPE_VOID,
								 AEXP_VAL_VOID
								 ())))))))))))),
				   newExp(EXP_TYPE_AEXP,
					  EXP_VAL_AEXP(newAexp
						       (AEXP_TYPE_VAR,
							AEXP_VAL_VAR(newAexpVar
								     ("a"))))))));
}

Exp *makeTestExpClosure()
{
	/* closure.scm */
	return
	    newExp(EXP_TYPE_LET,
		   EXP_VAL_LET(newExpLet
			       (newAexpVar("test"),
				newExp(EXP_TYPE_AEXP,
				       EXP_VAL_AEXP(newAexp
						    (AEXP_TYPE_LAM,
						     AEXP_VAL_LAM(newAexpLam
								  (newAexpVarList
								   (NULL,
								    newAexpVar
								    ("x")),
								   newExp
								   (EXP_TYPE_AEXP,
								    EXP_VAL_AEXP
								    (newAexp
								     (AEXP_TYPE_LAM,
								      AEXP_VAL_LAM
								      (newAexpLam
								       (newAexpVarList
									(NULL,
									 newAexpVar
									 ("y")),
									newExp
									(EXP_TYPE_AEXP,
									 EXP_VAL_AEXP
									 (newAexp
									  (AEXP_TYPE_PRIM,
									   AEXP_VAL_PRIM
									   (newAexpPrimApp
									    (AEXP_PRIM_ADD,
									     newAexp
									     (AEXP_TYPE_VAR,
									      AEXP_VAL_VAR
									      (newAexpVar
									       ("x"))),
									     newAexp
									     (AEXP_TYPE_VAR,
									      AEXP_VAL_VAR
									      (newAexpVar
									       ("y")))))))))))))))))),
				newExp(EXP_TYPE_LET,
				       EXP_VAL_LET(newExpLet
						   (newAexpVar("add2"),
						    newExp(EXP_TYPE_CEXP,
							   EXP_VAL_CEXP(newCexp
									(CEXP_TYPE_APPLY,
									 CEXP_VAL_APPLY
									 (newCexpApply
									  (newAexp
									   (AEXP_TYPE_VAR,
									    AEXP_VAL_VAR
									    (newAexpVar
									     ("test"))),
									   newAexpList
									   (NULL,
									    newAexp
									    (AEXP_TYPE_INT,
									     AEXP_VAL_INT
									     (2)))))))),
						    newExp(EXP_TYPE_CEXP,
							   EXP_VAL_CEXP(newCexp
									(CEXP_TYPE_APPLY,
									 CEXP_VAL_APPLY
									 (newCexpApply
									  (newAexp
									   (AEXP_TYPE_VAR,
									    AEXP_VAL_VAR
									    (newAexpVar
									     ("add2"))),
									   newAexpList
									   (NULL,
									    newAexp
									    (AEXP_TYPE_INT,
									     AEXP_VAL_INT
									     (3))))))))))))));
}

#ifdef DEBUG_STEP
#define DUMP_BYTECODE(bc) dumpByteCode(bc)
#else
#define DUMP_BYTECODE(bc) do {} while(0)
#endif

#define RUN_EXP(build) \
do { \
    disableGC(); \
    exp = build; \
    save = PROTECT(exp); \
    enableGC(); \
    analizeExp(exp, NULL, 0); \
    printExp(exp); \
    printf("\n"); \
    initByteCodeArray(&byteCodes); \
    writeExp(exp, &byteCodes); \
    writeEnd(&byteCodes); \
    DUMP_BYTECODE(&byteCodes); \
    UNPROTECT(save); \
    run(byteCodes); \
} while(0)

int main(int argc, char *argv[]) {

#ifdef TEST_STACK
    testStack();
    exit(0);
#endif
    ByteCodeArray byteCodes;
    int save;
    Exp *exp;

    int depth = 3;
    if (argc == 2) depth = atoi(argv[1]);

    // RUN_EXP(makeTestExpFib(depth));

    RUN_EXP(makeTestExpCons());

    // RUN_EXP(makeTestExpAmb());

    // RUN_EXP(makeTestExpCallCC());

    // RUN_EXP(makeTestExpCallCC2());

    // RUN_EXP(makeTestExpClosure());
}

#else /* testing parser */

// extern int yydebug;

extern AstNest *result;

int main(int argc, char *argv[]) {
    disableGC();
    // yydebug = 1;
    yyparse();
    printAstNest(result);
    printf("\n");
}

#endif

#else

int main(int argc, char *argv[]) {
}

#endif
