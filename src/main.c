/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
#include <errno.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "anf.h"
#include "anf_normalize.h"
#include "anf_pp.h"
#include "annotate.h"
#include "arithmetic_next.h"
#include "ast.h"
#include "ast_debug.h"
#include "ast_ns.h"
#include "bigint.h"
#include "builtins_helper.h"
#include "bytecode.h"
#include "common.h"
#include "debug.h"
#include "hash.h"
#include "init.h"
#include "inline.h"
#include "lambda_conversion.h"
#include "lambda_debug.h"
#include "lambda_desugar.h"
#include "lambda_pp.h"
#include "lambda_simplification.h"
#include "memory.h"
#include "minlam_alphaconvert.h"
#include "minlam_beta.h"
#include "minlam_curry.h"
#include "minlam_eta.h"
#include "minlam_fold.h"
#include "minlam_pp.h"
#include "pratt.h"
#include "pratt_parser.h"
#include "pratt_scanner.h"
#include "step.h"
#include "tc_analyze.h"
#include "tc_debug.h"
#include "tpmc_mermaid.h"
#include "utils.h"
#include "wrapper_synthesis.h"
#ifdef UNIT_TESTS
#include "tests.h"
#endif

// #define TEST_CPS

#ifdef TEST_CPS
#include "minlam_cps.h"
#endif

// temporary test
LamExp *anfNormalize2(LamExp *exp);
#ifdef DEBUG_STRESS_GC
extern int forceGcFlag;
#endif

int report_flag = 0;
static int help_flag = 0;
static int anf_flag = 0;
static int ast_flag = 0;
static int lambda_flag = 0;
static int inline_flag = 0;
static int parse_only_flag = 0;
#ifdef UNIT_TESTS
static int test_flag = 0;
#endif
extern bool assertions_failed;
extern int assertions_accumulate;
static char *binary_output_file = NULL;
static char *binary_input_file = NULL;
static char *snippet = NULL;

extern StringArray *include_paths;

static int beta_flag = 0;

/**
 * Report the build mode, i.e. the value of the BUILD_MODE macro when compiled.
 *
 * @param prog the program name
 */
static void report_build_mode(char *prog) {
    printf("%s - ", prog);
#ifdef BUILD_MODE
    switch (BUILD_MODE) {
    case 0:
        printf("debug build\n");
        break;
    case 1:
        printf("test build\n");
        break;
    case 2:
        printf("production build\n");
        break;
    case 3:
        printf("coverage build\n");
        break;
    default:
        printf("unrecognised build\n");
        break;
    }
#else
    printf("unspecified build\n");
#endif
}

/**
 * Display command-line usage information and exit.
 *
 * @param prog the program name
 * @param status the exit status
 */
static void usage(char *prog, int status) {
    report_build_mode(prog);
    printf("usage: %s <options> [---] [<filename> [<arguments> ...]]\n", prog);
    printf(
        "options:\n%s",
        "    -h\n"
        "    --help                   This help.\n"
        "    --assertions-accumulate  Don't exit on the first assertion "
        "failure.\n"
        "    -B<file>\n"
        "    --binary-in=<file>       Read byte code from file.\n"
        "    -O<file>\n"
        "    --binary-out=<file>      Write byte code to file.\n"
        "    -a\n"
        "    --dump-alpha             Display the intermediate code after "
        "alpha-conversion.\n"
        "    -a<function>\n"
        "    --dump-alpha=<function>  Display the intermediate code after "
        "alpha-conversion.\n"
        "    -b<function>\n"
        "    --dump-beta=<function>   Display the intermediate code after "
        "beta-conversion.\n"
        "    --dump-anf               Display the generated ANF.\n"
        "    --dump-ast               Display the parsed AST before lambda "
        "conversion.\n"
        "    --dump-bytecode          Dump the generated bytecode.\n"
        "    -d\n"
        "    --dump-desugared         Display the intermediate code after "
        "desugaring.\n"
        "    -d<function>\n"
        "    --dump-desugared=<function> Display the intermediate code after "
        "desugaring.\n"
        "    --dump-inline            Display the intermediate code after "
        "inlining.\n"
        "    -l\n"
        "    --dump-lambda            Display all the intermediate code.\n"
        "    -l<function>\n"
        "    --dump-lambda=<function> Display the intermediate code for the "
        "function.\n"
        "    -m <function>\n"
        "    --dump-tpmc=<function>   Dump a mermaid graph of the TPMC "
        "state table.\n"
        "    -e<snippet>\n"
        "    --exec=<snippet>         Execute the snippet of code directly\n"
        "    -i<dir>\n"
        "    --include=<dir>          Add dir to the list of directories to "
        "be searched.\n"
        "    --parse-only             Stop after parsing to enable "
        "parser-only profiling.\n"
        "    --report                 Report statistics.\n"
#ifdef DEBUG_STRESS_GC
        "    --stress-gc              Stress the garbage collector.\n"
#endif
#ifdef UNIT_TESTS
        "    --test                   Run unit tests.\n"
#endif
    );
    exit(status);
}

/**
 * Process command-line arguments.
 *
 * @param argc the argument count
 * @param argv the argument values
 * @return the index of the first non-option argument
 */
static int processArgs(int argc, char *argv[]) {
    int c;

    while (1) {
        static struct option long_options[] = {
#ifdef UNIT_TESTS
            {"test", no_argument, &test_flag, 1},
#endif
            {"report", no_argument, &report_flag, 1},
#ifdef DEBUG_STRESS_GC
            {"stress-gc", no_argument, &forceGcFlag, 1},
#endif
            {"parse-only", no_argument, &parse_only_flag, 1},
            {"dump-anf", no_argument, &anf_flag, 1},
            {"dump-ast", no_argument, &ast_flag, 1},
            {"dump-bytecode", no_argument, &dump_bytecode_flag, 1},
            {"exec", required_argument, 0, 'e'},
            {"help", no_argument, 0, 'h'},
            {"dump-inline", no_argument, &inline_flag, 1},
            {"assertions-accumulate", no_argument, &assertions_accumulate, 1},
            {"dump-tpmc", required_argument, 0, 'm'},
            {"dump-lambda", optional_argument, 0, 'l'},
            {"dump-desugared", optional_argument, 0, 'd'},
            {"dump-alpha", optional_argument, 0, 'a'},
            {"dump-beta", optional_argument, 0, 'b'},
            {"include", required_argument, 0, 'i'},
            {"binary-out", required_argument, 0, 'O'},
            {"binary-in", required_argument, 0, 'B'},
            {0, 0, 0, 0}};
        int option_index = 0;

        c = getopt_long(argc, argv, "l::hm:e:i:O:B:b::d::a::", long_options,
                        &option_index);

        if (c == -1)
            break;

        if (c == 'm') {
            tpmc_mermaid_function = optarg;
        }

        if (c == 'l') {
            if (optarg) {
                lambda_conversion_function = optarg;
            } else {
                lambda_flag = 1;
            }
        }

        if (c == 'a') {
            if (optarg) {
                alpha_conversion_function = optarg;
            } else {
                alpha_flag = 1;
            }
        }

        if (c == 'b') {
            if (optarg) {
                beta_conversion_function = optarg;
            } else {
                beta_flag = 1;
            }
        }

        if (c == 'd') {
            if (optarg) {
                desugar_conversion_function = optarg;
            } else {
                desugar_flag = 1;
            }
        }

        if (c == 'O') {
            binary_output_file = optarg;
        }

        if (c == 'B') {
            binary_input_file = optarg;
        }

        if (c == 'e') {
            snippet = optarg;
        }

        if (c == 'i') {
            pushStringArray(include_paths, strdup(optarg));
        }

        if (c == '?' || c == 'h') {
            help_flag = 1;
        }
    }

    if (help_flag) {
        usage(argv[0], 0);
    }

    if (binary_input_file != NULL && binary_output_file != NULL) {
        printf("incompatible --binary-out and --binary-in arguments\n");
        usage(argv[0], 1);
    }

    if (optind >= argc && !binary_input_file && !snippet
#ifdef UNIT_TESTS
        && !test_flag
#endif
    ) {
        eprintf("missing argument\n");
        usage(argv[0], 1);
    }

    return optind;
}

/**
 * Parse a file from the command line into an AST program.
 *
 * @param file the fileName
 * @return the AST program
 */
static AstProg *parseFile(char *file) {
    AstProg *prog = prattParseFile(file);
    int save = PROTECT(prog);
    if (hadErrors()) {
        exit(1);
    }
    UNPROTECT(save);
    return prog;
}

/**
 * Parse a string into an AST program.
 *
 * @param string the string to parse
 * @return the AST program
 */
static AstProg *parseString(char *string) {
    AstProg *prog = prattParseString(string, "command-line");
    int save = PROTECT(prog);
    if (hadErrors()) {
        exit(1);
    }
    UNPROTECT(save);
    return prog;
}

/**
 * Convert an AST program into a lambda expression.
 *
 * @param prog the AST program
 * @return the lambda expression
 */
static LamExp *convertProg(AstProg *prog) {
    LamExp *exp = lamConvertProg(prog);
    int save = PROTECT(exp);
    if (hadErrors()) {
        exit(1);
    }
    exp = lamPerformSimplifications(exp);
    REPLACE_PROTECT(save, exp);
    if (lambda_flag) {
        ppLamExp(exp);
        eprintf("\n");
    }
    UNPROTECT(save);
    return exp;
}

static LamExp *inlineExp(LamExp *exp) __attribute__((unused));

/**
 * Inline type constructors in a lambda expression.
 *
 * @param exp the lambda expression
 * @return the inlined lambda expression
 */
static LamExp *inlineExp(LamExp *exp) {
    exp = inlineLamExp(exp);
    int save = PROTECT(exp);
    if (inline_flag) {
        ppLamExp(exp);
        eprintf("\n");
    }
    UNPROTECT(save);
    return exp;
}

/**
 * Type check a lambda expression.
 *
 * @param exp the lambda expression
 * @param builtIns the built-in functions
 */
static void typeCheck(LamExp *exp, BuiltIns *builtIns) {
    TcEnv *env = tc_init(builtIns);
    int save = PROTECT(env);
    TcType *res __attribute__((unused)) = tc_analyze(exp, env);
    if (hadErrors()) {
        exit(1);
    }
#ifdef DEBUG_TC
    ppTcType(res);
    eprintf("\n");
#endif
    UNPROTECT(save);
}

/**
 * Annotate an ANF expression, adding location information for symbols
 *
 * @param anfExp the ANF expression
 * @param builtIns the built-in functions
 */
static void annotate(AnfExp *anfExp, BuiltIns *builtIns) {
    annotateAnf(anfExp, builtIns);
#ifdef DEBUG_ANF
    ppExp(anfExp);
    eprintf("\n");
#endif
}

/**
 * Generate byte codes from an ANF expression.
 *
 * @param anfExp the ANF expression
 * @param L the location array
 * @return the generated byte codes
 */
static ByteCodeArray generateByteCodes(AnfExp *anfExp, LocationArray *L) {
    ByteCodeArray byteCodes;
    initByteCodeArray(&byteCodes, 8);
    writeAnfExp(anfExp, &byteCodes, L);
    writeEnd(&byteCodes);
    return byteCodes;
}

/**
 * Report statistics on the execution.
 *
 * @param prog the program name
 * @param begin the begin time
 * @param compiled the compile time
 * @param end the end time
 */
static void report(char *prog, clock_t begin, clock_t compiled, clock_t end) {
    if (report_flag) {
        printf("\n");
        report_build_mode(prog);
        double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
        printf("elapsed time: %.4lf\n", time_spent);
        double compile_time = (double)(compiled - begin) / CLOCKS_PER_SEC;
        printf("compile time: %.4lf\n", compile_time);
        double run_time = (double)(end - compiled) / CLOCKS_PER_SEC;
        printf("run time: %.4lf\n", run_time);
        reportMemory();
        reportSteps();
    }
}

/**
 * Main entry point for the program.
 *
 * @param argc the argument count
 * @param argv the argument values
 * @return the exit status
 */
int main(int argc, char *argv[]) {
    clock_t begin = clock();
    initAll();
    include_paths = newStringArray();
    int save = PROTECT(include_paths);
    int nextargc = processArgs(argc, argv);
    BuiltIns *builtIns = registerBuiltIns(
        argc, binary_input_file ? nextargc : nextargc + 1, argv);
    PROTECT(builtIns);

#ifdef UNIT_TESTS
    if (test_flag) {
        if (run_unit_tests()) {
            exit(0);
        } else {
            exit(1);
        }
    } else
#endif
        if (binary_input_file) {
        ByteCodeArray byteCodes;
        initByteCodeArray(&byteCodes, 8);
        switch (readBinaryInputFile(&byteCodes, binary_input_file)) {
        case BYTECODES_BADFILE:
            fprintf(stderr, "%s: %s\n", binary_input_file, strerror(errno));
            exit(1);
        case BYTECODES_BADHEADER:
            fprintf(stderr, "%s: invalid header\n", binary_input_file);
            exit(1);
        case BYTECODES_BADVERSION:
            fprintf(stderr, "%s: invalid version\n", binary_input_file);
            exit(1);
        case BYTECODES_OK:
            break;
        default:
            cant_happen("unrecognised status from bytecode reader");
        }
        clock_t compiled = clock();
        run(byteCodes, NULL, builtIns);
        UNPROTECT(save);
        clock_t end = clock();
        report(argv[0], begin, compiled, end);
    } else {
        // Generate wrappers for builtins before parsing
        // they will be insterted into the preamble on
        // encountering the __builtins__ directive
        generateBuiltinWrappers(builtIns);
        AstProg *prog = NULL;
        if (snippet) {
            prog = parseString(snippet);
        } else {
            prog = parseFile(argv[nextargc++]);
        }
        int save2 = PROTECT(prog);

        if (parse_only_flag) {
            // Stop after parsing to enable parser-only profiling
            exit(0);
        }

        prog = nsAstProg(prog);
        REPLACE_PROTECT(save2, prog);

        if (ast_flag) {
            SCharArray *dest = newSCharArray();
            PROTECT(dest);
            ppAstProg(dest, prog);
            printf("%s\n", dest->entries);
        }

        // forceGcFlag = true;
        LamExp *exp = convertProg(prog);
        REPLACE_PROTECT(save2, exp);

        typeCheck(exp, builtIns);

        exp = inlineExp(exp);
        REPLACE_PROTECT(save2, exp);

        MinExp *minExp = desugarLamExp(exp);
        REPLACE_PROTECT(save2, minExp);

        if (desugar_flag) {
            ppMinExp(minExp);
            eprintf("\n");
            exit(0);
        }

#if 0
        // forceGcFlag = true;
        LamExp *anfLam = anfNormalize2(exp);
        REPLACE_PROTECT(save2, anfLam);
        ppLamExp(anfLam);
        eprintf("\n");
        exit(0);
#endif
        minExp = alphaConvertMinExp(minExp, builtIns);
        REPLACE_PROTECT(save2, minExp);
#ifdef TEST_CPS
        LamExp *halt = newLamExp_Var(CPI(exp), newSymbol("halt"));
        PROTECT(halt);
        forceGcFlag = true;
        exp = cpsTc(exp, halt);
        REPLACE_PROTECT(save2, exp);
        ppLamExp(exp);
        eprintf("\n");
        exit(0);
#endif

        if (alpha_flag) {
            ppMinExp(minExp);
            eprintf("\n");
            exit(0);
        }

        minExp = curryMinExp(minExp);
        REPLACE_PROTECT(save2, minExp);

        // if we move currying below this point we need to
        // update the following steps to propagate the isBuiltin flag
        minExp = betaMinExp(minExp);
        REPLACE_PROTECT(save2, minExp);

        minExp = etaMinExp(minExp);
        REPLACE_PROTECT(save2, minExp);
        minExp = betaMinExp(minExp); // second pass.
        REPLACE_PROTECT(save2, minExp);

        minExp = foldMinExp(minExp);
        REPLACE_PROTECT(save2, minExp);

        if (beta_flag) {
            ppMinExp(minExp);
            eprintf("\n");
            exit(0);
        }

        AnfExp *anfExp = anfNormalize(minExp);
        REPLACE_PROTECT(save2, anfExp);

        if (anf_flag) {
            ppAnfExp(anfExp);
            eprintf("\n");
        }

        annotate(anfExp, builtIns);

        LocationArray *L = newLocationArray();
        PROTECT(L);
        ByteCodeArray byteCodes = generateByteCodes(anfExp, L);
        if (binary_output_file != NULL) {
            if (!writeBinaryOutputFile(&byteCodes, binary_output_file)) {
                fprintf(stderr, "%s: %s\n", binary_output_file,
                        strerror(errno));
                exit(1);
            }
            exit(0);
        }

        UNPROTECT(save2);
        PROTECT(L);
        clock_t compiled = clock();
        run(byteCodes, L, builtIns);
        UNPROTECT(save);
        clock_t end = clock();
        report(argv[0], begin, compiled, end);
    }
    return assertions_failed ? 1 : 0;
}
