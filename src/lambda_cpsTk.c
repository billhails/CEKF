/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2025  Bill Hails
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 * Generated from src/lambda.yaml by tools/generate.py
 */

#include "lambda.h"
#include "memory.h"
#include "symbol.h"
#include "common.h"

#include "lambda_cps.h"
#include "lambda_functions.h"
#include "cps_kont.h"
#include "cps_kont_impl.h"

#ifdef DEBUG_LAMBDA_CPSTK
#  include "debugging_on.h"
#else
#  include "debugging_off.h"
#endif

// Forward declarations
static LamExp *cpsTkLamPrimApp(LamPrimApp *node, CpsKont *k);
static LamExp *cpsTkLamSequence(LamSequence *node, CpsKont *k);
static LamExp *cpsTkMakeTuple(LamArgs *node, CpsKont *k);
static LamExp *cpsTkLamApply(LamExp *node, CpsKont *k);
static LamExp *cpsTkLamLookUp(LamLookUp *node, CpsKont *k);
static LamExp *cpsTkTag(LamExp *node, CpsKont *k);
static LamExp *cpsTkLamConstruct(LamConstruct *node, CpsKont *k);
static LamExp *cpsTkLamDeconstruct(LamDeconstruct *node, CpsKont *k);
static LamExp *cpsTkLamTupleIndex(LamTupleIndex *node, CpsKont *k);
static LamExp *cpsTkMakeVec(LamMakeVec *node, CpsKont *k);
static LamExp *cpsTkLamIff(LamIff *node, CpsKont *k);
static LamExp *cpsTkLamCond(LamCond *node, CpsKont *k);
static LamExp *cpsTkLamMatch(LamMatch *node, CpsKont *k);
static LamExp *cpsTkLamLet(LamLet *node, CpsKont *k);
static LamExp *cpsTkLamLetStar(LamLetStar *node, CpsKont *k);
static LamExp *cpsTkLamLetRec(LamLetRec *node, CpsKont *k);
static LamExp *cpsTkLamAmb(LamAmb *node, CpsKont *k);
static LamExp *cpsTkLamPrint(LamPrint *node, CpsKont *k);
static LamExp *cpsTkLamTypeOf(LamTypeOf *node, CpsKont *k);
static LamExp *cpsTkLamTypeDefs(LamTypeDefs *node, CpsKont *k);
static LamExp *cpsTkLamExp(LamExp *node, CpsKont *k);
static LamExp *cpsTkLamNameSpaceArray(LamNameSpaceArray *node, CpsKont *k);

// utilities
static LamExp *INVOKE(CpsKont *k, LamExp *arg) {
    return k->wrapper(arg, k->env);
}

bool isAexpr(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_VAR:
        case LAMEXP_TYPE_BACK:
        case LAMEXP_TYPE_CHARACTER:
        case LAMEXP_TYPE_CONSTANT:
        case LAMEXP_TYPE_CONSTRUCTOR:
        case LAMEXP_TYPE_ENV:
        case LAMEXP_TYPE_ERROR:
        case LAMEXP_TYPE_LAM:
        case LAMEXP_TYPE_STDINT:
        case LAMEXP_TYPE_BIGINTEGER:
            return true;
        default:
            return false;
    }
}

LamExp *makeVar(ParserInfo PI, char *prefix) {
    return newLamExp_Var(PI, genSymDollar(prefix));
}

LamArgs *appendLamArg(LamArgs *args, LamExp *exp) {
    if (args == NULL) return newLamArgs(CPI(exp), exp, NULL);
    LamArgs *next = appendLamArg(args->next, exp);
    int save = PROTECT(next);
    LamArgs *this = newLamArgs(CPI(args), args->exp, next);
    UNPROTECT(save);
    return this;
}

LamVarList *appendLamVar(ParserInfo PI, LamVarList *args, HashSymbol *var) {
    if (args == NULL) return newLamVarList(PI, var, NULL);
    LamVarList *next = appendLamVar(PI, args->next, var);
    int save = PROTECT(next);
    LamVarList *this = newLamVarList(CPI(args), args->var, next);
    UNPROTECT(save);
    return this;
}

/*
    fn Ts_k {
        ([], k) { k([]) }
        (h @ t, k) {
            T_k(h, fn (hd) {
                Ts_k(t, fn (tl) {
                    k(hd @ tl)
                })
            })
        }
    }
 */
LamExp *cpsTs_k(LamExp *exp, CpsKont *k) {
    ENTER(cpsTs_k);
    if (getLamExp_Args(exp) == NULL) {
        return INVOKE(k, exp);
    }
    CpsKont *k1 = makeKont_TkS1(getLamExp_Args(exp)->next, k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(getLamExp_Args(exp)->exp, k1); // T_k(h, fn (hd) { ...k...t... })
    LEAVE(cpsTs_k);
    UNPROTECT(save);
    return result;
}

LamExp *TkS1Kont(LamExp *hd, TkS1KontEnv *env) {
    ENTER(TkS1Kont);
    CpsKont *k2 = makeKont_TkS2(env->k, hd);
    int save = PROTECT(k2);
    LamExp *args = newLamExp_Args(CPI(hd), env->t);
    PROTECT(args);
    LamExp *result = cpsTs_k(args, k2); // Ts_k(t, fn (tl) { ...k...hd... })
    LEAVE(TkS1Kont);
    UNPROTECT(save);
    return result;
}

LamExp *TkS2Kont(LamExp *tl, TkS2KontEnv *env) {
    ENTER(TkS2Kont);
    LamExp *args = makeLamExp_Args(CPI(env->hd), env->hd, getLamExp_Args(tl));
    int save = PROTECT(args);
    LamExp *result = INVOKE(env->k, args);
    UNPROTECT(save);
    LEAVE(TkS2Kont);
    return result;
}

/*
    fn kToC(k) {
        let rv = gensym("$rv");
        in E.lambda([rv], k(rv))
    }
*/
static LamExp *kToC(ParserInfo PI, CpsKont *k) {
    LamExp *rv = makeVar(PI, "rv");
    int save = PROTECT(rv);
    LamExp *body = INVOKE(k, rv);
    PROTECT(body);
    LamVarList *args = newLamVarList(PI, getLamExp_Var(rv), NULL);
    PROTECT(args);
    LamExp *cont = makeLamExp_Lam(PI, args, body);
    UNPROTECT(save);
    return cont;
}

// Visitor implementations

/*
    (E.tag(expr)) {
        T_k(expr, fn (sexpr) {
            k(E.tag(sexpr))
        })
    }
*/
static LamExp *cpsTkTag(LamExp *node, CpsKont *k) {
    ENTER(cpsTkTag);
    CpsKont *k1 = makeKont_TkTag(k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(node, k1);
    UNPROTECT(save);
    LEAVE(cpsTkTag);
    return result;
}

LamExp *TkTagKont(LamExp *sexpr, TkTagKontEnv *env) {
    ENTER(TkTagKont);
    LamExp *tagged = newLamExp_Tag(CPI(sexpr), sexpr);
    int save = PROTECT(tagged);
    LamExp *result = INVOKE(env->k, tagged);
    UNPROTECT(save);
    LEAVE(TkTagKont);
    return result;
}

/*
    (E.primapp(p, e1, e2)) {
        T_k(e1, fn (s1) {
            T_k(e2, fn (s2) {
                k(E.primapp(p, s1, s2))
            })
        })
    }
*/
static LamExp *cpsTkLamPrimApp(LamPrimApp *node, CpsKont *k) {
    ENTER(cpsTkLamPrimApp);
    CpsKont *k1 = makeKont_TkPrimApp1(k, node->exp2, node->type);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(node->exp1, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamPrimApp);
    return result;
}

LamExp *TkPrimApp1Kont(LamExp *s1, TkPrimApp1KontEnv *env) {
    ENTER(TkPrimApp1Kont);
    CpsKont *k = makeKont_TkPrimApp2(env->k, s1, env->p);
    int save = PROTECT(k);
    LamExp *result = cpsTk(env->e2, k);
    UNPROTECT(save);
    LEAVE(TkPrimApp1Kont);
    return result;
}

LamExp *TkPrimApp2Kont(LamExp *s2, TkPrimApp2KontEnv *env) {
    ENTER(TkPrimApp2Kont);
    LamExp *primapp = makeLamExp_Prim(CPI(env->s1), env->p, env->s1, s2);
    int save = PROTECT(primapp);
    LamExp *result = INVOKE(env->k, primapp);
    UNPROTECT(save);
    LEAVE(TkPrimApp2Kont);
    return result;
}

/*
    (E.sequence([expr])) { T_k(expr, k) }
    (E.sequence(expr @ exprs)) {
        T_k(expr, fn (ignored) {
            T_k(E.sequence(exprs), k)
        })
    }
*/
static LamExp *cpsTkLamSequence(LamSequence *node, CpsKont *k) {
    ENTER(cpsTkLamSequence);
#ifdef SAFETY_CHECKS
    if (node == NULL) {
        cant_happen("NULL node in cpsTkLamSequence");
    }
#endif
    LamExp *result = NULL;
    int save = PROTECT(NULL);
    if(node->next == NULL) {
        result = cpsTk(node->exp, k);
    } else {
        CpsKont *k1 = makeKont_TkSequence(k, node->next);
        PROTECT(k1);
        result = cpsTk(node->exp, k1);
    }
    UNPROTECT(save);
    LEAVE(cpsTkLamSequence);
    return result;
}

LamExp *TkSequenceKont(LamExp *ignored, TkSequenceKontEnv *env) {
    ENTER(TkSequenceKont);
    LamExp *sequence = newLamExp_Sequence(CPI(ignored), env->exprs);
    int save = PROTECT(sequence);
    LamExp *result = cpsTk(sequence, env->k);
    UNPROTECT(save);
    LEAVE(TkSequenceKont);
    return result;
}

/*
    (E.make_tuple(args)) {
        Ts_k(args, fn (sargs) {
            k(E.make_tuple(sargs))
        })
    }
*/
static LamExp *cpsTkMakeTuple(LamArgs *node, CpsKont *k) {
    ENTER(cpsTkMakeTuple);
    CpsKont *k1 = makeKont_TkMakeTuple(k);
    int save = PROTECT(k1);
    LamExp *exp = newLamExp_Args(CPI(node), node);
    PROTECT(exp);
    LamExp *result = cpsTs_k(exp, k1);
    UNPROTECT(save);
    LEAVE(cpsTkMakeTuple);
    return result;
}

LamExp *TkMakeTupleKont(LamExp *sargs, TkMakeTupleKontEnv *env) {
    ENTER(TkMakeTupleKont);
    LamExp *make_tuple = newLamExp_MakeTuple(CPI(sargs), getLamExp_Args(sargs));
    int save = PROTECT(make_tuple);
    LamExp *result = INVOKE(env->k, make_tuple);
    UNPROTECT(save);
    LEAVE(TkMakeTupleKont);
    return result;
}

/*
    (E.apply(_, _)) {
        let
            c = kToC(k)
        in
            T_c(e, c)
    }
*/
static LamExp *cpsTkLamApply(LamExp *node, CpsKont *k) {
    ENTER(cpsTkLamApply);
    if (node == NULL) {
        LEAVE(cpsTkLamApply);
        return NULL;
    }

    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    LamExp *result = cpsTc(node, c);
    UNPROTECT(save);
    LEAVE(cpsTkLamApply);
    return result;
}

/*
    (E.lookUp(name, index, expr)) {
        E.lookUp(name, index, T_k(expr, k))
    }
*/
static LamExp *cpsTkLamLookUp(LamLookUp *node, CpsKont *k) {
    ENTER(cpsTkLamLookUp);
    LamExp *expr = cpsTk(node->exp, k);
    int save = PROTECT(expr);
    LamExp *result = makeLamExp_LookUp(CPI(node), node->nsId, node->nsSymbol, expr);
    UNPROTECT(save);
    LEAVE(cpsTkLamLookUp);
    return result;
}

/*
    (E.construct(name, args)) {
        Ts_k(args, fn (sargs) {
            k(E.construct(name, sargs))
        })
    }
*/
static LamExp *cpsTkLamConstruct(LamConstruct *node, CpsKont *k) {
    ENTER(cpsTkLamConstruct);
    CpsKont *k1 = makeKont_TkConstruct(node->name, node->tag, k);
    int save = PROTECT(k1);
    LamExp *args = newLamExp_Args(CPI(node), node->args);
    PROTECT(args);
    LamExp *result = cpsTs_k(args, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamConstruct);
    return result;
}

LamExp *TkConstructKont(LamExp *sargs, TkConstructKontEnv *env) {
    ENTER(TkConstructKont);
    LamExp *construct = makeLamExp_Construct(CPI(sargs), env->name, env->tag, getLamExp_Args(sargs));
    int save = PROTECT(construct);
    LamExp *result = INVOKE(env->k, construct);
    UNPROTECT(save);
    LEAVE(TkConstructKont);
    return result;
}

/*
    (E.deconstruct(name, nsId, vec, expr)) {
        T_k(expr, fn (sexpr) {
            k(E.deconstruct(name, nsId, vec, sexpr))
        })
    }
*/
static LamExp *cpsTkLamDeconstruct(LamDeconstruct *node, CpsKont *k) {
    ENTER(cpsTkLamDeconstruct);
    CpsKont *k1 = makeKont_TkDeconstruct(node->name, node->nsId, node->vec, k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(node->exp, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamDeconstruct);
    return result;
}

LamExp *TkDeconstructKont(LamExp *sexpr, TkDeconstructKontEnv *env) {
    ENTER(TkDeconstructKont);
    LamExp *deconstruct = makeLamExp_Deconstruct(CPI(sexpr), env->name, env->nsId, env->vec, sexpr);
    int save = PROTECT(deconstruct);
    LamExp *result = INVOKE(env->k, deconstruct);
    UNPROTECT(save);
    LEAVE(TkDeconstructKont);
    return result;
}

/*
    (E.tuple_index(size, index, expr)) {
        T_k(expr, fn (sexpr) {
            k(E.tuple_index(size, index, sexpr))
        })
    }
*/
static LamExp *cpsTkLamTupleIndex(LamTupleIndex *node, CpsKont *k) {
    ENTER(cpsTkLamTupleIndex);
    CpsKont *k1 = makeKont_TkTupleIndex(node->size, node->vec, k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(node->exp, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamTupleIndex);
    return result;
}

LamExp *TkTupleIndexKont(LamExp *sexpr, TkTupleIndexKontEnv *env) {
    ENTER(TkTupleIndexKont);
    LamExp *tuple_index = makeLamExp_TupleIndex(CPI(sexpr), env->size, env->index, sexpr);
    int save = PROTECT(tuple_index);
    LamExp *result = INVOKE(env->k, tuple_index);
    UNPROTECT(save);
    LEAVE(TkTupleIndexKont);
    return result;
}

/*
    (E.make_vec(size, args)) {
        Ts_k(args, fn (sargs) {
            k(E.make_vec(size, sargs))
        })
    }
*/
static LamExp *cpsTkMakeVec(LamMakeVec *node, CpsKont *k) {
    ENTER(cpsTkMakeVec);
    CpsKont *k1 = makeKont_TkMakeVec(node->nArgs, k);
    int save = PROTECT(k1);
    LamExp *args = newLamExp_Args(CPI(node), node->args);
    PROTECT(args);
    LamExp *result = cpsTs_k(args, k1);
    UNPROTECT(save);
    LEAVE(cpsTkMakeVec);
    return result;
}

LamExp *TkMakeVecKont(LamExp *sargs, TkMakeVecKontEnv *env) {
    ENTER(TkMakeVecKont);
    LamExp *make_vec = makeLamExp_MakeVec(CPI(sargs), env->size, getLamExp_Args(sargs));
    int save = PROTECT(make_vec);
    LamExp *result = INVOKE(env->k, make_vec);
    UNPROTECT(save);
    LEAVE(TkMakeVecKont);
    return result;
}

/*
    (E.if_expr(exprc, exprt, exprf)) {
        let
            c = kToC(k);
        in 
            T_k(exprc, fn(aexp) {
                E.if_expr(aexp, T_c(exprt, c), T_c(exprf, c))
            })
    }
*/
static LamExp *cpsTkLamIff(LamIff *node, CpsKont *k) {
    ENTER(cpsTkLamIff);
    if (node == NULL) {
        LEAVE(cpsTkLamIff);
        return NULL;
    }
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkIff(c, node->consequent, node->alternative);
    PROTECT(k2);
    LamExp *result = cpsTk(node->condition, k2);
    UNPROTECT(save);
    LEAVE(cpsTkLamIff);
    return result;
}

LamExp *TkIffKont(LamExp *aexp, TkIffKontEnv *env) {
    ENTER(TkIffKont);
    LamExp *consequent = cpsTc(env->exprt, env->c);
    int save = PROTECT(consequent);
    LamExp *alternative = cpsTc(env->exprf, env->c);
    PROTECT(alternative);
    LamExp *result = makeLamExp_Iff(CPI(aexp), aexp, consequent, alternative);
    UNPROTECT(save);
    LEAVE(TkIffKont);
    return result;
}

static LamIntCondCases *mapIntCondCases(LamIntCondCases *cases, LamExp *c) {
    if (cases == NULL) return NULL;
    LamIntCondCases *next = mapIntCondCases(cases->next, c);
    int save = PROTECT(next);
    LamExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    LamIntCondCases *this = newLamIntCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return this;
}

static LamCharCondCases *mapCharCondCases(LamCharCondCases *cases, LamExp *c) {
    if (cases == NULL) return NULL;
    LamCharCondCases *next = mapCharCondCases(cases->next, c);
    int save = PROTECT(next);
    LamExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    LamCharCondCases *this = newLamCharCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return this;
}

/*
    (E.cond_expr(test, branches)) {
        let
            c = kToC(k);
        in
            T_k(test, fn (atest) {
                E.cond_expr(atest, list.map(fn {(#(val, result)) {
                    #(val, T_c(result, c))
                }}, branches))
            })
    }
*/
static LamExp *cpsTkLamCond(LamCond *node, CpsKont *k) {
    ENTER(cpsTkLamCond);
    if (node == NULL) {
        LEAVE(cpsTkLamCond);
        return NULL;
    }
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkCond(c, node->cases);
    PROTECT(k2);
    LamExp *result = cpsTk(node->value, k2);
    UNPROTECT(save);
    LEAVE(cpsTkLamCond);
    return result;
}

LamExp *TkCondKont(LamExp *atest, TkCondKontEnv *env) {
    ENTER(TkCondKont);
    LamCondCases *cases = NULL;
    int save = PROTECT(NULL);
    switch (env->branches->type) {
        case LAMCONDCASES_TYPE_INTEGERS: {
            LamIntCondCases *int_cases = mapIntCondCases(getLamCondCases_Integers(env->branches), env->c);
            PROTECT(int_cases);
            cases = newLamCondCases_Integers(CPI(atest), int_cases);
            PROTECT(cases);
        }
        break;
        case LAMCONDCASES_TYPE_CHARACTERS: {
            LamCharCondCases *char_cases = mapCharCondCases(getLamCondCases_Characters(env->branches), env->c);
            PROTECT(char_cases);
            cases = newLamCondCases_Characters(CPI(atest), char_cases);
            PROTECT(cases);
        }
        default:
            cant_happen("Unknown LamCondCases type %s in TkCondKont", lamCondCasesTypeName(env->branches->type));
    }
    LamExp *result = makeLamExp_Cond(CPI(atest), atest, cases);
    LEAVE(TkCondKont);
    UNPROTECT(save);
    return result;
}

/*
    (E.match_cases(test, cases)) {
        let
            c = kToC(k);
        in
            T_k(test, fn (atest) {
                E.match_cases(atest, list.map(fn {(#(indices, result)) {
                    #(indices, T_c(result, c))
                }}, cases))
            })
    }
*/
static LamExp *cpsTkLamMatch(LamMatch *node, CpsKont *k) {
    ENTER(cpsTkLamMatch);
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkMatch(c, node->cases);
    PROTECT(k2);
    LamExp *result = cpsTk(node->index, k2);
    UNPROTECT(save);
    LEAVE(cpsTkLamMatch);
    return result;
}

LamMatchList *mapTcOverMatchCases(LamMatchList *cases, LamExp *c) {
    if (cases == NULL) return NULL;
    LamMatchList *next = mapTcOverMatchCases(cases->next, c);
    int save = PROTECT(next);
    LamExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    LamMatchList *this = newLamMatchList(CPI(cases), cases->matches, body, next);
    UNPROTECT(save);
    return this;
}

LamExp *TkMatchKont(LamExp *atest, TkMatchKontEnv *env) {
    ENTER(TkMatchKont);
    LamMatchList *cases = mapTcOverMatchCases(env->cases, env->c);
    int save = PROTECT(cases);
    LamExp *result = makeLamExp_Match(CPI(atest), atest, cases);
    UNPROTECT(save);
    LEAVE(TkMatchKont);
    return result;
}

void cpsUnzipLamBindings(LamBindings *bindings,
                         LamVarList **vars,
                         LamArgs **exps) {
    if (bindings == NULL) {
        *vars = NULL;
        *exps = NULL;
        return;
    }
    cpsUnzipLamBindings(bindings->next, vars, exps);
    *vars = newLamVarList(CPI(bindings), bindings->var, *vars);
    PROTECT(*vars);
    *exps = newLamArgs(CPI(bindings), bindings->val, *exps);
    PROTECT(*exps);
}

/*
    (E.let_expr(bindings, expr)) {
        let
            #(vars, exps) = list.unzip(bindings);
        in
            T_k(E.apply(E.lambda(vars, expr), exps), k)
    }
*/
static LamExp *cpsTkLamLet(LamLet *node, CpsKont *k) {
    ENTER(cpsTkLamLet);
    int save = PROTECT(NULL);
    LamVarList *vars = NULL;
    LamArgs *exps = NULL;
    cpsUnzipLamBindings(node->bindings, &vars, &exps); // PROTECTED
    LamExp *lambda = makeLamExp_Lam(CPI(node), vars, node->body);
    PROTECT(lambda);
    LamExp *apply = makeLamExp_Apply(CPI(node), lambda, exps);
    PROTECT(apply);
    LamExp *result = cpsTk(apply, k);
    UNPROTECT(save);
    LEAVE(cpsTkLamLet);
    return result;
}

LamExp *cpsNestLets(LamBindings *bindings, LamExp *body) {
    if (bindings == NULL) {
        return body;
    }
    LamExp *rest = cpsNestLets(bindings->next, body);
    int save = PROTECT(rest);
    LamBindings *binding = newLamBindings(CPI(bindings), bindings->var, bindings->val, NULL);
    PROTECT(binding);
    LamExp *this = makeLamExp_Let(CPI(bindings), binding, rest);
    UNPROTECT(save);
    return this;
}
/*
    (E.letstar_expr(bindings, expr)) {
        let
            fn nest_lets {
                ([], body) { body }
                (#(var, exp) @ rest, body) {
                    E.let_expr([#(var, exp)], nest_lets(rest, body))
                }
            }
        in
            T_k(nest_lets(bindings, expr), k)
    }
*/
static LamExp *cpsTkLamLetStar(LamLetStar *node, CpsKont *k) {
    ENTER(cpsTkLamLetStar);
    LamExp *lets = cpsNestLets(node->bindings, node->body);
    int save = PROTECT(lets);
    LamExp *result = cpsTk(lets, k);
    UNPROTECT(save);
    LEAVE(cpsTkLamLetStar);
    return result;
}

LamBindings *mapMOverBindings(LamBindings *bindings) {
    if (bindings == NULL) return NULL;
    LamBindings *next = mapMOverBindings(bindings->next);
    int save = PROTECT(next);
    LamExp *val = cpsM(bindings->val);
    PROTECT(val);
    LamBindings *this = newLamBindings(CPI(bindings), bindings->var, val, next);
    UNPROTECT(save);
    return this;
}

/*
    (E.letrec_expr(bindings, expr)) {
        let
            #(vars, aexps) = list.unzip(bindings);
        in
            E.letrec_expr(list.zip(vars, list.map(M, aexps)), T_k(expr, k))
    }
*/
static LamExp *cpsTkLamLetRec(LamLetRec *node, CpsKont *k) {
    ENTER(cpsTkLamLetRec);
    LamBindings *bindings = mapMOverBindings(node->bindings);
    int save = PROTECT(bindings);
    LamExp *body = cpsTkLamExp(node->body, k);
    PROTECT(body);
    LamExp *result = makeLamExp_LetRec(CPI(node), bindings, body);
    UNPROTECT(save);
    LEAVE(cpsTkLamLetRec);
    return result;
}

/*
    (E.amb_expr(expr1, expr2)) {
        let
            c = kToC(k);
        in 
            E.amb_expr(T_c(expr1, c), T_c(expr2, c))
    }
*/
static LamExp *cpsTkLamAmb(LamAmb *node, CpsKont *k) {
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    LamExp *exp1 = cpsTc(node->left, c);
    PROTECT(exp1);
    LamExp *exp2 = cpsTc(node->right, c);
    PROTECT(exp2);
    LamExp *result = makeLamExp_Amb(CPI(node), exp1, exp2);
    UNPROTECT(save);
    return result;
}

/*
    (E.print_exp(expr)) {
        T_k(expr, fn (sexpr) {
            k(E.print_exp(sexpr))
        })
    }
*/
static LamExp *cpsTkLamPrint(LamPrint *node, CpsKont *k) {
    ENTER(cpsTkLamPrint);
    CpsKont *k1 = makeKont_TkPrint(k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(node->exp, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamPrint);
    return result;
}

LamExp *TkPrintKont(LamExp *sexpr, TkPrintKontEnv *env) {
    ENTER(TkPrintKont);
    LamExp *print_exp = makeLamExp_Print(CPI(sexpr), sexpr);
    int save = PROTECT(print_exp);
    LamExp *result = INVOKE(env->k, print_exp);
    UNPROTECT(save);
    LEAVE(TkPrintKont);
    return result;
}

/*
    (E.typeOf_expr(expr)) {
        T_k(expr, fn (sexpr) {
            k(E.typeOf_expr(sexpr))
        })
    }
*/
static LamExp *cpsTkLamTypeOf(LamTypeOf *node, CpsKont *k) {
    ENTER(cpsTkLamTypeOf);
    CpsKont *k1 = makeKont_TkTypeOf(k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(node->exp, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamTypeOf);
    return result;
}

LamExp *TkTypeOfKont(LamExp *sexpr, TkTypeOfKontEnv *env) {
    ENTER(TkTypeOfKont);
    LamExp *typeOf_exp = makeLamExp_TypeOf(CPI(sexpr), sexpr);
    int save = PROTECT(typeOf_exp);
    LamExp *result = INVOKE(env->k, typeOf_exp);
    UNPROTECT(save);
    LEAVE(TkTypeOfKont);
    return result;
}

/*
    (E.typeDefs(defs, expr)) {
        E.typeDefs(defs, T_k(expr, k))
    }
*/
static LamExp *cpsTkLamTypeDefs(LamTypeDefs *node, CpsKont *k) {
    ENTER(cpsTkLamTypeDefs);
    LamExp *expr = cpsTk(node->body, k);
    int save = PROTECT(expr);
    LamExp *result = makeLamExp_TypeDefs(CPI(node), node->typeDefs, expr);
    UNPROTECT(save);
    LEAVE(cpsTkLamTypeDefs);
    return result;
}

/*
    (E.callCC_expr(e)) {
        let
            c = kToC(k);
        in
            T_c(E.callCC_expr(e), c)
    }
*/
static LamExp *cpsTkCallCC(LamExp *node, CpsKont *k) {
    ENTER(cpsTkCallCC);
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    LamExp *result = cpsTc(node, c);
    UNPROTECT(save);
    LEAVE(cpsTkCallCC);
    return result;
}

static LamExp *cpsTkLamExp(LamExp *node, CpsKont *k) {
    if (node == NULL) return NULL;

    if (isAexpr(node)) {
        LamExp *expr = cpsM(node);
        int save = PROTECT(expr);
        LamExp *result = INVOKE(k, expr);
        UNPROTECT(save);
        return result;
    }

    switch (node->type) {
        case LAMEXP_TYPE_AMB:
            return cpsTkLamAmb(getLamExp_Amb(node), k);
        case LAMEXP_TYPE_APPLY:
            return cpsTkLamApply(node, k);
        case LAMEXP_TYPE_CALLCC:
            return cpsTkCallCC(getLamExp_CallCC(node), k);
        case LAMEXP_TYPE_COND:
            return cpsTkLamCond(getLamExp_Cond(node), k);
        case LAMEXP_TYPE_CONSTRUCT:
            return cpsTkLamConstruct(getLamExp_Construct(node), k);
        case LAMEXP_TYPE_DECONSTRUCT:
            return cpsTkLamDeconstruct(getLamExp_Deconstruct(node), k);
        case LAMEXP_TYPE_IFF:
            return cpsTkLamIff(getLamExp_Iff(node), k);
        case LAMEXP_TYPE_LET:
            return cpsTkLamLet(getLamExp_Let(node), k);
        case LAMEXP_TYPE_LETSTAR:
            return cpsTkLamLetStar(getLamExp_LetStar(node), k);
        case LAMEXP_TYPE_LETREC:
            return cpsTkLamLetRec(getLamExp_LetRec(node), k);
        case LAMEXP_TYPE_LOOKUP:
            return cpsTkLamLookUp(getLamExp_LookUp(node), k);
        case LAMEXP_TYPE_MAKETUPLE:
            return cpsTkMakeTuple(getLamExp_MakeTuple(node), k);
        case LAMEXP_TYPE_MAKEVEC:
            return cpsTkMakeVec(getLamExp_MakeVec(node), k);
        case LAMEXP_TYPE_MATCH:
            return cpsTkLamMatch(getLamExp_Match(node), k);
        case LAMEXP_TYPE_NAMESPACES:
            return cpsTkLamNameSpaceArray(getLamExp_NameSpaces(node), k);
        case LAMEXP_TYPE_PRIM:
            return cpsTkLamPrimApp(getLamExp_Prim(node), k);
        case LAMEXP_TYPE_PRINT:
            return cpsTkLamPrint(getLamExp_Print(node), k);
        case LAMEXP_TYPE_SEQUENCE:
            return cpsTkLamSequence(getLamExp_Sequence(node), k);
        case LAMEXP_TYPE_TAG:
            return cpsTkTag(getLamExp_Tag(node), k);
        case LAMEXP_TYPE_TUPLEINDEX:
            return cpsTkLamTupleIndex(getLamExp_TupleIndex(node), k);
        case LAMEXP_TYPE_TYPEDEFS:
            return cpsTkLamTypeDefs(getLamExp_TypeDefs(node), k);
        case LAMEXP_TYPE_TYPEOF:
            return cpsTkLamTypeOf(getLamExp_TypeOf(node), k);
        default:
            cant_happen("unrecognized LamExp type %s [%s %d]",
                lamExpTypeName(node->type),
                CPI(node).fileName,
                CPI(node).lineNo);
    }
}

/*
    (E.nameSpaces(exprs)) {
        Ts_k(exprs, fn (sexprs) {
            k(E.nameSpaces(sexprs))
        })
    }
*/
static LamExp *cpsTkLamNameSpaceArray(LamNameSpaceArray *node, CpsKont *k) {
    ENTER(cpsTkLamNameSpaceArray);
    LamExp *seq = nsaToArgs(node);
    int save = PROTECT(seq);
    CpsKont *k1 = makeKont_TkNameSpaces(k);
    PROTECT(k1);
    LamExp *result = cpsTs_k(seq, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamNameSpaceArray);
    return result;
}

LamExp *TkNameSpacesKont(LamExp *sexprs, TkNameSpacesKontEnv *env) {
    ENTER(TkNameSpacesKont);
    LamNameSpaceArray *nsa = argsToNsa(sexprs);
    int save = PROTECT(nsa);
    LamExp *nsaExp = newLamExp_NameSpaces(CPI(sexprs), nsa);
    PROTECT(nsaExp);
    LamExp *result = INVOKE(env->k, nsaExp);
    UNPROTECT(save);
    LEAVE(TkNameSpacesKont);
    return result;
}

LamExp *nsaToArgs(LamNameSpaceArray *nsa) {
    ENTER(nsaToArgs);
    LamArgs *args = NULL;
    int save = PROTECT(NULL);
    for (Index i = nsa->size; i > 0; i--) {
        LamExp *ns_exp = peeknLamNameSpaceArray(nsa, i - 1);
        args = newLamArgs(CPI(ns_exp), ns_exp, args);
        PROTECT(args);
    }
    LamExp *result = newLamExp_Args(CPI(args), args);
    UNPROTECT(save);
    LEAVE(nsaToArgs);
    return result;
}

LamNameSpaceArray *argsToNsa(LamExp *args_exp) {
    ENTER(argsToNsa);
    LamArgs *args = getLamExp_Args(args_exp);
    LamNameSpaceArray *nsa = newLamNameSpaceArray();
    int save = PROTECT(nsa);
    for (LamArgs *current = args; current != NULL; current = current->next) {
        pushLamNameSpaceArray(nsa, current->exp);
    }
    UNPROTECT(save);
    LEAVE(argsToNsa);
    return nsa;
}

LamExp *cpsTk(LamExp *node, CpsKont *k) {
    return cpsTkLamExp(node, k);
}
