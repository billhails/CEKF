/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2025  Bill Hails
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 * Generated from src/lambda.yaml by tools/generate.py
 */

#include "lambda.h"
#include "memory.h"
#include "symbol.h"

#include "lambda_cps.h"
#include "lambda_functions.h"
#include "cps_kont.h"
#include "cps_kont_impl.h"

#ifdef DEBUG_LAMBDA_CPSTK
#  include "debugging_on.h"
#else
#  include "debugging_off.h"
#endif

// Forward declarations
static LamMacroSet *cpsTkLamMacroSet(LamMacroSet *node, CpsKont *k);
static LamInfoTable *cpsTkLamInfoTable(LamInfoTable *node, CpsKont *k);
static LamAliasTable *cpsTkLamAliasTable(LamAliasTable *node, CpsKont *k);
static LamAlphaTable *cpsTkLamAlphaTable(LamAlphaTable *node, CpsKont *k);
static LamLam *cpsTkLamLam(LamLam *node, CpsKont *k);
static LamVarList *cpsTkLamVarList(LamVarList *node, CpsKont *k);
static LamPrimApp *cpsTkLamPrimApp(LamPrimApp *node, CpsKont *k);
static LamSequence *cpsTkLamSequence(LamSequence *node, CpsKont *k);
static LamArgs *cpsTkLamArgs(LamArgs *node, CpsKont *k);
static LamExp *cpsTkLamApply(LamExp *node, CpsKont *k);
static LamLookup *cpsTkLamLookup(LamLookup *node, CpsKont *k);
static LamLookupSymbol *cpsTkLamLookupSymbol(LamLookupSymbol *node, CpsKont *k);
static LamConstant *cpsTkLamConstant(LamConstant *node, CpsKont *k);
static LamExp *cpsTkLamConstruct(LamConstruct *node, CpsKont *k);
static LamExp *cpsTkLamDeconstruct(LamDeconstruct *node, CpsKont *k);
static LamTupleIndex *cpsTkLamTupleIndex(LamTupleIndex *node, CpsKont *k);
static LamMakeVec *cpsTkLamMakeVec(LamMakeVec *node, CpsKont *k);
static LamExp *cpsTkLamIff(LamIff *node, CpsKont *k);
static LamExp *cpsTkLamCond(LamCond *node, CpsKont *k);
static LamMatch *cpsTkLamMatch(LamMatch *node, CpsKont *k);
static LamMatchList *cpsTkLamMatchList(LamMatchList *node, CpsKont *k);
static LamIntList *cpsTkLamIntList(LamIntList *node, CpsKont *k);
static LamLet *cpsTkLamLet(LamLet *node, CpsKont *k);
static LamBindings *cpsTkLamBindings(LamBindings *node, CpsKont *k);
static LamLetRec *cpsTkLamLetRec(LamLetRec *node, CpsKont *k);
static LamContext *cpsTkLamContext(LamContext *node, CpsKont *k);
static LamExp *cpsTkLamAmb(LamAmb *node, CpsKont *k);
static LamPrint *cpsTkLamPrint(LamPrint *node, CpsKont *k);
static LamTypeof *cpsTkLamTypeof(LamTypeof *node, CpsKont *k);
static LamTypeDefs *cpsTkLamTypeDefs(LamTypeDefs *node, CpsKont *k);
static LamTypeDefList *cpsTkLamTypeDefList(LamTypeDefList *node, CpsKont *k);
static LamTypeDef *cpsTkLamTypeDef(LamTypeDef *node, CpsKont *k);
static LamTypeConstructorList *cpsTkLamTypeConstructorList(LamTypeConstructorList *node, CpsKont *k);
static LamTypeSig *cpsTkLamTypeSig(LamTypeSig *node, CpsKont *k);
static LamTypeTags *cpsTkLamTypeTags(LamTypeTags *node, CpsKont *k);
static LamTypeSigArgs *cpsTkLamTypeSigArgs(LamTypeSigArgs *node, CpsKont *k);
static LamTypeConstructor *cpsTkLamTypeConstructor(LamTypeConstructor *node, CpsKont *k);
static LamTypeConstructorArgs *cpsTkLamTypeConstructorArgs(LamTypeConstructorArgs *node, CpsKont *k);
static LamTypeFunction *cpsTkLamTypeFunction(LamTypeFunction *node, CpsKont *k);
static LamTypeConstructorInfo *cpsTkLamTypeConstructorInfo(LamTypeConstructorInfo *node, CpsKont *k);
static LamAlphaEnv *cpsTkLamAlphaEnv(LamAlphaEnv *node, CpsKont *k);
static LamExp *cpsTkLamExp(LamExp *node, CpsKont *k);
static LamLookupOrSymbol *cpsTkLamLookupOrSymbol(LamLookupOrSymbol *node, CpsKont *k);
static LamTypeConstructorType *cpsTkLamTypeConstructorType(LamTypeConstructorType *node, CpsKont *k);
static LamInfo *cpsTkLamInfo(LamInfo *node, CpsKont *k);
static LamNamespaceArray *cpsTkLamNamespaceArray(LamNamespaceArray *node, CpsKont *k);
static LamAlphaEnvArray *cpsTkLamAlphaEnvArray(LamAlphaEnvArray *node, CpsKont *k);

// utilities
static inline LamExp *INVOKE(CpsKont *k, LamExp *arg) {
    return k->wrapper(arg, k->env);
}

bool isAexpr(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_VAR:
        case LAMEXP_TYPE_BACK:
        case LAMEXP_TYPE_CHARACTER:
        case LAMEXP_TYPE_CONSTANT:
        case LAMEXP_TYPE_CONSTRUCTOR:
        case LAMEXP_TYPE_ENV:
        case LAMEXP_TYPE_ERROR:
        case LAMEXP_TYPE_LAM:
        case LAMEXP_TYPE_STDINT:
        case LAMEXP_TYPE_BIGINTEGER:
            return true;
        default:
            return false;
    }
}

LamExp *makeVar(ParserInfo PI, char *prefix) {
    return newLamExp_Var(PI, genSymDollar(prefix));
}

LamArgs *appendLamArg(LamArgs *args, LamExp *exp) {
    if (args == NULL) return newLamArgs(CPI(exp), exp, NULL);
    LamArgs *next = appendLamArg(args->next, exp);
    int save = PROTECT(next);
    LamArgs *this = newLamArgs(CPI(args), args->exp, next);
    UNPROTECT(save);
    return this;
}

LamVarList *appendLamVar(ParserInfo PI, LamVarList *args, HashSymbol *var) {
    if (args == NULL) return newLamVarList(PI, var, NULL);
    LamVarList *next = appendLamVar(PI, args->next, var);
    int save = PROTECT(next);
    LamVarList *this = newLamVarList(CPI(args), args->var, next);
    UNPROTECT(save);
    return this;
}

/*
    fn Ts_k {
        ([], k) { k([]) }
        (h @ t, k) {
            T_k(h, fn (hd) {
                Ts_k(t, fn (tl) {
                    k(hd @ tl)
                })
            })
        }
    }
 */
LamExp *cpsTs_k(LamExp *exp, CpsKont *k) {
    ENTER(cpsTs_k);
    LamArgs *args = getLamExp_Args(exp);
    if (args == NULL) {
        return INVOKE(k, exp);
    }
    LamExp *h = args->exp;
    LamArgs *t = args->next;
    CpsKont *k1 = makeKont_TkS1(t, k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(h, k1);
    LEAVE(cpsTs_k);
    UNPROTECT(save);
    return result;
}

LamExp *TkS1Kont(LamExp *hd, TkS1KontEnv *env) {
    ENTER(TkS1Kont);
    CpsKont *k2 = makeKont_TkS2(env->k, hd);
    int save = PROTECT(k2);
    LamExp *result = cpsTs_k(newLamExp_Args(CPI(env->t), env->t), k2);
    LEAVE(TkS1Kont);
    UNPROTECT(save);
    return result;
}

LamExp *TkS2Kont(LamExp *tl, TkS2KontEnv *env) {
    ENTER(TkS2Kont);
    LamExp *args = makeLamExp_Args(CPI(env->hd), env->hd, getLamExp_Args(tl));
    int save = PROTECT(args);
    LamExp *result = INVOKE(env->k, args);
    UNPROTECT(save);
    LEAVE(TkS2Kont);
    return result;
}

/*
    fn kToC(k) {
        let rv = gensym("$rv");
        in E.lambda([rv], k(rv))
    }
*/
static LamExp *kToC(ParserInfo PI, CpsKont *k) {
    LamExp *rv = makeVar(PI, "rv");
    int save = PROTECT(rv);
    LamExp *body = INVOKE(k, rv);
    PROTECT(body);
    LamVarList *args = newLamVarList(PI, getLamExp_Var(rv), NULL);
    PROTECT(args);
    LamExp *cont = makeLamExp_Lam(PI, args, body);
    UNPROTECT(save);
    return cont;
}

// Visitor implementations
static LamMacroSet *cpsTkLamMacroSet(LamMacroSet *node, CpsKont *k) {
    ENTER(cpsTkLamMacroSet);
    if (node == NULL) {
        LEAVE(cpsTkLamMacroSet);
        return NULL;
    }

    (void)k;  // Hash set has no values to visit
    // Iterate over keys (uncomment if you need to inspect/log them)
    // Index i = 0;
    // HashSymbol *key;
    // while ((key = iterateLamMacroSet(node, &i)) != NULL) {
    //     // Inspect/log key here
    // }
    LEAVE(cpsTkLamMacroSet);
    return node;
}

static LamInfoTable *cpsTkLamInfoTable(LamInfoTable *node, CpsKont *k) {
    ENTER(cpsTkLamInfoTable);
    if (node == NULL) {
        LEAVE(cpsTkLamInfoTable);
        return NULL;
    }

    bool changed = false;
    LamInfoTable *result = newLamInfoTable();
    int save = PROTECT(result);

    // Iterate over all entries
    Index i = 0;
    struct LamInfo * value;
    HashSymbol *key;
    while ((key = iterateLamInfoTable(node, &i, &value)) != NULL) {
        struct LamInfo * new_value = cpsTkLamInfo(value, k);
        PROTECT(new_value);
        changed = changed || (new_value != value);
        setLamInfoTable(result, key, new_value);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTkLamInfoTable);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamInfoTable);
    return node;
}

static LamAliasTable *cpsTkLamAliasTable(LamAliasTable *node, CpsKont *k) {
    ENTER(cpsTkLamAliasTable);
    if (node == NULL) {
        LEAVE(cpsTkLamAliasTable);
        return NULL;
    }

    bool changed = false;
    LamAliasTable *result = newLamAliasTable();
    int save = PROTECT(result);

    // Iterate over all entries
    Index i = 0;
    struct LamTypeConstructorType * value;
    HashSymbol *key;
    while ((key = iterateLamAliasTable(node, &i, &value)) != NULL) {
        struct LamTypeConstructorType * new_value = cpsTkLamTypeConstructorType(value, k);
        PROTECT(new_value);
        changed = changed || (new_value != value);
        setLamAliasTable(result, key, new_value);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTkLamAliasTable);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamAliasTable);
    return node;
}

static LamAlphaTable *cpsTkLamAlphaTable(LamAlphaTable *node, CpsKont *k) {
    ENTER(cpsTkLamAlphaTable);
    if (node == NULL) {
        LEAVE(cpsTkLamAlphaTable);
        return NULL;
    }

    (void)k;  // Values are HashSymbol (not memory-managed)
#ifdef NOTDEF
    // Iterate over all entries for inspection/logging
    Index i = 0;
    struct HashSymbol * value;
    HashSymbol *key;
    while ((key = iterateLamAlphaTable(node, &i, &value)) != NULL) {
        // Inspect/log key and value here
    }
#endif
    LEAVE(cpsTkLamAlphaTable);
    return node;
}

static LamLam *cpsTkLamLam(LamLam *node, CpsKont *k) {
    ENTER(cpsTkLamLam);
    if (node == NULL) {
        LEAVE(cpsTkLamLam);
        return NULL;
    }

    bool changed = false;
    LamVarList *new_args = cpsTkLamVarList(node->args, k);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);
    LamExp *new_exp = cpsTkLamExp(node->exp, k);
    PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    // Pass through isMacro (type: bool, not memory-managed)

    if (changed) {
        // Create new node with modified fields
        LamLam *result = newLamLam(CPI(node), new_args, new_exp);
        UNPROTECT(save);
        LEAVE(cpsTkLamLam);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamLam);
    return node;
}

static LamVarList *cpsTkLamVarList(LamVarList *node, CpsKont *k) {
    ENTER(cpsTkLamVarList);
    if (node == NULL) {
        LEAVE(cpsTkLamVarList);
        return NULL;
    }

    bool changed = false;
    // Pass through var (type: HashSymbol, not memory-managed)
    LamVarList *new_next = cpsTkLamVarList(node->next, k);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamVarList *result = newLamVarList(CPI(node), node->var, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamVarList);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamVarList);
    return node;
}

static LamPrimApp *cpsTkLamPrimApp(LamPrimApp *node, CpsKont *k) {
    ENTER(cpsTkLamPrimApp);
    if (node == NULL) {
        LEAVE(cpsTkLamPrimApp);
        return NULL;
    }

    bool changed = false;
    // Pass through type (type: LamPrimOp, not memory-managed)
    LamExp *new_exp1 = cpsTkLamExp(node->exp1, k);
    int save = PROTECT(new_exp1);
    changed = changed || (new_exp1 != node->exp1);
    LamExp *new_exp2 = cpsTkLamExp(node->exp2, k);
    PROTECT(new_exp2);
    changed = changed || (new_exp2 != node->exp2);

    if (changed) {
        // Create new node with modified fields
        LamPrimApp *result = newLamPrimApp(CPI(node), node->type, new_exp1, new_exp2);
        UNPROTECT(save);
        LEAVE(cpsTkLamPrimApp);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamPrimApp);
    return node;
}

static LamSequence *cpsTkLamSequence(LamSequence *node, CpsKont *k) {
    ENTER(cpsTkLamSequence);
    if (node == NULL) {
        LEAVE(cpsTkLamSequence);
        return NULL;
    }

    bool changed = false;
    LamExp *new_exp = cpsTkLamExp(node->exp, k);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamSequence *new_next = cpsTkLamSequence(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamSequence *result = newLamSequence(CPI(node), new_exp, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamSequence);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamSequence);
    return node;
}

static LamArgs *cpsTkLamArgs(LamArgs *node, CpsKont *k) {
    ENTER(cpsTkLamArgs);
    if (node == NULL) {
        LEAVE(cpsTkLamArgs);
        return NULL;
    }

    bool changed = false;
    LamExp *new_exp = cpsTkLamExp(node->exp, k);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamArgs *new_next = cpsTkLamArgs(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamArgs *result = newLamArgs(CPI(node), new_exp, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamArgs);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamArgs);
    return node;
}

/*
    (E.apply(_, _)) {
        let
            c = kToC(k)
        in
            T_c(e, c)
    }
*/
static LamExp *cpsTkLamApply(LamExp *node, CpsKont *k) {
    ENTER(cpsTkLamApply);
    if (node == NULL) {
        LEAVE(cpsTkLamApply);
        return NULL;
    }

    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    LamExp *result = cpsTc(node, c);
    UNPROTECT(save);
    LEAVE(cpsTkLamApply);
    return result;
}

static LamLookup *cpsTkLamLookup(LamLookup *node, CpsKont *k) {
    ENTER(cpsTkLamLookup);
    if (node == NULL) {
        LEAVE(cpsTkLamLookup);
        return NULL;
    }

    bool changed = false;
    // Pass through nsid (type: int, not memory-managed)
    // Pass through nsSymbol (type: HashSymbol, not memory-managed)
    LamExp *new_exp = cpsTkLamExp(node->exp, k);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        LamLookup *result = newLamLookup(CPI(node), node->nsid, node->nsSymbol, new_exp);
        UNPROTECT(save);
        LEAVE(cpsTkLamLookup);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamLookup);
    return node;
}

static LamLookupSymbol *cpsTkLamLookupSymbol(LamLookupSymbol *node, CpsKont *k) {
    ENTER(cpsTkLamLookupSymbol);
    if (node == NULL) {
        LEAVE(cpsTkLamLookupSymbol);
        return NULL;
    }

    // Pass through nsid (type: int, not memory-managed)
    // Pass through nsSymbol (type: HashSymbol, not memory-managed)
    // Pass through symbol (type: HashSymbol, not memory-managed)

    (void)k;  // Unused parameter - all fields are pass-through
    LEAVE(cpsTkLamLookupSymbol);
    return node;
}

static LamConstant *cpsTkLamConstant(LamConstant *node, CpsKont *k) {
    ENTER(cpsTkLamConstant);
    if (node == NULL) {
        LEAVE(cpsTkLamConstant);
        return NULL;
    }

    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through tag (type: int, not memory-managed)

    (void)k;  // Unused parameter - all fields are pass-through
    LEAVE(cpsTkLamConstant);
    return node;
}

/*
    (E.construct(name, args)) {
        Ts_k(args, fn (sargs) {
            k(E.construct(name, sargs))
        })
    }
*/
static LamExp *cpsTkLamConstruct(LamConstruct *node, CpsKont *k) {
    ENTER(cpsTkLamConstruct);
    CpsKont *k1 = makeKont_TkConstruct(node->name, node->tag, k);
    int save = PROTECT(k1);
    LamExp *args = newLamExp_Args(CPI(node), node->args);
    PROTECT(args);
    LamExp *result = cpsTs_k(args, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamConstruct);
    return result;
}

LamExp *TkConstructKont(LamExp *sargs, TkConstructKontEnv *env) {
    ENTER(TkConstructKont);
    LamExp *construct = makeLamExp_Construct(CPI(sargs), env->name, env->tag, getLamExp_Args(sargs));
    int save = PROTECT(construct);
    LamExp *result = INVOKE(env->k, construct);
    UNPROTECT(save);
    LEAVE(TkConstructKont);
    return result;
}

/*
    (E.deconstruct(name, nsid, vec, expr)) {
        T_k(expr, fn (sexpr) {
            k(E.deconstruct(name, nsid, vec, sexpr))
        })
    }
*/
static LamExp *cpsTkLamDeconstruct(LamDeconstruct *node, CpsKont *k) {
    ENTER(cpsTkLamDeconstruct);
    CpsKont *k1 = makeKont_TkDeconstruct(node->name, node->nsid, node->vec, k);
    int save = PROTECT(k1);
    LamExp *result = cpsTk(node->exp, k1);
    UNPROTECT(save);
    LEAVE(cpsTkLamDeconstruct);
    return result;
}

LamExp *TkDeconstructKont(LamExp *sexpr, TkDeconstructKontEnv *env) {
    ENTER(TkDeconstructKont);
    LamExp *deconstruct = makeLamExp_Deconstruct(CPI(sexpr), env->name, env->nsid, env->vec, sexpr);
    int save = PROTECT(deconstruct);
    LamExp *result = INVOKE(env->k, deconstruct);
    UNPROTECT(save);
    LEAVE(TkDeconstructKont);
    return result;
}

static LamTupleIndex *cpsTkLamTupleIndex(LamTupleIndex *node, CpsKont *k) {
    ENTER(cpsTkLamTupleIndex);
    if (node == NULL) {
        LEAVE(cpsTkLamTupleIndex);
        return NULL;
    }

    bool changed = false;
    // Pass through vec (type: int, not memory-managed)
    // Pass through size (type: int, not memory-managed)
    LamExp *new_exp = cpsTkLamExp(node->exp, k);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        LamTupleIndex *result = newLamTupleIndex(CPI(node), node->vec, node->size, new_exp);
        UNPROTECT(save);
        LEAVE(cpsTkLamTupleIndex);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTupleIndex);
    return node;
}

static LamMakeVec *cpsTkLamMakeVec(LamMakeVec *node, CpsKont *k) {
    ENTER(cpsTkLamMakeVec);
    if (node == NULL) {
        LEAVE(cpsTkLamMakeVec);
        return NULL;
    }

    bool changed = false;
    // Pass through nargs (type: int, not memory-managed)
    LamArgs *new_args = cpsTkLamArgs(node->args, k);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamMakeVec *result = newLamMakeVec(CPI(node), node->nargs, new_args);
        UNPROTECT(save);
        LEAVE(cpsTkLamMakeVec);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamMakeVec);
    return node;
}

/*
    (E.if_expr(exprc, exprt, exprf)) {
        let
            c = kToC(k);
        in 
            T_k(exprc, fn(aexp) {
                E.if_expr(aexp, T_c(exprt, c), T_c(exprf, c))
            })
    }
*/
static LamExp *cpsTkLamIff(LamIff *node, CpsKont *k) {
    ENTER(cpsTkLamIff);
    if (node == NULL) {
        LEAVE(cpsTkLamIff);
        return NULL;
    }
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkIf(c, node->consequent, node->alternative);
    PROTECT(k2);
    LamExp *result = cpsTk(node->condition, k2);
    UNPROTECT(save);
    LEAVE(cpsTkLamIff);
    return result;
}

LamExp *TkIfKont(LamExp *aexp, TkIfKontEnv *env) {
    ENTER(TkIfKont);
    LamExp *consequent = cpsTc(env->exprt, env->c);
    int save = PROTECT(consequent);
    LamExp *alternative = cpsTc(env->exprf, env->c);
    PROTECT(alternative);
    LamExp *result = makeLamExp_Iff(CPI(aexp), aexp, consequent, alternative);
    UNPROTECT(save);
    LEAVE(TkIfKont);
    return result;
}

static LamIntCondCases *mapIntCondCases(LamIntCondCases *cases, LamExp *c) {
    if (cases == NULL) return NULL;
    LamIntCondCases *next = mapIntCondCases(cases->next, c);
    int save = PROTECT(next);
    LamExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    LamIntCondCases *this = newLamIntCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return this;
}

static LamCharCondCases *mapCharCondCases(LamCharCondCases *cases, LamExp *c) {
    if (cases == NULL) return NULL;
    LamCharCondCases *next = mapCharCondCases(cases->next, c);
    int save = PROTECT(next);
    LamExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    LamCharCondCases *this = newLamCharCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return this;
}

/*
    (E.cond_expr(test, branches)) {
        let
            c = kToC(k);
        in
            T_k(test, fn (atest) {
                E.cond_expr(atest, list.map(fn {(#(val, result)) {
                    #(val, T_c(result, c))
                }}, branches))
            })
    }
*/
static LamExp *cpsTkLamCond(LamCond *node, CpsKont *k) {
    ENTER(cpsTkLamCond);
    if (node == NULL) {
        LEAVE(cpsTkLamCond);
        return NULL;
    }
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    CpsKont *k2 = makeKont_TkCond(c, node->cases);
    PROTECT(k2);
    LamExp *result = cpsTk(node->value, k2);
    UNPROTECT(save);
    LEAVE(cpsTkLamCond);
    return result;
}

LamExp *TkCondKont(LamExp *atest, TkCondKontEnv *env) {
    ENTER(TkCondKont);
    LamCondCases *cases = NULL;
    int save = PROTECT(NULL);
    switch (env->branches->type) {
        case LAMCONDCASES_TYPE_INTEGERS: {
            LamIntCondCases *int_cases = mapIntCondCases(getLamCondCases_Integers(env->branches), env->c);
            PROTECT(int_cases);
            cases = newLamCondCases_Integers(CPI(atest), int_cases);
            PROTECT(cases);
        }
        break;
        case LAMCONDCASES_TYPE_CHARACTERS: {
            LamCharCondCases *char_cases = mapCharCondCases(getLamCondCases_Characters(env->branches), env->c);
            PROTECT(char_cases);
            cases = newLamCondCases_Characters(CPI(atest), char_cases);
            PROTECT(cases);
        }
        default:
            cant_happen("Unknown LamCondCases type %s in TkCondKont", lamCondCasesTypeName(env->branches->type));
    }
    LamExp *result = makeLamExp_Cond(CPI(atest), atest, cases);
    LEAVE(TkCondKont);
    UNPROTECT(save);
    return result;
}

static LamMatch *cpsTkLamMatch(LamMatch *node, CpsKont *k) {
    ENTER(cpsTkLamMatch);
    if (node == NULL) {
        LEAVE(cpsTkLamMatch);
        return NULL;
    }

    bool changed = false;
    LamExp *new_index = cpsTkLamExp(node->index, k);
    int save = PROTECT(new_index);
    changed = changed || (new_index != node->index);
    LamMatchList *new_cases = cpsTkLamMatchList(node->cases, k);
    PROTECT(new_cases);
    changed = changed || (new_cases != node->cases);

    if (changed) {
        // Create new node with modified fields
        LamMatch *result = newLamMatch(CPI(node), new_index, new_cases);
        UNPROTECT(save);
        LEAVE(cpsTkLamMatch);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamMatch);
    return node;
}

static LamMatchList *cpsTkLamMatchList(LamMatchList *node, CpsKont *k) {
    ENTER(cpsTkLamMatchList);
    if (node == NULL) {
        LEAVE(cpsTkLamMatchList);
        return NULL;
    }

    bool changed = false;
    LamIntList *new_matches = cpsTkLamIntList(node->matches, k);
    int save = PROTECT(new_matches);
    changed = changed || (new_matches != node->matches);
    LamExp *new_body = cpsTkLamExp(node->body, k);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);
    LamMatchList *new_next = cpsTkLamMatchList(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamMatchList *result = newLamMatchList(CPI(node), new_matches, new_body, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamMatchList);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamMatchList);
    return node;
}

static LamIntList *cpsTkLamIntList(LamIntList *node, CpsKont *k) {
    ENTER(cpsTkLamIntList);
    if (node == NULL) {
        LEAVE(cpsTkLamIntList);
        return NULL;
    }

    bool changed = false;
    // Pass through item (type: int, not memory-managed)
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through nsid (type: int, not memory-managed)
    LamIntList *new_next = cpsTkLamIntList(node->next, k);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamIntList *result = newLamIntList(CPI(node), node->item, node->name, node->nsid, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamIntList);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamIntList);
    return node;
}

static LamLet *cpsTkLamLet(LamLet *node, CpsKont *k) {
    ENTER(cpsTkLamLet);
    if (node == NULL) {
        LEAVE(cpsTkLamLet);
        return NULL;
    }

    bool changed = false;
    LamBindings *new_bindings = cpsTkLamBindings(node->bindings, k);
    int save = PROTECT(new_bindings);
    changed = changed || (new_bindings != node->bindings);
    LamExp *new_body = cpsTkLamExp(node->body, k);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);

    if (changed) {
        // Create new node with modified fields
        LamLet *result = newLamLet(CPI(node), new_bindings, new_body);
        UNPROTECT(save);
        LEAVE(cpsTkLamLet);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamLet);
    return node;
}

static LamBindings *cpsTkLamBindings(LamBindings *node, CpsKont *k) {
    ENTER(cpsTkLamBindings);
    if (node == NULL) {
        LEAVE(cpsTkLamBindings);
        return NULL;
    }

    bool changed = false;
    // Pass through var (type: HashSymbol, not memory-managed)
    LamExp *new_val = cpsTkLamExp(node->val, k);
    int save = PROTECT(new_val);
    changed = changed || (new_val != node->val);
    LamBindings *new_next = cpsTkLamBindings(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamBindings *result = newLamBindings(CPI(node), node->var, new_val, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamBindings);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamBindings);
    return node;
}

static LamLetRec *cpsTkLamLetRec(LamLetRec *node, CpsKont *k) {
    ENTER(cpsTkLamLetRec);
    if (node == NULL) {
        LEAVE(cpsTkLamLetRec);
        return NULL;
    }

    bool changed = false;
    LamBindings *new_bindings = cpsTkLamBindings(node->bindings, k);
    int save = PROTECT(new_bindings);
    changed = changed || (new_bindings != node->bindings);
    LamExp *new_body = cpsTkLamExp(node->body, k);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);

    if (changed) {
        // Create new node with modified fields
        LamLetRec *result = newLamLetRec(CPI(node), new_bindings, new_body);
        UNPROTECT(save);
        LEAVE(cpsTkLamLetRec);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamLetRec);
    return node;
}

static LamContext *cpsTkLamContext(LamContext *node, CpsKont *k) {
    ENTER(cpsTkLamContext);
    if (node == NULL) {
        LEAVE(cpsTkLamContext);
        return NULL;
    }

    bool changed = false;
    LamInfoTable *new_frame = cpsTkLamInfoTable(node->frame, k);
    int save = PROTECT(new_frame);
    changed = changed || (new_frame != node->frame);
    LamAliasTable *new_aliases = cpsTkLamAliasTable(node->aliases, k);
    PROTECT(new_aliases);
    changed = changed || (new_aliases != node->aliases);
    LamMacroSet *new_macros = cpsTkLamMacroSet(node->macros, k);
    PROTECT(new_macros);
    changed = changed || (new_macros != node->macros);
    LamContext *new_parent = cpsTkLamContext(node->parent, k);
    PROTECT(new_parent);
    changed = changed || (new_parent != node->parent);

    if (changed) {
        // Create new node with modified fields
        LamContext *result = newLamContext(CPI(node), new_parent);
        result->frame = new_frame;
        result->aliases = new_aliases;
        result->macros = new_macros;
        UNPROTECT(save);
        LEAVE(cpsTkLamContext);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamContext);
    return node;
}

/*
    (E.amb_expr(expr1, expr2)) {
        let
            c = kToC(k);
        in 
            E.amb_expr(T_c(expr1, c), T_c(expr2, c))
    }
*/
static LamExp *cpsTkLamAmb(LamAmb *node, CpsKont *k) {
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    LamExp *exp1 = cpsTc(node->left, c);
    PROTECT(exp1);
    LamExp *exp2 = cpsTc(node->right, c);
    PROTECT(exp2);
    LamExp *result = makeLamExp_Amb(CPI(node), exp1, exp2);
    UNPROTECT(save);
    return result;
}

static LamPrint *cpsTkLamPrint(LamPrint *node, CpsKont *k) {
    ENTER(cpsTkLamPrint);
    if (node == NULL) {
        LEAVE(cpsTkLamPrint);
        return NULL;
    }

    bool changed = false;
    LamExp *new_exp = cpsTkLamExp(node->exp, k);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamExp *new_printer = cpsTkLamExp(node->printer, k);
    PROTECT(new_printer);
    changed = changed || (new_printer != node->printer);

    if (changed) {
        // Create new node with modified fields
        LamPrint *result = newLamPrint(CPI(node), new_exp);
        result->printer = new_printer;
        UNPROTECT(save);
        LEAVE(cpsTkLamPrint);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamPrint);
    return node;
}

static LamTypeof *cpsTkLamTypeof(LamTypeof *node, CpsKont *k) {
    ENTER(cpsTkLamTypeof);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeof);
        return NULL;
    }

    bool changed = false;
    LamExp *new_exp = cpsTkLamExp(node->exp, k);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamExp *new_typestring = cpsTkLamExp(node->typestring, k);
    PROTECT(new_typestring);
    changed = changed || (new_typestring != node->typestring);

    if (changed) {
        // Create new node with modified fields
        LamTypeof *result = newLamTypeof(CPI(node), new_exp);
        result->typestring = new_typestring;
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeof);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeof);
    return node;
}

static LamTypeDefs *cpsTkLamTypeDefs(LamTypeDefs *node, CpsKont *k) {
    ENTER(cpsTkLamTypeDefs);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeDefs);
        return NULL;
    }

    bool changed = false;
    LamTypeDefList *new_typeDefs = cpsTkLamTypeDefList(node->typeDefs, k);
    int save = PROTECT(new_typeDefs);
    changed = changed || (new_typeDefs != node->typeDefs);
    LamExp *new_body = cpsTkLamExp(node->body, k);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);

    if (changed) {
        // Create new node with modified fields
        LamTypeDefs *result = newLamTypeDefs(CPI(node), new_typeDefs, new_body);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeDefs);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeDefs);
    return node;
}

static LamTypeDefList *cpsTkLamTypeDefList(LamTypeDefList *node, CpsKont *k) {
    ENTER(cpsTkLamTypeDefList);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeDefList);
        return NULL;
    }

    bool changed = false;
    LamTypeDef *new_typeDef = cpsTkLamTypeDef(node->typeDef, k);
    int save = PROTECT(new_typeDef);
    changed = changed || (new_typeDef != node->typeDef);
    LamTypeDefList *new_next = cpsTkLamTypeDefList(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeDefList *result = newLamTypeDefList(CPI(node), new_typeDef, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeDefList);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeDefList);
    return node;
}

static LamTypeDef *cpsTkLamTypeDef(LamTypeDef *node, CpsKont *k) {
    ENTER(cpsTkLamTypeDef);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeDef);
        return NULL;
    }

    bool changed = false;
    LamTypeSig *new_type = cpsTkLamTypeSig(node->type, k);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeConstructorList *new_constructors = cpsTkLamTypeConstructorList(node->constructors, k);
    PROTECT(new_constructors);
    changed = changed || (new_constructors != node->constructors);

    if (changed) {
        // Create new node with modified fields
        LamTypeDef *result = newLamTypeDef(CPI(node), new_type, new_constructors);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeDef);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeDef);
    return node;
}

static LamTypeConstructorList *cpsTkLamTypeConstructorList(LamTypeConstructorList *node, CpsKont *k) {
    ENTER(cpsTkLamTypeConstructorList);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeConstructorList);
        return NULL;
    }

    bool changed = false;
    LamTypeConstructor *new_constructor = cpsTkLamTypeConstructor(node->constructor, k);
    int save = PROTECT(new_constructor);
    changed = changed || (new_constructor != node->constructor);
    LamTypeConstructorList *new_next = cpsTkLamTypeConstructorList(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorList *result = newLamTypeConstructorList(CPI(node), new_constructor, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeConstructorList);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeConstructorList);
    return node;
}

static LamTypeSig *cpsTkLamTypeSig(LamTypeSig *node, CpsKont *k) {
    ENTER(cpsTkLamTypeSig);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeSig);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSigArgs *new_args = cpsTkLamTypeSigArgs(node->args, k);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeSig *result = newLamTypeSig(CPI(node), node->name, new_args);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeSig);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeSig);
    return node;
}

static LamTypeTags *cpsTkLamTypeTags(LamTypeTags *node, CpsKont *k) {
    ENTER(cpsTkLamTypeTags);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeTags);
        return NULL;
    }

    bool changed = false;
    // Pass through tag (type: HashSymbol, not memory-managed)
    LamTypeTags *new_next = cpsTkLamTypeTags(node->next, k);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeTags *result = newLamTypeTags(CPI(node), node->tag, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeTags);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeTags);
    return node;
}

static LamTypeSigArgs *cpsTkLamTypeSigArgs(LamTypeSigArgs *node, CpsKont *k) {
    ENTER(cpsTkLamTypeSigArgs);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeSigArgs);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSigArgs *new_next = cpsTkLamTypeSigArgs(node->next, k);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeSigArgs *result = newLamTypeSigArgs(CPI(node), node->name, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeSigArgs);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeSigArgs);
    return node;
}

static LamTypeConstructor *cpsTkLamTypeConstructor(LamTypeConstructor *node, CpsKont *k) {
    ENTER(cpsTkLamTypeConstructor);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeConstructor);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSig *new_type = cpsTkLamTypeSig(node->type, k);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeConstructorArgs *new_args = cpsTkLamTypeConstructorArgs(node->args, k);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructor *result = newLamTypeConstructor(CPI(node), node->name, new_type, new_args);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeConstructor);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeConstructor);
    return node;
}

static LamTypeConstructorArgs *cpsTkLamTypeConstructorArgs(LamTypeConstructorArgs *node, CpsKont *k) {
    ENTER(cpsTkLamTypeConstructorArgs);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeConstructorArgs);
        return NULL;
    }

    bool changed = false;
    LamTypeConstructorType *new_arg = cpsTkLamTypeConstructorType(node->arg, k);
    int save = PROTECT(new_arg);
    changed = changed || (new_arg != node->arg);
    LamTypeConstructorArgs *new_next = cpsTkLamTypeConstructorArgs(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorArgs *result = newLamTypeConstructorArgs(CPI(node), new_arg, new_next);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeConstructorArgs);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeConstructorArgs);
    return node;
}

static LamTypeFunction *cpsTkLamTypeFunction(LamTypeFunction *node, CpsKont *k) {
    ENTER(cpsTkLamTypeFunction);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeFunction);
        return NULL;
    }

    bool changed = false;
    LamLookupOrSymbol *new_name = cpsTkLamLookupOrSymbol(node->name, k);
    int save = PROTECT(new_name);
    changed = changed || (new_name != node->name);
    LamTypeConstructorArgs *new_args = cpsTkLamTypeConstructorArgs(node->args, k);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeFunction *result = newLamTypeFunction(CPI(node), new_name, new_args);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeFunction);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeFunction);
    return node;
}

static LamTypeConstructorInfo *cpsTkLamTypeConstructorInfo(LamTypeConstructorInfo *node, CpsKont *k) {
    ENTER(cpsTkLamTypeConstructorInfo);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeConstructorInfo);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through nsid (type: int, not memory-managed)
    LamTypeConstructor *new_type = cpsTkLamTypeConstructor(node->type, k);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeTags *new_tags = cpsTkLamTypeTags(node->tags, k);
    PROTECT(new_tags);
    changed = changed || (new_tags != node->tags);
    // Pass through needsVec (type: bool, not memory-managed)
    // Pass through arity (type: int, not memory-managed)
    // Pass through size (type: int, not memory-managed)
    // Pass through index (type: int, not memory-managed)

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorInfo *result = newLamTypeConstructorInfo(CPI(node), node->name, node->nsid, new_type, new_tags, node->needsVec, node->arity, node->size, node->index);
        UNPROTECT(save);
        LEAVE(cpsTkLamTypeConstructorInfo);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeConstructorInfo);
    return node;
}

static LamAlphaEnv *cpsTkLamAlphaEnv(LamAlphaEnv *node, CpsKont *k) {
    ENTER(cpsTkLamAlphaEnv);
    if (node == NULL) {
        LEAVE(cpsTkLamAlphaEnv);
        return NULL;
    }

    bool changed = false;
    LamAlphaTable *new_alphaTable = cpsTkLamAlphaTable(node->alphaTable, k);
    int save = PROTECT(new_alphaTable);
    changed = changed || (new_alphaTable != node->alphaTable);
    LamAlphaEnv *new_next = cpsTkLamAlphaEnv(node->next, k);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);
    LamAlphaEnvArray *new_namespaces = cpsTkLamAlphaEnvArray(node->namespaces, k);
    PROTECT(new_namespaces);
    changed = changed || (new_namespaces != node->namespaces);

    if (changed) {
        // Create new node with modified fields
        LamAlphaEnv *result = newLamAlphaEnv(new_next);
        result->alphaTable = new_alphaTable;
        result->namespaces = new_namespaces;
        UNPROTECT(save);
        LEAVE(cpsTkLamAlphaEnv);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamAlphaEnv);
    return node;
}

/*
    (E.callCC_expr(e)) {
        let
            c = kToC(k);
        in
            T_c(E.callCC_expr(e), c)
    }
*/
static LamExp *cpsTkCallCC(LamExp *node, CpsKont *k) {
    ENTER(cpsTkCallCC);
    LamExp *c = kToC(CPI(node), k);
    int save = PROTECT(c);
    LamExp *result = cpsTc(node, c);
    UNPROTECT(save);
    LEAVE(cpsTkCallCC);
    return result;
}

static LamExp *cpsTkLamExp(LamExp *node, CpsKont *k) {
    ENTER(cpsTkLamExp);
    if (node == NULL) {
        LEAVE(cpsTkLamExp);
        return NULL;
    }

    if (isAexpr(node)) {
        LamExp *expr = cpsM(node);
        int save = PROTECT(expr);
        LamExp *result = INVOKE(k, expr);
        UNPROTECT(save);
        LEAVE(cpsTkLamExp);
        return result;
    }

    int save = PROTECT(NULL);
    LamExp *result = node;

    switch (node->type) {
        case LAMEXP_TYPE_AMB: {
            // LamAmb
            result = cpsTkLamAmb(getLamExp_Amb(node), k);
            break;
        }
        case LAMEXP_TYPE_APPLY: {
            // LamApply
            result = cpsTkLamApply(node, k);
            break;
        }
        case LAMEXP_TYPE_ARGS: {
            // LamArgs
            LamArgs *variant = getLamExp_Args(node);
            LamArgs *new_variant = cpsTkLamArgs(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Args(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_BACK: {
            // void_ptr
            break;
        }
        case LAMEXP_TYPE_BIGINTEGER: {
            // MaybeBigInt
            break;
        }
        case LAMEXP_TYPE_BINDINGS: {
            // LamBindings
            LamBindings *variant = getLamExp_Bindings(node);
            LamBindings *new_variant = cpsTkLamBindings(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Bindings(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_CALLCC: {
            // LamExp
            result = cpsTkCallCC(getLamExp_CallCC(node), k);
            break;
        }
        case LAMEXP_TYPE_CHARACTER: {
            // character
            break;
        }
        case LAMEXP_TYPE_COND: {
            // LamCond
            result = cpsTkLamCond(getLamExp_Cond(node), k);
            break;
        }
        case LAMEXP_TYPE_CONSTANT: {
            // LamConstant
            LamConstant *variant = getLamExp_Constant(node);
            LamConstant *new_variant = cpsTkLamConstant(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Constant(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_CONSTRUCT: {
            // LamConstruct
            result = cpsTkLamConstruct(getLamExp_Construct(node), k);
            break;
        }
        case LAMEXP_TYPE_CONSTRUCTOR: {
            // LamTypeConstructorInfo
            LamTypeConstructorInfo *variant = getLamExp_Constructor(node);
            LamTypeConstructorInfo *new_variant = cpsTkLamTypeConstructorInfo(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Constructor(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_DECONSTRUCT: {
            // LamDeconstruct
            result = cpsTkLamDeconstruct(getLamExp_Deconstruct(node), k);
            break;
        }
        case LAMEXP_TYPE_ENV: {
            // void_ptr
            break;
        }
        case LAMEXP_TYPE_ERROR: {
            // void_ptr
            break;
        }
        case LAMEXP_TYPE_IFF: {
            result = cpsTkLamIff(getLamExp_Iff(node), k);
            break;
        }
        case LAMEXP_TYPE_LAM: {
            // LamLam
            LamLam *variant = getLamExp_Lam(node);
            LamLam *new_variant = cpsTkLamLam(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Lam(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LET: {
            // LamLet
            LamLet *variant = getLamExp_Let(node);
            LamLet *new_variant = cpsTkLamLet(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Let(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LETREC: {
            // LamLetRec
            LamLetRec *variant = getLamExp_Letrec(node);
            LamLetRec *new_variant = cpsTkLamLetRec(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Letrec(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_LOOKUP: {
            // LamLookup
            LamLookup *variant = getLamExp_Lookup(node);
            LamLookup *new_variant = cpsTkLamLookup(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Lookup(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_MAKETUPLE: {
            // LamArgs
            LamArgs *variant = getLamExp_MakeTuple(node);
            LamArgs *new_variant = cpsTkLamArgs(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_MakeTuple(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_MAKEVEC: {
            // LamMakeVec
            LamMakeVec *variant = getLamExp_MakeVec(node);
            LamMakeVec *new_variant = cpsTkLamMakeVec(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_MakeVec(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_MATCH: {
            // LamMatch
            LamMatch *variant = getLamExp_Match(node);
            LamMatch *new_variant = cpsTkLamMatch(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Match(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_NAMESPACES: {
            // LamNamespaceArray
            LamNamespaceArray *variant = getLamExp_Namespaces(node);
            LamNamespaceArray *new_variant = cpsTkLamNamespaceArray(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Namespaces(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_PRIM: {
            // LamPrimApp
            LamPrimApp *variant = getLamExp_Prim(node);
            LamPrimApp *new_variant = cpsTkLamPrimApp(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Prim(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_PRINT: {
            // LamPrint
            LamPrint *variant = getLamExp_Print(node);
            LamPrint *new_variant = cpsTkLamPrint(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Print(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_SEQUENCE: {
            // LamSequence
            LamSequence *variant = getLamExp_Sequence(node);
            LamSequence *new_variant = cpsTkLamSequence(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Sequence(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_STDINT: {
            // int
            break;
        }
        case LAMEXP_TYPE_TAG: {
            // LamExp
            LamExp *variant = getLamExp_Tag(node);
            LamExp *new_variant = cpsTkLamExp(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Tag(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TUPLEINDEX: {
            // LamTupleIndex
            LamTupleIndex *variant = getLamExp_TupleIndex(node);
            LamTupleIndex *new_variant = cpsTkLamTupleIndex(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_TupleIndex(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TYPEDEFS: {
            // LamTypeDefs
            LamTypeDefs *variant = getLamExp_Typedefs(node);
            LamTypeDefs *new_variant = cpsTkLamTypeDefs(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Typedefs(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TYPEOF: {
            // LamTypeof
            LamTypeof *variant = getLamExp_TypeOf(node);
            LamTypeof *new_variant = cpsTkLamTypeof(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_TypeOf(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_VAR: {
            // HashSymbol
            break;
        }
        default:
            cant_happen("unrecognized LamExp type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamExp);
    return result;
}

static LamLookupOrSymbol *cpsTkLamLookupOrSymbol(LamLookupOrSymbol *node, CpsKont *k) {
    ENTER(cpsTkLamLookupOrSymbol);
    if (node == NULL) {
        LEAVE(cpsTkLamLookupOrSymbol);
        return NULL;
    }

    int save = PROTECT(NULL);
    LamLookupOrSymbol *result = node;

    switch (node->type) {
        case LAMLOOKUPORSYMBOL_TYPE_SYMBOL: {
            // HashSymbol
            break;
        }
        case LAMLOOKUPORSYMBOL_TYPE_LOOKUP: {
            // LamLookupSymbol
            LamLookupSymbol *variant = getLamLookupOrSymbol_Lookup(node);
            LamLookupSymbol *new_variant = cpsTkLamLookupSymbol(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamLookupOrSymbol_Lookup(CPI(node), new_variant);
            }
            break;
        }
        default:
            cant_happen("unrecognized LamLookupOrSymbol type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamLookupOrSymbol);
    return result;
}

static LamTypeConstructorType *cpsTkLamTypeConstructorType(LamTypeConstructorType *node, CpsKont *k) {
    ENTER(cpsTkLamTypeConstructorType);
    if (node == NULL) {
        LEAVE(cpsTkLamTypeConstructorType);
        return NULL;
    }

    int save = PROTECT(NULL);
    LamTypeConstructorType *result = node;

    switch (node->type) {
        case LAMTYPECONSTRUCTORTYPE_TYPE_INTEGER: {
            // void_ptr
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_CHARACTER: {
            // void_ptr
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_VAR: {
            // HashSymbol
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_FUNCTION: {
            // LamTypeFunction
            LamTypeFunction *variant = getLamTypeConstructorType_Function(node);
            LamTypeFunction *new_variant = cpsTkLamTypeFunction(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamTypeConstructorType_Function(CPI(node), new_variant);
            }
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_TUPLE: {
            // LamTypeConstructorArgs
            LamTypeConstructorArgs *variant = getLamTypeConstructorType_Tuple(node);
            LamTypeConstructorArgs *new_variant = cpsTkLamTypeConstructorArgs(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamTypeConstructorType_Tuple(CPI(node), new_variant);
            }
            break;
        }
        default:
            cant_happen("unrecognized LamTypeConstructorType type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamTypeConstructorType);
    return result;
}

static LamInfo *cpsTkLamInfo(LamInfo *node, CpsKont *k) {
    ENTER(cpsTkLamInfo);
    if (node == NULL) {
        LEAVE(cpsTkLamInfo);
        return NULL;
    }

    int save = PROTECT(NULL);
    LamInfo *result = node;

    switch (node->type) {
        case LAMINFO_TYPE_TYPECONSTRUCTORINFO: {
            // LamTypeConstructorInfo
            LamTypeConstructorInfo *variant = getLamInfo_TypeConstructorInfo(node);
            LamTypeConstructorInfo *new_variant = cpsTkLamTypeConstructorInfo(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamInfo_TypeConstructorInfo(CPI(node), new_variant);
            }
            break;
        }
        case LAMINFO_TYPE_NAMESPACEINFO: {
            // LamContext
            LamContext *variant = getLamInfo_NamespaceInfo(node);
            LamContext *new_variant = cpsTkLamContext(variant, k);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamInfo_NamespaceInfo(CPI(node), new_variant);
            }
            break;
        }
        case LAMINFO_TYPE_NSID: {
            // int
            break;
        }
        default:
            cant_happen("unrecognized LamInfo type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamInfo);
    return result;
}

static LamNamespaceArray *cpsTkLamNamespaceArray(LamNamespaceArray *node, CpsKont *k) {
    ENTER(cpsTkLamNamespaceArray);
    if (node == NULL) {
        LEAVE(cpsTkLamNamespaceArray);
        return NULL;
    }

    bool changed = false;
    LamNamespaceArray *result = newLamNamespaceArray();
    int save = PROTECT(result);

    // Iterate over all elements
    for (Index i = 0; i < node->size; i++) {
        struct LamExp * element = peeknLamNamespaceArray(node, i);
        struct LamExp * new_element = cpsTkLamExp(element, k);
        PROTECT(new_element);
        changed = changed || (new_element != element);
        pushLamNamespaceArray(result, new_element);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTkLamNamespaceArray);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamNamespaceArray);
    return node;
}

static LamAlphaEnvArray *cpsTkLamAlphaEnvArray(LamAlphaEnvArray *node, CpsKont *k) {
    ENTER(cpsTkLamAlphaEnvArray);
    if (node == NULL) {
        LEAVE(cpsTkLamAlphaEnvArray);
        return NULL;
    }

    bool changed = false;
    LamAlphaEnvArray *result = newLamAlphaEnvArray();
    int save = PROTECT(result);

    // Iterate over all elements
    for (Index i = 0; i < node->size; i++) {
        struct LamAlphaEnv * element = peeknLamAlphaEnvArray(node, i);
        struct LamAlphaEnv * new_element = cpsTkLamAlphaEnv(element, k);
        PROTECT(new_element);
        changed = changed || (new_element != element);
        pushLamAlphaEnvArray(result, new_element);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTkLamAlphaEnvArray);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTkLamAlphaEnvArray);
    return node;
}

LamExp *cpsTk(LamExp *node, CpsKont *k) {
    return cpsTkLamExp(node, k);
}
