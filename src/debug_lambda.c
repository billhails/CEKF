/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 *
 * generated from src/lambda.yaml by makeAST.py
 */

#include <stdio.h>

#include "debug_lambda.h"
#include "bigint.h"

static void pad(int depth) { fprintf(stderr, "%*s", depth * 4, ""); }

void printLamLam(struct LamLam * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamLam (NULL)"); return; }
    fprintf(stderr, "LamLam[\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->nargs);
    fprintf(stderr, "\n");
    printLamVarList(x->args, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->exp, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamVarList(struct LamVarList * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamVarList (NULL)"); return; }
    fprintf(stderr, "LamVarList[\n");
        printLambdaSymbol(x->var, depth + 1);
    fprintf(stderr, "\n");
    printLamVarList(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamPrimApp(struct LamPrimApp * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamPrimApp (NULL)"); return; }
    fprintf(stderr, "LamPrimApp[\n");
    switch (x->type) {
        case LAMPRIMOP_TYPE_LAM_PRIM_ADD:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_ADD");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_SUB:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_SUB");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_MUL:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_MUL");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_DIV:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_DIV");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_MOD:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_MOD");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_POW:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_POW");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_EQ:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_EQ");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_NE:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_NE");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_GT:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_GT");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_LT:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_LT");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_GE:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_GE");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_LE:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_LE");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_VEC:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_VEC");
            break;
        case LAMPRIMOP_TYPE_LAM_PRIM_XOR:
            pad(depth + 1);
            fprintf(stderr, "LAMPRIMOP_TYPE_LAM_PRIM_XOR");
            break;
    }
    fprintf(stderr, "\n");
    printLamExp(x->exp1, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->exp2, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamUnaryApp(struct LamUnaryApp * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamUnaryApp (NULL)"); return; }
    fprintf(stderr, "LamUnaryApp[\n");
    switch (x->type) {
        case LAMUNARYOP_TYPE_LAM_UNARY_NEG:
            pad(depth + 1);
            fprintf(stderr, "LAMUNARYOP_TYPE_LAM_UNARY_NEG");
            break;
        case LAMUNARYOP_TYPE_LAM_UNARY_NOT:
            pad(depth + 1);
            fprintf(stderr, "LAMUNARYOP_TYPE_LAM_UNARY_NOT");
            break;
        case LAMUNARYOP_TYPE_LAM_UNARY_PRINT:
            pad(depth + 1);
            fprintf(stderr, "LAMUNARYOP_TYPE_LAM_UNARY_PRINT");
            break;
    }
    fprintf(stderr, "\n");
    printLamExp(x->exp, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamSequence(struct LamSequence * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamSequence (NULL)"); return; }
    fprintf(stderr, "LamSequence[\n");
    printLamExp(x->exp, depth + 1);
    fprintf(stderr, "\n");
    printLamSequence(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamList(struct LamList * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamList (NULL)"); return; }
    fprintf(stderr, "LamList[\n");
    printLamExp(x->exp, depth + 1);
    fprintf(stderr, "\n");
    printLamList(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamApply(struct LamApply * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamApply (NULL)"); return; }
    fprintf(stderr, "LamApply[\n");
    printLamExp(x->function, depth + 1);
    fprintf(stderr, "\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->nargs);
    fprintf(stderr, "\n");
    printLamList(x->args, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamMakeVec(struct LamMakeVec * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamMakeVec (NULL)"); return; }
    fprintf(stderr, "LamMakeVec[\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->nargs);
    fprintf(stderr, "\n");
    printLamList(x->args, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamIff(struct LamIff * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamIff (NULL)"); return; }
    fprintf(stderr, "LamIff[\n");
    printLamExp(x->condition, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->consequent, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->alternative, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamCond(struct LamCond * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamCond (NULL)"); return; }
    fprintf(stderr, "LamCond[\n");
    printLamExp(x->value, depth + 1);
    fprintf(stderr, "\n");
    printLamCondCases(x->cases, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamIntCondCases(struct LamIntCondCases * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamIntCondCases (NULL)"); return; }
    fprintf(stderr, "LamIntCondCases[\n");
        printBigInt(x->constant, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->body, depth + 1);
    fprintf(stderr, "\n");
    printLamIntCondCases(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamCharCondCases(struct LamCharCondCases * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamCharCondCases (NULL)"); return; }
    fprintf(stderr, "LamCharCondCases[\n");
        pad(depth + 1);
fprintf(stderr, "char %c", x->constant);
    fprintf(stderr, "\n");
    printLamExp(x->body, depth + 1);
    fprintf(stderr, "\n");
    printLamCharCondCases(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamMatch(struct LamMatch * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamMatch (NULL)"); return; }
    fprintf(stderr, "LamMatch[\n");
    printLamExp(x->index, depth + 1);
    fprintf(stderr, "\n");
    printLamMatchList(x->cases, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamMatchList(struct LamMatchList * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamMatchList (NULL)"); return; }
    fprintf(stderr, "LamMatchList[\n");
    printLamIntList(x->matches, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->body, depth + 1);
    fprintf(stderr, "\n");
    printLamMatchList(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamIntList(struct LamIntList * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamIntList (NULL)"); return; }
    fprintf(stderr, "LamIntList[\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->item);
    fprintf(stderr, "\n");
    printLamIntList(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamLet(struct LamLet * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamLet (NULL)"); return; }
    fprintf(stderr, "LamLet[\n");
        printLambdaSymbol(x->var, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->value, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->body, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamLetRec(struct LamLetRec * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamLetRec (NULL)"); return; }
    fprintf(stderr, "LamLetRec[\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->nbindings);
    fprintf(stderr, "\n");
    printLamLetRecBindings(x->bindings, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->body, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamLetRecBindings(struct LamLetRecBindings * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamLetRecBindings (NULL)"); return; }
    fprintf(stderr, "LamLetRecBindings[\n");
        printLambdaSymbol(x->var, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->val, depth + 1);
    fprintf(stderr, "\n");
    printLamLetRecBindings(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamContext(struct LamContext * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamContext (NULL)"); return; }
    fprintf(stderr, "LamContext[\n");
        printHashTable(x->frame, depth + 1);
    fprintf(stderr, "\n");
    printLamContext(x->parent, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamAnd(struct LamAnd * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamAnd (NULL)"); return; }
    fprintf(stderr, "LamAnd[\n");
    printLamExp(x->left, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->right, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamOr(struct LamOr * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamOr (NULL)"); return; }
    fprintf(stderr, "LamOr[\n");
    printLamExp(x->left, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->right, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamAmb(struct LamAmb * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamAmb (NULL)"); return; }
    fprintf(stderr, "LamAmb[\n");
    printLamExp(x->left, depth + 1);
    fprintf(stderr, "\n");
    printLamExp(x->right, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamTypeConstructorInfo(struct LamTypeConstructorInfo * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamTypeConstructorInfo (NULL)"); return; }
    fprintf(stderr, "LamTypeConstructorInfo[\n");
        pad(depth + 1);
fprintf(stderr, "bool %d", x->vec);
    fprintf(stderr, "\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->arity);
    fprintf(stderr, "\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->size);
    fprintf(stderr, "\n");
        pad(depth + 1);
fprintf(stderr, "int %d", x->index);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamExp(struct LamExp * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamExp (NULL)"); return; }
    fprintf(stderr, "LamExp[\n");
    switch(x->type) {
        case LAMEXP_TYPE_LAM:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_LAM\n");
            printLamLam(x->val.lam, depth + 1);
            break;
        case LAMEXP_TYPE_VAR:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_VAR\n");
                        printLambdaSymbol(x->val.var, depth + 1);
            break;
        case LAMEXP_TYPE_STDINT:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_STDINT\n");
                        pad(depth + 1);
fprintf(stderr, "int %d", x->val.stdint);
            break;
        case LAMEXP_TYPE_BIGINTEGER:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_BIGINTEGER\n");
                        printBigInt(x->val.biginteger, depth + 1);
            break;
        case LAMEXP_TYPE_PRIM:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_PRIM\n");
            printLamPrimApp(x->val.prim, depth + 1);
            break;
        case LAMEXP_TYPE_UNARY:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_UNARY\n");
            printLamUnaryApp(x->val.unary, depth + 1);
            break;
        case LAMEXP_TYPE_LIST:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_LIST\n");
            printLamSequence(x->val.list, depth + 1);
            break;
        case LAMEXP_TYPE_MAKEVEC:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_MAKEVEC\n");
            printLamMakeVec(x->val.makeVec, depth + 1);
            break;
        case LAMEXP_TYPE_APPLY:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_APPLY\n");
            printLamApply(x->val.apply, depth + 1);
            break;
        case LAMEXP_TYPE_IFF:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_IFF\n");
            printLamIff(x->val.iff, depth + 1);
            break;
        case LAMEXP_TYPE_CALLCC:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_CALLCC\n");
            printLamExp(x->val.callcc, depth + 1);
            break;
        case LAMEXP_TYPE_LETREC:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_LETREC\n");
            printLamLetRec(x->val.letrec, depth + 1);
            break;
        case LAMEXP_TYPE_LET:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_LET\n");
            printLamLet(x->val.let, depth + 1);
            break;
        case LAMEXP_TYPE_MATCH:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_MATCH\n");
            printLamMatch(x->val.match, depth + 1);
            break;
        case LAMEXP_TYPE_COND:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_COND\n");
            printLamCond(x->val.cond, depth + 1);
            break;
        case LAMEXP_TYPE_AND:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_AND\n");
            printLamAnd(x->val.and, depth + 1);
            break;
        case LAMEXP_TYPE_OR:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_OR\n");
            printLamOr(x->val.or, depth + 1);
            break;
        case LAMEXP_TYPE_AMB:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_AMB\n");
            printLamAmb(x->val.amb, depth + 1);
            break;
        case LAMEXP_TYPE_CHARACTER:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_CHARACTER\n");
                        pad(depth + 1);
fprintf(stderr, "char %c", x->val.character);
            break;
        case LAMEXP_TYPE_BACK:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_BACK\n");
                        pad(depth + 1);
fprintf(stderr, "void * %p", x->val.back);
            break;
        case LAMEXP_TYPE_ERROR:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_ERROR\n");
                        pad(depth + 1);
fprintf(stderr, "void * %p", x->val.error);
            break;
        case LAMEXP_TYPE_COND_DEFAULT:
            pad(depth + 1);
            fprintf(stderr, "LAMEXP_TYPE_COND_DEFAULT\n");
                        pad(depth + 1);
fprintf(stderr, "void * %p", x->val.cond_default);
            break;
        default:
            cant_happen("unrecognised type %d in printLamExp", x->type);
    }
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printLamCondCases(struct LamCondCases * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "LamCondCases (NULL)"); return; }
    fprintf(stderr, "LamCondCases[\n");
    switch(x->type) {
        case LAMCONDCASES_TYPE_INTEGERS:
            pad(depth + 1);
            fprintf(stderr, "LAMCONDCASES_TYPE_INTEGERS\n");
            printLamIntCondCases(x->val.integers, depth + 1);
            break;
        case LAMCONDCASES_TYPE_CHARACTERS:
            pad(depth + 1);
            fprintf(stderr, "LAMCONDCASES_TYPE_CHARACTERS\n");
            printLamCharCondCases(x->val.characters, depth + 1);
            break;
        default:
            cant_happen("unrecognised type %d in printLamCondCases", x->type);
    }
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

