/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 *
 * generated from src/lambda.yaml by makeAST.py
 */

#include <stdio.h>

#include "debug_lambda.h"
#include "bigint.h"

static void pad(int depth) { eprintf("%*s", depth * 4, ""); }

void printLamLam(struct LamLam * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamLam (NULL)"); return; }
    eprintf("LamLam[\n");
        pad(depth + 1);
eprintf("int %d", x->nargs);
    eprintf("\n");
    printLamVarList(x->args, depth + 1);
    eprintf("\n");
    printLamExp(x->exp, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamVarList(struct LamVarList * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamVarList (NULL)"); return; }
    eprintf("LamVarList[\n");
        printLambdaSymbol(x->var, depth + 1);
    eprintf("\n");
    printLamVarList(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamPrimApp(struct LamPrimApp * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamPrimApp (NULL)"); return; }
    eprintf("LamPrimApp[\n");
    switch (x->type) {
        case LAMPRIMOP_TYPE_ADD:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_ADD");
            break;
        case LAMPRIMOP_TYPE_SUB:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_SUB");
            break;
        case LAMPRIMOP_TYPE_MUL:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_MUL");
            break;
        case LAMPRIMOP_TYPE_DIV:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_DIV");
            break;
        case LAMPRIMOP_TYPE_MOD:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_MOD");
            break;
        case LAMPRIMOP_TYPE_POW:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_POW");
            break;
        case LAMPRIMOP_TYPE_EQ:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_EQ");
            break;
        case LAMPRIMOP_TYPE_NE:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_NE");
            break;
        case LAMPRIMOP_TYPE_GT:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_GT");
            break;
        case LAMPRIMOP_TYPE_LT:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_LT");
            break;
        case LAMPRIMOP_TYPE_GE:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_GE");
            break;
        case LAMPRIMOP_TYPE_LE:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_LE");
            break;
        case LAMPRIMOP_TYPE_VEC:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_VEC");
            break;
        case LAMPRIMOP_TYPE_XOR:
            pad(depth + 1);
            eprintf("LAMPRIMOP_TYPE_XOR");
            break;
    }
    eprintf("\n");
    printLamExp(x->exp1, depth + 1);
    eprintf("\n");
    printLamExp(x->exp2, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamUnaryApp(struct LamUnaryApp * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamUnaryApp (NULL)"); return; }
    eprintf("LamUnaryApp[\n");
    switch (x->type) {
        case LAMUNARYOP_TYPE_NEG:
            pad(depth + 1);
            eprintf("LAMUNARYOP_TYPE_NEG");
            break;
        case LAMUNARYOP_TYPE_NOT:
            pad(depth + 1);
            eprintf("LAMUNARYOP_TYPE_NOT");
            break;
        case LAMUNARYOP_TYPE_PRINT:
            pad(depth + 1);
            eprintf("LAMUNARYOP_TYPE_PRINT");
            break;
    }
    eprintf("\n");
    printLamExp(x->exp, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamSequence(struct LamSequence * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamSequence (NULL)"); return; }
    eprintf("LamSequence[\n");
    printLamExp(x->exp, depth + 1);
    eprintf("\n");
    printLamSequence(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamList(struct LamList * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamList (NULL)"); return; }
    eprintf("LamList[\n");
    printLamExp(x->exp, depth + 1);
    eprintf("\n");
    printLamList(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamApply(struct LamApply * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamApply (NULL)"); return; }
    eprintf("LamApply[\n");
    printLamExp(x->function, depth + 1);
    eprintf("\n");
        pad(depth + 1);
eprintf("int %d", x->nargs);
    eprintf("\n");
    printLamList(x->args, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamMakeVec(struct LamMakeVec * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamMakeVec (NULL)"); return; }
    eprintf("LamMakeVec[\n");
        pad(depth + 1);
eprintf("int %d", x->nargs);
    eprintf("\n");
    printLamList(x->args, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamIff(struct LamIff * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamIff (NULL)"); return; }
    eprintf("LamIff[\n");
    printLamExp(x->condition, depth + 1);
    eprintf("\n");
    printLamExp(x->consequent, depth + 1);
    eprintf("\n");
    printLamExp(x->alternative, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamType(struct LamType * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamType (NULL)"); return; }
    eprintf("LamType[\n");
        printLambdaSymbol(x->name, depth + 1);
    eprintf("\n");
    printLamTypeArgs(x->args, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamTypeArgs(struct LamTypeArgs * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamTypeArgs (NULL)"); return; }
    eprintf("LamTypeArgs[\n");
        printLambdaSymbol(x->name, depth + 1);
    eprintf("\n");
    printLamTypeArgs(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamTypeConstructor(struct LamTypeConstructor * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamTypeConstructor (NULL)"); return; }
    eprintf("LamTypeConstructor[\n");
        printLambdaSymbol(x->name, depth + 1);
    eprintf("\n");
    printLamType(x->type, depth + 1);
    eprintf("\n");
    printLamTypeConstructorArgs(x->args, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamTypeConstructorArgs(struct LamTypeConstructorArgs * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamTypeConstructorArgs (NULL)"); return; }
    eprintf("LamTypeConstructorArgs[\n");
    printLamTypeConstructorArg(x->arg, depth + 1);
    eprintf("\n");
    printLamTypeConstructorArgs(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamTypeConstructorArg(struct LamTypeConstructorArg * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamTypeConstructorArg (NULL)"); return; }
    eprintf("LamTypeConstructorArg[\n");
    printLamTypeConstructorType(x->type, depth + 1);
    eprintf("\n");
    printLamTypeConstructorArg(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamTypeFunction(struct LamTypeFunction * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamTypeFunction (NULL)"); return; }
    eprintf("LamTypeFunction[\n");
        printLambdaSymbol(x->name, depth + 1);
    eprintf("\n");
    printLamTypeConstructorArgs(x->args, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamCond(struct LamCond * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamCond (NULL)"); return; }
    eprintf("LamCond[\n");
    printLamExp(x->value, depth + 1);
    eprintf("\n");
    printLamCondCases(x->cases, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamIntCondCases(struct LamIntCondCases * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamIntCondCases (NULL)"); return; }
    eprintf("LamIntCondCases[\n");
        printBigInt(x->constant, depth + 1);
    eprintf("\n");
    printLamExp(x->body, depth + 1);
    eprintf("\n");
    printLamIntCondCases(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamCharCondCases(struct LamCharCondCases * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamCharCondCases (NULL)"); return; }
    eprintf("LamCharCondCases[\n");
        pad(depth + 1);
eprintf("char %c", x->constant);
    eprintf("\n");
    printLamExp(x->body, depth + 1);
    eprintf("\n");
    printLamCharCondCases(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamMatch(struct LamMatch * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamMatch (NULL)"); return; }
    eprintf("LamMatch[\n");
    printLamExp(x->index, depth + 1);
    eprintf("\n");
    printLamMatchList(x->cases, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamMatchList(struct LamMatchList * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamMatchList (NULL)"); return; }
    eprintf("LamMatchList[\n");
    printLamIntList(x->matches, depth + 1);
    eprintf("\n");
    printLamExp(x->body, depth + 1);
    eprintf("\n");
    printLamMatchList(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamIntList(struct LamIntList * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamIntList (NULL)"); return; }
    eprintf("LamIntList[\n");
        pad(depth + 1);
eprintf("int %d", x->item);
    eprintf("\n");
    printLamIntList(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamLet(struct LamLet * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamLet (NULL)"); return; }
    eprintf("LamLet[\n");
        printLambdaSymbol(x->var, depth + 1);
    eprintf("\n");
    printLamExp(x->value, depth + 1);
    eprintf("\n");
    printLamExp(x->body, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamLetRec(struct LamLetRec * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamLetRec (NULL)"); return; }
    eprintf("LamLetRec[\n");
        pad(depth + 1);
eprintf("int %d", x->nbindings);
    eprintf("\n");
    printLamLetRecBindings(x->bindings, depth + 1);
    eprintf("\n");
    printLamExp(x->body, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamLetRecBindings(struct LamLetRecBindings * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamLetRecBindings (NULL)"); return; }
    eprintf("LamLetRecBindings[\n");
        printLambdaSymbol(x->var, depth + 1);
    eprintf("\n");
    printLamExp(x->val, depth + 1);
    eprintf("\n");
    printLamLetRecBindings(x->next, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamContext(struct LamContext * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamContext (NULL)"); return; }
    eprintf("LamContext[\n");
        printHashTable(x->frame, depth + 1);
    eprintf("\n");
    printLamContext(x->parent, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamAnd(struct LamAnd * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamAnd (NULL)"); return; }
    eprintf("LamAnd[\n");
    printLamExp(x->left, depth + 1);
    eprintf("\n");
    printLamExp(x->right, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamOr(struct LamOr * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamOr (NULL)"); return; }
    eprintf("LamOr[\n");
    printLamExp(x->left, depth + 1);
    eprintf("\n");
    printLamExp(x->right, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamAmb(struct LamAmb * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamAmb (NULL)"); return; }
    eprintf("LamAmb[\n");
    printLamExp(x->left, depth + 1);
    eprintf("\n");
    printLamExp(x->right, depth + 1);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamTypeConstructorInfo(struct LamTypeConstructorInfo * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamTypeConstructorInfo (NULL)"); return; }
    eprintf("LamTypeConstructorInfo[\n");
    printLamTypeConstructor(x->type, depth + 1);
    eprintf("\n");
        pad(depth + 1);
eprintf("bool %d", x->vec);
    eprintf("\n");
        pad(depth + 1);
eprintf("int %d", x->arity);
    eprintf("\n");
        pad(depth + 1);
eprintf("int %d", x->size);
    eprintf("\n");
        pad(depth + 1);
eprintf("int %d", x->index);
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamExp(struct LamExp * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamExp (NULL)"); return; }
    eprintf("LamExp[\n");
    switch(x->type) {
        case LAMEXP_TYPE_LAM:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_LAM\n");
            printLamLam(x->val.lam, depth + 1);
            break;
        case LAMEXP_TYPE_VAR:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_VAR\n");
                        printLambdaSymbol(x->val.var, depth + 1);
            break;
        case LAMEXP_TYPE_STDINT:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_STDINT\n");
                        pad(depth + 1);
eprintf("int %d", x->val.stdint);
            break;
        case LAMEXP_TYPE_BIGINTEGER:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_BIGINTEGER\n");
                        printBigInt(x->val.biginteger, depth + 1);
            break;
        case LAMEXP_TYPE_PRIM:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_PRIM\n");
            printLamPrimApp(x->val.prim, depth + 1);
            break;
        case LAMEXP_TYPE_UNARY:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_UNARY\n");
            printLamUnaryApp(x->val.unary, depth + 1);
            break;
        case LAMEXP_TYPE_LIST:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_LIST\n");
            printLamSequence(x->val.list, depth + 1);
            break;
        case LAMEXP_TYPE_MAKEVEC:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_MAKEVEC\n");
            printLamMakeVec(x->val.makeVec, depth + 1);
            break;
        case LAMEXP_TYPE_APPLY:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_APPLY\n");
            printLamApply(x->val.apply, depth + 1);
            break;
        case LAMEXP_TYPE_IFF:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_IFF\n");
            printLamIff(x->val.iff, depth + 1);
            break;
        case LAMEXP_TYPE_CALLCC:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_CALLCC\n");
            printLamExp(x->val.callcc, depth + 1);
            break;
        case LAMEXP_TYPE_LETREC:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_LETREC\n");
            printLamLetRec(x->val.letrec, depth + 1);
            break;
        case LAMEXP_TYPE_LET:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_LET\n");
            printLamLet(x->val.let, depth + 1);
            break;
        case LAMEXP_TYPE_MATCH:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_MATCH\n");
            printLamMatch(x->val.match, depth + 1);
            break;
        case LAMEXP_TYPE_COND:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_COND\n");
            printLamCond(x->val.cond, depth + 1);
            break;
        case LAMEXP_TYPE_AND:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_AND\n");
            printLamAnd(x->val.and, depth + 1);
            break;
        case LAMEXP_TYPE_OR:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_OR\n");
            printLamOr(x->val.or, depth + 1);
            break;
        case LAMEXP_TYPE_AMB:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_AMB\n");
            printLamAmb(x->val.amb, depth + 1);
            break;
        case LAMEXP_TYPE_CHARACTER:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_CHARACTER\n");
                        pad(depth + 1);
eprintf("char %c", x->val.character);
            break;
        case LAMEXP_TYPE_BACK:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_BACK\n");
                        pad(depth + 1);
eprintf("void * %p", x->val.back);
            break;
        case LAMEXP_TYPE_ERROR:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_ERROR\n");
                        pad(depth + 1);
eprintf("void * %p", x->val.error);
            break;
        case LAMEXP_TYPE_COND_DEFAULT:
            pad(depth + 1);
            eprintf("LAMEXP_TYPE_COND_DEFAULT\n");
                        pad(depth + 1);
eprintf("void * %p", x->val.cond_default);
            break;
        default:
            cant_happen("unrecognised type %d in printLamExp", x->type);
    }
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamCondCases(struct LamCondCases * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamCondCases (NULL)"); return; }
    eprintf("LamCondCases[\n");
    switch(x->type) {
        case LAMCONDCASES_TYPE_INTEGERS:
            pad(depth + 1);
            eprintf("LAMCONDCASES_TYPE_INTEGERS\n");
            printLamIntCondCases(x->val.integers, depth + 1);
            break;
        case LAMCONDCASES_TYPE_CHARACTERS:
            pad(depth + 1);
            eprintf("LAMCONDCASES_TYPE_CHARACTERS\n");
            printLamCharCondCases(x->val.characters, depth + 1);
            break;
        default:
            cant_happen("unrecognised type %d in printLamCondCases", x->type);
    }
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

void printLamTypeConstructorType(struct LamTypeConstructorType * x, int depth) {
    pad(depth);
    if (x == NULL) { eprintf("LamTypeConstructorType (NULL)"); return; }
    eprintf("LamTypeConstructorType[\n");
    switch(x->type) {
        case LAMTYPECONSTRUCTORTYPE_TYPE_INTEGER:
            pad(depth + 1);
            eprintf("LAMTYPECONSTRUCTORTYPE_TYPE_INTEGER\n");
                        pad(depth + 1);
eprintf("void * %p", x->val.integer);
            break;
        case LAMTYPECONSTRUCTORTYPE_TYPE_CHARACTER:
            pad(depth + 1);
            eprintf("LAMTYPECONSTRUCTORTYPE_TYPE_CHARACTER\n");
                        pad(depth + 1);
eprintf("void * %p", x->val.character);
            break;
        case LAMTYPECONSTRUCTORTYPE_TYPE_VAR:
            pad(depth + 1);
            eprintf("LAMTYPECONSTRUCTORTYPE_TYPE_VAR\n");
                        printLambdaSymbol(x->val.var, depth + 1);
            break;
        case LAMTYPECONSTRUCTORTYPE_TYPE_FUNCTION:
            pad(depth + 1);
            eprintf("LAMTYPECONSTRUCTORTYPE_TYPE_FUNCTION\n");
            printLamTypeFunction(x->val.function, depth + 1);
            break;
        default:
            cant_happen("unrecognised type %d in printLamTypeConstructorType", x->type);
    }
    eprintf("\n");
    pad(depth);
    eprintf("]");
}

