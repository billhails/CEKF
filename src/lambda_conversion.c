/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// conversion of the AST generated by the parser
// to an intermediate "plain" lambda calculus which
// will then be fed into the type checker and the
// A-Normal Form converter.

#include <stdio.h>
#include <stdlib.h>
#include "common.h"
#include "lambda_conversion.h"
#include "lambda_helper.h"
#include "symbols.h"
#include "tpmc_logic.h"
#include "tpmc_mermaid.h"
#include "ast_debug.h"
#include "print_generator.h"

char *lambda_conversion_function = NULL; // set by --lambda-conversion flag

static LamLetRecBindings *convertFuncDefs(AstDefinitions *definitions,
                                          LamContext *env);
static LamList *convertExpressions(AstExpressions *expressions,
                                   LamContext *env);
static LamSequence *convertSequence(AstExpressions *expressions,
                                    LamContext *env);
static LamLetRecBindings *prependDefinition(AstDefinition *definition,
                                            LamContext *env,
                                            LamLetRecBindings *next);
static LamLetRecBindings *prependDefine(AstDefine *define, LamContext *env,
                                        LamLetRecBindings *next);
static LamExp *convertExpression(AstExpression *expression, LamContext *env);
static bool typeHasFields(AstTypeBody *typeBody);
static LamTypeDefList *collectTypeDefs(AstDefinitions *definitions,
                                       LamContext *env);
static LamTypeConstructor *collectTypeConstructor(AstTypeConstructor
                                                  *typeConstructor,
                                                  LamType *type, int size,
                                                  int index, bool needsVec,
                                                  LamContext *env);
static void collectTypeInfo(HashSymbol *symbol, LamTypeConstructor *type,
                            bool needsVec, int enumCount, int index,
                            int arity, LamContext *env);
static LamTypeConstructorArgs *convertAstTypeList(AstTypeList *typeList);
static HashSymbol *dollarSubstitute(HashSymbol *original);
static LamExp *convertNest(AstNest *nest, LamContext *env);
static LamExp *lamConvertDefsNsAndExprs(AstDefinitions *definitions,
                                        AstNamespaceArray *nsArray,
                                        AstExpressions *expressions,
                                        LamContext *env);

#ifdef DEBUG_LAMBDA_CONVERT
#  include "debugging_on.h"
#else
#  include "debugging_off.h"
#endif

static bool inPreamble;  // preamble is treated specially

static void addCurrentNamespaceToContext(LamContext *context, int id) {
    LamInfo *lamInfo = newLamInfo_Namespace(COPY_PARSER_INFO(context), id);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, namespaceSymbol(), lamInfo);
    UNPROTECT(save);
}

LamExp *lamConvertProg(AstProg *prog) {
    ENTER(lamConvertProg);
    inPreamble = true;
    LamContext *env = newLamContext(COPY_PARSER_INFO(prog), NULL);
    int save = PROTECT(env);
    addCurrentNamespaceToContext(env, NS_GLOBAL);
    LamExp *result = lamConvertDefsNsAndExprs(prog->preamble, prog->namespaces, prog->body, env);
    UNPROTECT(save);
    LEAVE(lamConvertProg);
    return result;
}

static LamExp *convertNest(AstNest *nest, LamContext *env) {
    ENTER(convertNest);
    env = newLamContext(COPY_PARSER_INFO(nest), env);
    int save = PROTECT(env);
    LamExp *result = lamConvertDefsNsAndExprs(nest->definitions, NULL, nest->expressions, env);
    PROTECT(result);
    UNPROTECT(save);
    LEAVE(convertNest);
    return result;
}

static void addConstructorInfoToLamContext(LamContext *context, HashSymbol *symbol,
                         LamTypeConstructorInfo *info) {
    LamInfo *lamInfo = newLamInfo_TypeConstructorInfo(COPY_PARSER_INFO(context), info);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, symbol, lamInfo);
    UNPROTECT(save);
}

static void addNamespaceInfoToLamContext(LamContext *context, LamContext *info, Index namespace) {
    char buf[80];
    sprintf(buf, NS_FORMAT, namespace);
    HashSymbol *symbol = newSymbol(buf);
    LamInfo *lamInfo = newLamInfo_NamespaceInfo(COPY_PARSER_INFO(context), info);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, symbol, lamInfo);
    UNPROTECT(save);
}

static LamExp *lamConvertDefsNsAndExprs(AstDefinitions *definitions,
                                        AstNamespaceArray *nsArray,
                                        AstExpressions *expressions,
                                        LamContext *env) {
    ENTER(lamConvertDefsNsAndExprs);
    LamTypeDefList *typeDefList = collectTypeDefs(definitions, env);
    int save = PROTECT(typeDefList);
    LamLetRecBindings *funcDefsList = convertFuncDefs(definitions, env);
    PROTECT(funcDefsList);
    funcDefsList = makePrintFunctions(typeDefList, funcDefsList, env, inPreamble);
    PROTECT(funcDefsList);
    LamNamespaceArray *namespaces = NULL;
    if (nsArray != NULL) {
        inPreamble = false; // dodgy, we must be in the preamble because we're being called with namespaces
        namespaces = newLamNamespaceArray();
        PROTECT(namespaces);
        for (Index i = 0; i < nsArray->size; ++i) {
            AstNamespaceImpl *namespace = nsArray->entries[i];
            LamContext *nsEnv = newLamContext(COPY_PARSER_INFO(env), env);
            int save2 = PROTECT(nsEnv);
            addCurrentNamespaceToContext(env, (int) i);
            AstExpression *envToken = newAstExpression_Env(COPY_PARSER_INFO(namespace));
            PROTECT(envToken);
            AstExpressions *body = newAstExpressions(COPY_PARSER_INFO(namespace), envToken, NULL);
            PROTECT(body);
            LamExp *lamNamespace = lamConvertDefsNsAndExprs(namespace->definitions, NULL, body, nsEnv);
            PROTECT(lamNamespace);
            pushLamNamespaceArray(namespaces, lamNamespace);
            addNamespaceInfoToLamContext(env, nsEnv, i);
            UNPROTECT(save2);
        }
    }
    LamSequence *body = convertSequence(expressions, env);
    PROTECT(body);
    if (namespaces != NULL && namespaces->size > 0) {
        LamExp *lamNamespaces = newLamExp_Namespaces(COPY_PARSER_INFO(env), namespaces);
        PROTECT(lamNamespaces);
        body = newLamSequence(COPY_PARSER_INFO(env), lamNamespaces, body);
        PROTECT(body);
    }
    LamExp *letRecBody = newLamExp_List(COPY_PARSER_INFO(body), body);
    PROTECT(letRecBody);
    LamExp *result = NULL;
    if (funcDefsList != NULL) {
        LamLetRec *letRec =
            newLamLetRec(COPY_PARSER_INFO(letRecBody), countLamLetRecBindings(funcDefsList), funcDefsList,
                         letRecBody);
        PROTECT(letRec);
        result = newLamExp_Letrec(COPY_PARSER_INFO(letRec), letRec);
    } else {
        result = newLamExp_List(COPY_PARSER_INFO(body), body);
    }
    PROTECT(result);
    if (typeDefList != NULL) {
        LamTypeDefs *typeDefs = newLamTypeDefs(COPY_PARSER_INFO(typeDefList), typeDefList, result);
        PROTECT(typeDefs);
        result =
            newLamExp_Typedefs(COPY_PARSER_INFO(typeDefs), typeDefs);
    }
    UNPROTECT(save);
    LEAVE(lamConvertDefsNsAndExprs);
    return result;
}

static LamExp *lamConvertIff(AstIff *iff, LamContext *context) {
    ENTER(lamConvertIff);
    LamExp *test = convertExpression(iff->test, context);
    int save = PROTECT(test);
    LamExp *consequent = convertNest(iff->consequent, context);
    PROTECT(consequent);
    LamExp *alternative = convertNest(iff->alternative, context);
    PROTECT(alternative);
    LamIff *lamIff = newLamIff(COPY_PARSER_INFO(test), test, consequent, alternative);
    PROTECT(lamIff);
    LamExp *result = newLamExp_Iff(COPY_PARSER_INFO(test), lamIff);
    UNPROTECT(save);
    LEAVE(lamConvertIff);
    return result;
}

static LamExp *lamConvertPrint(AstPrint *print, LamContext *context) {
    ENTER(lamConvertPrint);
    LamExp *exp = convertExpression(print->exp, context);
    int save = PROTECT(exp);
    LamPrint *lamPrint = newLamPrint(COPY_PARSER_INFO(exp), exp);
    PROTECT(lamPrint);
    LamExp *result = newLamExp_Print(COPY_PARSER_INFO(lamPrint), lamPrint);
    UNPROTECT(save);
    LEAVE(lamConvertPrint);
    return result;
}

static LamExp *lamConvertTuple(AstExpressions *tuple, LamContext *env) {
    LamList *expressions = convertExpressions(tuple, env);
    int save = PROTECT(expressions);
    LamExp *res = newLamExp_Make_tuple(COPY_PARSER_INFO(expressions), expressions);
    UNPROTECT(save);
    return res;
}

static LamExp *lamConvertLookup(AstLookup *lookup, LamContext *env) {
    LamContext *nsEnv = lookupNamespaceInLamContext(env, lookup->namespace);
    LamExp *expression = convertExpression(lookup->expression, nsEnv);
    int save = PROTECT(expression);
    LamLookup *llu = newLamLookup(COPY_PARSER_INFO(lookup), lookup->namespace, lookup->name, expression);
    PROTECT(llu);
    LamExp *res = newLamExp_Lookup(COPY_PARSER_INFO(lookup), llu);
    UNPROTECT(save);
    return res;
}

static LamLetRecBindings *convertFuncDefs(AstDefinitions *definitions,
                                          LamContext *env) {
    ENTER(convertFuncDefs);
    if (definitions == NULL) {
        return NULL;
    }
    LamLetRecBindings *next = convertFuncDefs(definitions->next, env);
    int save = PROTECT(next);
    LamLetRecBindings *this =
        prependDefinition(definitions->definition, env, next);
    UNPROTECT(save);
    LEAVE(convertFuncDefs);
    return this;
}

static LamTypeArgs *convertTypeSymbols(AstTypeSymbols *symbols) {
    if (symbols == NULL)
        return NULL;
    LamTypeArgs *next = convertTypeSymbols(symbols->next);
    int save = PROTECT(next);
    LamTypeArgs *this = newLamTypeArgs(COPY_PARSER_INFO(symbols), symbols->typeSymbol, next);
    UNPROTECT(save);
    return this;
}

static LamType *convertUserType(AstUserType *userType) {
    LamTypeArgs *args = convertTypeSymbols(userType->typeSymbols);
    int save = PROTECT(args);
    LamType *res = newLamType(COPY_PARSER_INFO(userType), userType->symbol, args);
    UNPROTECT(save);
    return res;
}

static LamLookupSymbol *convertAstLookupSymbol(AstLookupSymbol *ls) {
    return newLamLookupSymbol(COPY_PARSER_INFO(ls), ls->namespace, ls->name, ls->symbol);
}

static LamLookupOrSymbol *convertAstLookupOrSymbol(AstLookupOrSymbol *los) {
    switch (los->type) {
        case AST_LOOKUPORSYMBOL_TYPE_SYMBOL:
            return newLamLookupOrSymbol_Symbol(COPY_PARSER_INFO(los), los->val.symbol);
        case AST_LOOKUPORSYMBOL_TYPE_LOOKUP:{
            LamLookupSymbol *ls = convertAstLookupSymbol(los->val.lookup);
            int save = PROTECT(ls);
            LamLookupOrSymbol *llos = newLamLookupOrSymbol_Lookup(COPY_PARSER_INFO(los), ls);
            UNPROTECT(save);
            return llos;
        }
        default:
            cant_happen("unrecognized %s", astLookupOrSymbolTypeName(los->type));
    }
}

static LamTypeFunction *convertAstTypeFunction(AstTypeFunction
                                               *astTypeFunction) {
    LamTypeConstructorArgs *lamTypeConstructorArgs =
        convertAstTypeList(astTypeFunction->typeList);
    int save = PROTECT(lamTypeConstructorArgs);
    LamLookupOrSymbol *los = convertAstLookupOrSymbol(astTypeFunction->symbol);
    PROTECT(los);
    LamTypeFunction *this = newLamTypeFunction(COPY_PARSER_INFO(los), los, lamTypeConstructorArgs);
    UNPROTECT(save);
    return this;
}

static LamTypeConstructorType *convertAstTypeClause(AstTypeClause
                                                    *astTypeClause) {
    switch (astTypeClause->type) {
        case AST_TYPECLAUSE_TYPE_INTEGER:
            return
                newLamTypeConstructorType_Integer(COPY_PARSER_INFO(astTypeClause));
            break;
        case AST_TYPECLAUSE_TYPE_CHARACTER:
            return
                newLamTypeConstructorType_Character(COPY_PARSER_INFO(astTypeClause));
            break;
        case AST_TYPECLAUSE_TYPE_VAR:
            return newLamTypeConstructorType_Var(COPY_PARSER_INFO(astTypeClause), astTypeClause->val.var);
            break;
        case AST_TYPECLAUSE_TYPE_TYPEFUNCTION:{
                LamTypeFunction *lamTypeFunction =
                    convertAstTypeFunction(astTypeClause->val.typeFunction);
                int save = PROTECT(lamTypeFunction);
                LamTypeConstructorType *this =
                    newLamTypeConstructorType_Function(COPY_PARSER_INFO(astTypeClause), lamTypeFunction);
                UNPROTECT(save);
                return this;
            }
            break;
        case AST_TYPECLAUSE_TYPE_TYPETUPLE: {
            LamTypeConstructorArgs *lamTypeConstructorArgs =
                convertAstTypeList(astTypeClause->val.typeTuple);
            int save = PROTECT(lamTypeConstructorArgs);
            LamTypeConstructorType *this =
                newLamTypeConstructorType_Tuple(COPY_PARSER_INFO(astTypeClause), lamTypeConstructorArgs);
            UNPROTECT(save);
            return this;
        }
        break;
        default:
            cant_happen
                ("unrecognised astTypeClause type %d in convertAstTypeClause",
                 astTypeClause->type);
    }
}

static LamTypeFunction *makeArrow(LamTypeConstructorType *lhs,
                                  LamTypeConstructorType *rhs) {
    LamTypeConstructorArgs *rhsArg = newLamTypeConstructorArgs(COPY_PARSER_INFO(rhs), rhs, NULL);
    int save = PROTECT(rhsArg);
    LamTypeConstructorArgs *args = newLamTypeConstructorArgs(COPY_PARSER_INFO(lhs), lhs, rhsArg);
    PROTECT(args);
    LamLookupOrSymbol *los = newLamLookupOrSymbol_Symbol(COPY_PARSER_INFO(lhs), arrowSymbol());
    PROTECT(los);
    LamTypeFunction *res = newLamTypeFunction(COPY_PARSER_INFO(lhs), los, args);
    UNPROTECT(save);
    return res;
}

static LamTypeConstructorType *convertAstType(AstType *astType) {
    if (astType->next) {        // it's a function
        LamTypeConstructorType *next = convertAstType(astType->next);
        int save = PROTECT(next);
        LamTypeConstructorType *this =
            convertAstTypeClause(astType->typeClause);
        PROTECT(this);
        LamTypeFunction *arrow = makeArrow(this, next);
        PROTECT(arrow);
        LamTypeConstructorType *res =
            newLamTypeConstructorType_Function(COPY_PARSER_INFO(astType), arrow);
        UNPROTECT(save);
        return res;
    } else {
        return convertAstTypeClause(astType->typeClause);
    }
}

static LamTypeConstructorArgs *convertAstTypeList(AstTypeList *typeList) {
    if (typeList == NULL)
        return NULL;
    LamTypeConstructorArgs *next = convertAstTypeList(typeList->next);
    int save = PROTECT(next);
    LamTypeConstructorType *arg = convertAstType(typeList->type);
    PROTECT(arg);
    LamTypeConstructorArgs *this = newLamTypeConstructorArgs(COPY_PARSER_INFO(arg), arg, next);
    UNPROTECT(save);
    return this;
}

static void collectTypeInfo(HashSymbol *symbol, LamTypeConstructor *type,
                            bool needsVec, int enumCount, int index,
                            int arity, LamContext *env) {
    ENTER(collectTypeInfo);
    int namespace = lookupCurrentNamespaceInLamContext(env);
    LamTypeConstructorInfo *info =
        newLamTypeConstructorInfo(COPY_PARSER_INFO(type), symbol, namespace, type, needsVec,
                                  arity, enumCount, index);
    int save = PROTECT(info);
    addConstructorInfoToLamContext(env, symbol, info);
    UNPROTECT(save);
    LEAVE(collectTypeInfo);
}

static LamTypeConstructor *collectTypeConstructor(AstTypeConstructor
                                                  *typeConstructor,
                                                  LamType *type,
                                                  int enumCount, int index,
                                                  bool needsVec,
                                                  LamContext *env) {
    int nargs = countAstTypeList(typeConstructor->typeList);
    LamTypeConstructorArgs *args =
        convertAstTypeList(typeConstructor->typeList);
    int save = PROTECT(args);
    LamTypeConstructor *lamTypeConstructor =
        newLamTypeConstructor(COPY_PARSER_INFO(type), typeConstructor->symbol, type, args);
    PROTECT(lamTypeConstructor);
    collectTypeInfo(typeConstructor->symbol, lamTypeConstructor, needsVec,
                    enumCount, index, nargs, env);
    UNPROTECT(save);
    return lamTypeConstructor;
}

static LamTypeDef *collectTypeDef(AstTypeDef *typeDef, LamContext *env) {
    LamType *type = convertUserType(typeDef->userType);
    int save = PROTECT(type);
    AstTypeBody *typeBody = typeDef->typeBody;
    bool needsVec = typeHasFields(typeBody);
    int enumCount = countAstTypeBody(typeBody);
    int index = 0;
    LamTypeConstructorList *lamTypeConstructorList = NULL;
    int save2 = PROTECT(type);
    while (typeBody != NULL) {
        LamTypeConstructor *lamTypeConstructor =
            collectTypeConstructor(typeBody->typeConstructor,
                                   type,
                                   enumCount,
                                   index,
                                   needsVec,
                                   env);
        int save3 = PROTECT(lamTypeConstructor);
        lamTypeConstructorList =
            newLamTypeConstructorList(COPY_PARSER_INFO(lamTypeConstructor), lamTypeConstructor,
                                      lamTypeConstructorList);
        REPLACE_PROTECT(save2, lamTypeConstructorList);
        UNPROTECT(save3);
        typeBody = typeBody->next;
        index++;
    }
    LamTypeDef *res = newLamTypeDef(COPY_PARSER_INFO(type), type, lamTypeConstructorList);
    UNPROTECT(save);
    return res;
}

static LamTypeDefList *collectTypeDefs(AstDefinitions *definitions,
                                       LamContext *env) {
    if (definitions == NULL) {
        return NULL;
    }
    if (definitions->definition->type == AST_DEFINITION_TYPE_TYPEDEF) {
        LamTypeDef *lamTypeDef =
            collectTypeDef(definitions->definition->val.typeDef, env);
        int save = PROTECT(lamTypeDef);
        LamTypeDefList *rest = collectTypeDefs(definitions->next, env);
        PROTECT(rest);
        LamTypeDefList *res = newLamTypeDefList(COPY_PARSER_INFO(lamTypeDef), lamTypeDef, rest);
        UNPROTECT(save);
        return res;
    } else {
        return collectTypeDefs(definitions->next, env);
    }
}

static LamLetRecBindings *prependDefinition(AstDefinition *definition,
                                            LamContext *env,
                                            LamLetRecBindings *next) {
    ENTER(prependDefinition);
    LamLetRecBindings *result = NULL;
    switch (definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
            result = prependDefine(definition->val.define, env, next);
            break;
        case AST_DEFINITION_TYPE_TYPEDEF:
            result = next;
            break;
        case AST_DEFINITION_TYPE_BLANK:
            result = next;
            break;
        default:
            cant_happen
                ("unrecognised definition type %s in prependDefinition",
                 astDefinitionTypeName(definition->type));
    }
    LEAVE(prependDefinition);
    return result;
}

static bool typeHasFields(AstTypeBody *typeBody) {
    ENTER(typeHasFields);
    while (typeBody != NULL) {
        if (typeBody->typeConstructor->typeList != NULL) {
            return true;
        }
        typeBody = typeBody->next;
    }
    return false;
}

static LamLetRecBindings *prependDefine(AstDefine * define, LamContext * env,
                                        LamLetRecBindings * next) {
    ENTER(prependDefine);
    bool doMermaid = (tpmc_mermaid_function != NULL
                      && strcmp(tpmc_mermaid_function,
                                define->symbol->name) == 0);
    if (doMermaid)
        tpmc_mermaid_flag = 1;
    LamExp *exp = convertExpression(define->expression, env);
    if (lambda_conversion_function != NULL && strcmp(lambda_conversion_function, define->symbol->name) == 0) {
        ppLamExp(exp);
        eprintf("\n");
    }
    if (doMermaid)
        tpmc_mermaid_flag = 0;
    int save = PROTECT(exp);
    LamLetRecBindings *this =
        newLamLetRecBindings(COPY_PARSER_INFO(define), dollarSubstitute(define->symbol), exp, next);
    UNPROTECT(save);
    LEAVE(prependDefine);
    return this;
}

static HashSymbol *dollarSubstitute(HashSymbol *symbol) {
    if (!inPreamble)
        return symbol;
    bool needs_substitution = false;
    for (char *s = symbol->name; *s != 0; s++) {
        if (*s == '_') {
            needs_substitution = true;
            break;
        }
    }
    if (needs_substitution) {
        char *buf = NEW_ARRAY(char, strlen(symbol->name) + 1);
        strcpy(buf, symbol->name);
        for (int i = 0; buf[i] != 0; i++) {
            if (buf[i] == '_') {
                buf[i] = '$';
            }
        }
        HashSymbol *replacement = newSymbol(buf);
        FREE_ARRAY(char, buf, strlen(buf) + 1);
        return replacement;
    } else {
        return symbol;
    }
}

#define CHECK_ONE_ARG(name, args) do { \
    int count = countLamList(args); \
    if (count != 1) \
        cant_happen("expected 1 arg in " #name ", got %d", count); \
} while(0)

#define CHECK_TWO_ARGS(name, args) do { \
    int count = countLamList(args); \
    if (count != 2) \
        cant_happen("expected 2 args in " #name ", got %d", count); \
} while(0)

static LamExp *makeUnaryOp(LamUnaryOp opCode, LamList *args) {
    CHECK_ONE_ARG(makeUnaryOp, args);
    LamUnaryApp *app = newLamUnaryApp(COPY_PARSER_INFO(args), opCode, args->exp);
    int save = PROTECT(app);
    LamExp *exp = newLamExp_Unary(COPY_PARSER_INFO(app), app);
    UNPROTECT(save);
    return exp;
}

static LamExp *makeCallCC(LamList *args) {
    CHECK_ONE_ARG(makeCallCC, args);
    return newLamExp_Callcc(COPY_PARSER_INFO(args), args->exp);
}

static LamExp *makeBinOp(LamPrimOp opCode, LamList *args) {
    CHECK_TWO_ARGS(makeBinOp, args);
    LamPrimApp *app = newLamPrimApp(COPY_PARSER_INFO(args), opCode, args->exp, args->next->exp);
    int save = PROTECT(app);
    LamExp *exp = newLamExp_Prim(COPY_PARSER_INFO(app), app);
    UNPROTECT(save);
    return exp;
}

static LamExp *makeLamAnd(LamList *args) {
    CHECK_TWO_ARGS(makeLamAnd, args);
    LamAnd *lamAnd = newLamAnd(COPY_PARSER_INFO(args), args->exp, args->next->exp);
    int save = PROTECT(lamAnd);
    LamExp *res = newLamExp_And(COPY_PARSER_INFO(lamAnd), lamAnd);
    UNPROTECT(save);
    return res;
}

static LamExp *makeLamOr(LamList *args) {
    CHECK_TWO_ARGS(makeLamOr, args);
    LamOr *lamOr = newLamOr(COPY_PARSER_INFO(args), args->exp, args->next->exp);
    int save = PROTECT(lamOr);
    LamExp *res = newLamExp_Or(COPY_PARSER_INFO(lamOr), lamOr);
    UNPROTECT(save);
    return res;
}

static LamExp *makeLamAmb(LamList *args) {
    CHECK_TWO_ARGS(makeLamAmb, args);
    LamAmb *lamAmb = newLamAmb(COPY_PARSER_INFO(args), args->exp, args->next->exp);
    int save = PROTECT(lamAmb);
    LamExp *res = newLamExp_Amb(COPY_PARSER_INFO(lamAmb), lamAmb);
    UNPROTECT(save);
    return res;
}

static LamExp *makePrimApp(HashSymbol *symbol, LamList *args) {
    if (symbol == putcSymbol())
        return makeUnaryOp(LAMUNARYOP_TYPE_PUTC, args);
    if (symbol == putnSymbol())
        return makeUnaryOp(LAMUNARYOP_TYPE_PUTN, args);
    if (symbol == putvSymbol())
        return makeUnaryOp(LAMUNARYOP_TYPE_PUTV, args);
    if (symbol == negSymbol())
        return makeUnaryOp(LAMUNARYOP_TYPE_NEG, args);
    if (symbol == notSymbol())
        return makeUnaryOp(LAMUNARYOP_TYPE_NOT, args);
    if (symbol == hereSymbol())
        return makeCallCC(args);
    if (symbol == thenSymbol())
        return makeLamAmb(args);
    if (symbol == andSymbol())
        return makeLamAnd(args);
    if (symbol == orSymbol())
        return makeLamOr(args);
    if (symbol == xorSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_XOR, args);
    if (symbol == eqSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_EQ, args);
    if (symbol == neSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_NE, args);
    if (symbol == gtSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_GT, args);
    if (symbol == ltSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_LT, args);
    if (symbol == geSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_GE, args);
    if (symbol == leSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_LE, args);
    if (symbol == addSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_ADD, args);
    if (symbol == subSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_SUB, args);
    if (symbol == mulSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_MUL, args);
    if (symbol == divSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_DIV, args);
    if (symbol == modSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_MOD, args);
    if (symbol == powSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_POW, args);
    if (symbol == cmpSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_CMP, args);
    return NULL;
}

static LamExp *makeConstructor(HashSymbol *symbol, LamContext *env) {
    LamTypeConstructorInfo *info = lookupConstructorInLamContext(env, symbol);
    if (info != NULL) {
        return newLamExp_Constructor(COPY_PARSER_INFO(info), info);
    }
    return NULL;
}

static LamExp *makeApplication(LamExp *fun, LamList *args) {
    LamApply *apply = newLamApply(COPY_PARSER_INFO(fun), fun, args);
    int save = PROTECT(apply);
    LamExp *result = newLamExp_Apply(COPY_PARSER_INFO(apply), apply);
    UNPROTECT(save);
    return result;
}

static LamList *varListToList(LamVarList *list) {
    if (list == NULL) return NULL;
    LamList *next = varListToList(list->next);
    int save = PROTECT(next);
    LamExp *var = newLamExp_Var(COPY_PARSER_INFO(list), list->var);
    PROTECT(var);
    LamList *this = newLamList(COPY_PARSER_INFO(var), var, next);
    UNPROTECT(save);
    return this;
}

static LamVarList *genSymVarList(ParserInfo I, int nargs) {
    if (nargs == 0) {
        return NULL;
    }
    LamVarList *rest = genSymVarList(I, nargs - 1);
    int save = PROTECT(rest);
    HashSymbol *s = genSym("$x");
    LamVarList *this = newLamVarList(I, s, rest);
    UNPROTECT(save);
    return this;
}

static int findUnderlyingArity(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_CONSTRUCTOR:
            return exp->val.constructor->arity;
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingArity(exp->val.lookup->exp);
        default:
            cant_happen("expected lookup or constructor");
    }
}

static int findUnderlyingType(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingType(exp->val.lookup->exp);
        default:
            return exp->type;
    }
}

static LamExp *findUnderlyingValue(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingValue(exp->val.lookup->exp);
        default:
            return exp;
    }
}

// (costructor4 arg1 arg2) =>
// ((lambda (x1 x2 x3 x4) (constructor4 x1 x2 x3 x4)) arg1 arg2)

static LamExp *makeConstructorApplication(LamExp *constructor, LamList *args) {
    int nargs = (int) countLamList(args);
    LamExp *result;
    int arity = findUnderlyingArity(constructor);
    if (nargs < arity) {
        LamVarList *fargs = genSymVarList(COPY_PARSER_INFO(constructor), arity);
        int save = PROTECT(fargs);
        LamList *aargs = varListToList(fargs);
        PROTECT(aargs);
        LamApply *innerApply = newLamApply(COPY_PARSER_INFO(constructor), constructor, aargs);
        PROTECT(innerApply);
        LamExp *applyExp = newLamExp_Apply(COPY_PARSER_INFO(innerApply), innerApply);
        PROTECT(applyExp);
        LamLam *lambda = newLamLam(COPY_PARSER_INFO(fargs), fargs, applyExp);
        PROTECT(lambda);
        LamExp *lamExp = newLamExp_Lam(COPY_PARSER_INFO(lambda), lambda);
        PROTECT(lamExp);
        LamApply *apply = newLamApply(COPY_PARSER_INFO(lamExp), lamExp, args);
        PROTECT(apply);
        result = newLamExp_Apply(COPY_PARSER_INFO(apply), apply);
        UNPROTECT(save);
    } else {
        LamApply *apply = newLamApply(COPY_PARSER_INFO(constructor), constructor, args);
        int save = PROTECT(apply);
        result = newLamExp_Apply(COPY_PARSER_INFO(apply), apply);
        UNPROTECT(save);
    }
    return result;
}

static LamExp *convertFunCall(AstFunCall *funCall, LamContext *env) {
    LamList *args = convertExpressions(funCall->arguments, env);
    int save = PROTECT(args);
    LamExp *function = convertExpression(funCall->function, env);
    PROTECT(function);
    LamExp *result = NULL;
    switch (findUnderlyingType(function)) {
        case LAMEXP_TYPE_VAR:{
            LamExp *symbol = findUnderlyingValue(function);
            result = makePrimApp(symbol->val.var, args);
            if (result != NULL) {
                UNPROTECT(save);
                return result;
            }
            result = makeApplication(function, args);
            UNPROTECT(save);
            return result;
        }
        case LAMEXP_TYPE_CONSTRUCTOR:{
            result = makeConstructorApplication(function, args);
            UNPROTECT(save);
            return result;
        }
        default:{
            result = makeApplication(function, args);
            UNPROTECT(save);
            return result;
        }
    }
}

static LamLam *convertCompositeBodies(int nargs, AstCompositeFunction *fun,
                                      LamContext *env) {
    ENTER(convertCompositeBodies);
    int nBodies = countAstCompositeFunction(fun);
    if (nBodies == 0) {
        can_happen("empty composite function");
        LEAVE(convertCompositeBodies);
        return NULL;
    }
    LamExp **actions = NEW_ARRAY(LamExp *, nBodies);
    AstArgList **argLists = NEW_ARRAY(AstArgList *, nBodies);
    int p = PROTECT(NULL);
    AstCompositeFunction *f = fun;
    for (int i = 0; i < nBodies; i++, f = f->next) {
        AstFunction *func = f->function;
        actions[i] = convertNest(func->nest, env);
        PROTECT(actions[i]);
        argLists[i] = func->argList;
    }
    LamLam *result = tpmcConvert(COPY_PARSER_INFO(fun), nargs, nBodies, argLists, actions, env);
    PROTECT(result);
    FREE_ARRAY(LamExp *, actions, nBodies);
    FREE_ARRAY(AstArgList *, argLists, nBodies);
    UNPROTECT(p);
    LEAVE(convertCompositeBodies);
    return result;
}

static LamExp *convertCompositeFun(AstCompositeFunction *fun, LamContext *env) {
    ENTER(convertCompositeFun);
    if (fun == NULL)
        cant_happen("composite function with no components");
    int nargs = countAstArgList(fun->function->argList);
    LamLam *lambda = convertCompositeBodies(nargs, fun, env);
    DEBUG("convertCompositeBodies returned %p", lambda);
    int save = PROTECT(lambda);
    LamExp *result = newLamExp_Lam(COPY_PARSER_INFO(lambda), lambda);
    UNPROTECT(save);
    LEAVE(convertCompositeFun);
    return result;
}

static LamExp *convertSymbol(ParserInfo I, HashSymbol *symbol, LamContext *env) {
    ENTER(convertSymbol);
    DEBUG("convertSymbol %s", symbol->name);
    LamExp *result = makeConstructor(symbol, env);
    if (result == NULL) {
        symbol = dollarSubstitute(symbol);
        result = newLamExp_Var(I, symbol);
    }
    LEAVE(convertSymbol);
    return result;
}

static LamExp *convertExpression(AstExpression *expression, LamContext *env) {
    ENTER(convertExpression);
    LamExp *result = NULL;
    switch (expression->type) {
        case AST_EXPRESSION_TYPE_BACK:
            DEBUG("back");
            result = newLamExp_Back(COPY_PARSER_INFO(expression));
            break;
        case AST_EXPRESSION_TYPE_FUNCALL:
            DEBUG("funcall");
            result = convertFunCall(expression->val.funCall, env);
            break;
        case AST_EXPRESSION_TYPE_SYMBOL:
            DEBUG("symbol");
            result = convertSymbol(COPY_PARSER_INFO(expression), expression->val.symbol, env);
            break;
        case AST_EXPRESSION_TYPE_NUMBER:
            DEBUG("number");
            result =
                newLamExp_Biginteger(COPY_PARSER_INFO(expression), expression->val.number);
            break;
        case AST_EXPRESSION_TYPE_CHARACTER:
            DEBUG("character");
            result =
                newLamExp_Character(COPY_PARSER_INFO(expression), expression->val.character);
            break;
        case AST_EXPRESSION_TYPE_ENV:
            DEBUG("env");
            result =
                newLamExp_Env(COPY_PARSER_INFO(expression));
            break;
        case AST_EXPRESSION_TYPE_FUN:
            DEBUG("fun");
            result = convertCompositeFun(expression->val.fun, env);
            break;
        case AST_EXPRESSION_TYPE_NEST:
            DEBUG("nest");
            result = convertNest(expression->val.nest, env);
            break;
        case AST_EXPRESSION_TYPE_IFF:
            DEBUG("iff");
            result = lamConvertIff(expression->val.iff, env);
            break;
        case AST_EXPRESSION_TYPE_PRINT:
            DEBUG("print");
            result = lamConvertPrint(expression->val.print, env);
            break;
        case AST_EXPRESSION_TYPE_TUPLE:
            DEBUG("tuple");
            result = lamConvertTuple(expression->val.tuple, env);
            break;
        case AST_EXPRESSION_TYPE_LOOKUP:
            DEBUG("lookup");
            result = lamConvertLookup(expression->val.lookup, env);
            break;
        default:
            cant_happen
                ("unrecognised expression type %s",
                 astExpressionTypeName(expression->type));
    }
    LEAVE(convertExpression);
    return result;
}

static LamList *convertExpressions(AstExpressions *expressions,
                                   LamContext *env) {
    if (expressions == NULL)
        return NULL;
    LamList *next = convertExpressions(expressions->next, env);
    int save = PROTECT(next);
    LamExp *exp = convertExpression(expressions->expression, env);
    (void) PROTECT(exp);
    LamList *this = newLamList(COPY_PARSER_INFO(exp), exp, next);
    UNPROTECT(save);
    return this;
}

static LamSequence *convertSequence(AstExpressions *expressions,
                                    LamContext *env) {
    if (expressions == NULL)
        return NULL;
    LamSequence *next = convertSequence(expressions->next, env);
    int save = PROTECT(next);
    LamExp *exp = convertExpression(expressions->expression, env);
    (void) PROTECT(exp);
    LamSequence *this = newLamSequence(COPY_PARSER_INFO(exp), exp, next);
    UNPROTECT(save);
    return this;
}
