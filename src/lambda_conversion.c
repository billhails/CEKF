/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// conversion of the AST generated by the parser, after desugaring and
// static analysis, to an intermediate "plain" lambda calculus which
// will then be fed into the A-Normal converter.

#include <stdio.h>
#include <stdlib.h>
#include "common.h"
#include "lambda_conversion.h"
#include "lambda_helper.h"
#include "symbol.h"
#include "tpmc_logic.h"
#include "debug_ast.h"

#define ARG_CATEGORY_VAR 0
#define ARG_CATEGORY_CONST 1
#define ARG_CATEGORY_STRUCT 2
#define ARG_CATEGORY_ENV 3

#define SAFE_MALLOC(thing) ((thing *)safe_malloc(sizeof(thing)))

static LamLetRecBindings *convertLetrecBindings(AstDefinitions *definitions, LamContext *env);
static LamSequence *convertExpressions(AstExpressions *expressions, LamContext *env);
static int countLetRecBindings(LamLetRecBindings *b);
static LamLetRecBindings *prependDefinition(AstDefinition *definition, LamContext *env, LamLetRecBindings *next);
static LamLetRecBindings *prependDefine(AstDefine *define, LamContext *env, LamLetRecBindings *next);
static LamLetRecBindings *prependTypeDef(AstTypeDef *typeDef, LamLetRecBindings *next, LamContext *env);
static LamExp *convertExpression(AstExpression *expression, LamContext *env);
static LamLetRecBindings *prependTypeConstructor(AstTypeConstructor *typeConstructor, int size, int index, bool hasFields, LamLetRecBindings *next, LamContext *env);
static bool typeHasFields(AstTypeBody *typeBody);
static void collectTypeDefs(AstDefinitions *definitions, LamContext *env);
static void collectTypeConstructor(AstTypeConstructor *typeConstructor, int size, int index, bool hasFields, LamContext *env);

#ifdef DEBUG_LAMBDA_CONVERT
static int invocationId = 0;
#define ENTER(name) \
int myId = invocationId++; \
fprintf(stderr, "enter " #name " %d\n", myId);
#define LEAVE(name) \
fprintf(stderr, "leave " #name " %d\n", myId);
#else
#define ENTER(n)
#define LEAVE(n)
#endif

#define MAKE_COUNT_LIST(type)           \
static int count ## type (type *list) { \
    ENTER(count ## type)                \
    int count = 0;                      \
    while (list != NULL) {              \
        count++;                        \
        list = list->next;              \
    }                                   \
    LEAVE(count ## type)                \
    return count;                       \
}

MAKE_COUNT_LIST(LamLetRecBindings)

MAKE_COUNT_LIST(AstTypeList)

MAKE_COUNT_LIST(AstExpressions)

MAKE_COUNT_LIST(AstArgList)

MAKE_COUNT_LIST(AstCompositeFunction)

LamExp *lamConvertNest(AstNest *nest, LamContext *env) {
    ENTER(lamConvertNest)
    LamContext *ext = extendLamContext(env);
    int save = PROTECT(ext);
    LamLetRecBindings *bindings = convertLetrecBindings(nest->definitions, ext);
    (void) PROTECT(bindings);
    LamSequence *body = convertExpressions(nest->expressions, ext);
    (void) PROTECT(body);
    LamExp *letRecBody = newLamExp(LAMEXP_TYPE_LIST, LAMEXP_VAL_LIST(body));
    (void) PROTECT(letRecBody);

    LamExp *result = NULL;
    if (bindings) {
        LamLetRec *letRec = newLamLetRec(countLamLetRecBindings(bindings), bindings, letRecBody);
        (void) PROTECT(letRec);
        result = newLamExp(LAMEXP_TYPE_LETREC, LAMEXP_VAL_LETREC(letRec));
    } else {
        result = newLamExp(LAMEXP_TYPE_LIST, LAMEXP_VAL_LIST(body));
    }
    UNPROTECT(save);
    LEAVE(lamConvertNest)
    return result;
}

static HashSymbol *performVarSubstitutions(HashSymbol *var, HashTable *substitutions);

static LamVarList *performVarListSubstitutions(LamVarList *varList, HashTable *substitutions) {
    if (varList == NULL) {
        return NULL;
    }
    varList->next = performVarListSubstitutions(varList->next, substitutions);
    varList->var = performVarSubstitutions(varList->var, substitutions);
    return varList;
}

static LamLam *performLamSubstitutions(LamLam *lam, HashTable *substitutions) {
    lam->args = performVarListSubstitutions(lam->args, substitutions);
    lam->exp = lamPerformSubstitutions(lam->exp, substitutions);
    return lam;
}

static HashSymbol *performVarSubstitutions(HashSymbol *var, HashTable *substitutions) {
    HashSymbol *replacement = NULL;
    if (hashGet(substitutions, var, &replacement)) {
        return replacement;
    }
    return var;
}

static LamPrimApp *performPrimSubstitutions(LamPrimApp *prim, HashTable *substitutions) {
    prim->exp1 = lamPerformSubstitutions(prim->exp1, substitutions);
    prim->exp2 = lamPerformSubstitutions(prim->exp2, substitutions);
    return prim;
}

static LamUnaryApp *performUnarySubstitutions(LamUnaryApp *unary, HashTable *substitutions) {
    unary->exp = lamPerformSubstitutions(unary->exp, substitutions);
    return unary;
}

static LamSequence *performListSubstitutions(LamSequence *list, HashTable *substitutions) {
    if (list == NULL) {
        return NULL;
    }
    list->next = performListSubstitutions(list->next, substitutions);
    list->exp = lamPerformSubstitutions(list->exp, substitutions);
    return list;
}

static LamMakeVec *performMakeVecSubstitutions(LamMakeVec *makeVec, HashTable *substitutions) {
    makeVec->args = performListSubstitutions(makeVec->args, substitutions);
    return makeVec;
}

static LamApply *performApplySubstitutions(LamApply *apply, HashTable *substitutions) {
    apply->function = lamPerformSubstitutions(apply->function, substitutions);
    apply->args = performListSubstitutions(apply->args, substitutions);
    return apply;
}

static LamIff *performIffSubstitutions(LamIff *iff, HashTable *substitutions) {
    iff->condition = lamPerformSubstitutions(iff->condition, substitutions);
    iff->consequent = lamPerformSubstitutions(iff->consequent, substitutions);
    iff->alternative = lamPerformSubstitutions(iff->alternative, substitutions);
    return iff;
}

static LamLetRecBindings *performBindingsSubstitutions(LamLetRecBindings *bindings, HashTable *substitutions) {
    if (bindings == NULL) {
        return NULL;
    }
    bindings->next = performBindingsSubstitutions(bindings->next, substitutions);
    bindings->var = performVarSubstitutions(bindings->var, substitutions);
    bindings->val = lamPerformSubstitutions(bindings->val, substitutions);
    return bindings;
}

static LamLetRec *performLetRecSubstitutions(LamLetRec *letrec, HashTable *substitutions) {
    letrec->bindings = performBindingsSubstitutions(letrec->bindings, substitutions);
    letrec->body = lamPerformSubstitutions(letrec->body, substitutions);
    return letrec;
}

static LamMatchList *performCaseSubstitutions(LamMatchList *cases, HashTable *substitutions) {
    if (cases == NULL) {
        return NULL;
    }
    cases->next = performCaseSubstitutions(cases->next, substitutions);
    cases->body = lamPerformSubstitutions(cases->body, substitutions);
    return cases;
}

static LamMatch *performMatchSubstitutions(LamMatch *match, HashTable *substitutions) {
    match->index = lamPerformSubstitutions(match->index, substitutions);
    match->cases = performCaseSubstitutions(match->cases, substitutions);
    return match;
}

static LamCondCases *performCondCaseSubstitutions(LamCondCases *cases, HashTable *substitutions) {
    if (cases == NULL) {
        return NULL;
    }
    cases->constant = lamPerformSubstitutions(cases->constant, substitutions); // shouldn't be necessary but ...
    cases->body = lamPerformSubstitutions(cases->body, substitutions);
    cases->next = performCondCaseSubstitutions(cases->next, substitutions);
    return cases;
}

static LamCond *performCondSubstitutions(LamCond *cond, HashTable *substitutions) {
    cond->value = lamPerformSubstitutions(cond->value, substitutions);
    cond->cases = performCondCaseSubstitutions(cond->cases, substitutions);
    return cond;
}

LamExp *lamPerformSubstitutions(LamExp *exp, HashTable *substitutions) {
    switch (exp->type) {
        case LAMEXP_TYPE_INTEGER:
        case LAMEXP_TYPE_CHARACTER:
        case LAMEXP_TYPE_BACK:
            break;
        case LAMEXP_TYPE_LAM:
            exp->val.lam = performLamSubstitutions(exp->val.lam, substitutions);
            break;
        case LAMEXP_TYPE_VAR:
            exp->val.var = performVarSubstitutions(exp->val.var, substitutions);
            break;
        case LAMEXP_TYPE_PRIM:
            exp->val.prim = performPrimSubstitutions(exp->val.prim, substitutions);
            break;
        case LAMEXP_TYPE_UNARY:
            exp->val.unary = performUnarySubstitutions(exp->val.unary, substitutions);
            break;
        case LAMEXP_TYPE_LIST:
            exp->val.list = performListSubstitutions(exp->val.list, substitutions);
            break;
        case LAMEXP_TYPE_MAKEVEC:
            exp->val.makeVec = performMakeVecSubstitutions(exp->val.makeVec, substitutions);
            break;
        case LAMEXP_TYPE_APPLY:
            exp->val.apply = performApplySubstitutions(exp->val.apply, substitutions);
            break;
        case LAMEXP_TYPE_IFF:
            exp->val.iff = performIffSubstitutions(exp->val.iff, substitutions);
            break;
        case LAMEXP_TYPE_COND:
            exp->val.cond = performCondSubstitutions(exp->val.cond, substitutions);
            break;
        case LAMEXP_TYPE_CALLCC:
            exp->val.callcc = lamPerformSubstitutions(exp->val.callcc, substitutions);
            break;
        case LAMEXP_TYPE_LETREC:
            exp->val.letrec = performLetRecSubstitutions(exp->val.letrec, substitutions);
            break;
        case LAMEXP_TYPE_MATCH:
            exp->val.match = performMatchSubstitutions(exp->val.match, substitutions);
            break;
        default:
            cant_happen("unrecognized LamExp type (%d) in lamPerformSubstitutions", exp->type);
    }
    return exp;
}

static LamLetRecBindings *convertFuncDefs(AstDefinitions *definitions, LamContext *env) {
    if (definitions == NULL) {
        return NULL;
    }
    LamLetRecBindings *next = convertFuncDefs(definitions->next, env);
    int save = PROTECT(next);
    LamLetRecBindings *this = prependDefinition(definitions->definition, env, next);
    UNPROTECT(save);
    return this;
}
 
static LamLetRecBindings *convertLetrecBindings(AstDefinitions *definitions, LamContext *env) {
    ENTER(convertLetrecBindings)
    if (definitions == NULL) {
        LEAVE(convertLetrecBindings)
        return NULL;
    }
    collectTypeDefs(definitions, env);
    LamLetRecBindings *funcDefs = convertFuncDefs(definitions, env);
    LEAVE(convertLetrecBindings)
    return funcDefs;
}

static int countTypeBodies(AstTypeBody *typeBody) {
    int count = 0;
    while (typeBody != NULL) {
        count++;
        typeBody = typeBody->next;
    }
    return count;
}

static void collectTypeDef(AstDefinition *definition, LamContext *env) {
    if (definition->type == AST_DEFINITION_TYPE_TYPEDEF) {
        AstTypeDef *typeDef = definition->val.typeDef;
        AstTypeBody *typeBody = typeDef->typeBody;
        bool hasFields = typeHasFields(typeBody);
        int size = countTypeBodies(typeBody);
        int index = 0;
        while (typeBody != NULL) {
            collectTypeConstructor(typeBody->typeConstructor, size, index, hasFields, env);
            typeBody = typeBody->next;
            index++;
        }
    }
}

static void collectTypeDefs(AstDefinitions *definitions, LamContext *env) {
    if (definitions == NULL) {
        return;
    }
    collectTypeDef(definitions->definition, env);
    collectTypeDefs(definitions->next, env);
}

static LamLetRecBindings *prependDefinition(AstDefinition *definition, LamContext *env, LamLetRecBindings *next) {
    ENTER(prependDefinition)
    LamLetRecBindings *result = NULL;
    switch (definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
            result = prependDefine(definition->val.define, env, next);
            break;
        case AST_DEFINITION_TYPE_TYPEDEF:
            result = next;
            break;
        default:
            cant_happen("unrecognised definition type %d in prependDefinition", definition->type);
    }
    LEAVE(prependDefinition)
    return result;
}

static bool typeHasFields(AstTypeBody *typeBody) {
    ENTER(typeHasFields)
    while (typeBody != NULL) {
        if (typeBody->typeConstructor->typeList != NULL) {
            return true;
        }
        typeBody = typeBody->next;
    }
    return false;
}


static void collectTypeInfo(HashSymbol *symbol, bool vec, int size, int index, int arity, LamContext *env) {
    ENTER(collectTypeInfo)
    LamTypeConstructorInfo *info = newLamTypeConstructorInfo(vec, arity, size, index);
    int save = PROTECT(info);
    addToLamContext(env, symbol, info);
    UNPROTECT(save);
    LEAVE(collectTypeInfo)
}

static LamVarList *genLamVarList(int nargs) {
    if (nargs == 0) return NULL;
    LamVarList *next = genLamVarList(nargs - 1);
    int save = PROTECT(next);
    LamVarList *this = newLamVarList(genSym("$var"), next);
    UNPROTECT(save);
    return this;
}

static LamSequence *varListToLamList(LamVarList *varList) {
    if (varList == NULL) return NULL;
    LamSequence *next = varListToLamList(varList->next);
    int save = PROTECT(next);
    LamExp *exp = newLamExp(LAMEXP_TYPE_VAR, LAMEXP_VAL_VAR(varList->var));
    (void) PROTECT(exp);
    LamSequence *this = newLamSequence(exp, next);
    UNPROTECT(save);
    return this;
}

static LamExp *makeMakeVec(int nargs, int index, LamSequence *args) {
    LamExp *indexExp = newLamExp(LAMEXP_TYPE_INTEGER, LAMEXP_VAL_INTEGER(index));
    int save = PROTECT(indexExp);
    args = newLamSequence(indexExp, args);
    (void) PROTECT(args);
    LamMakeVec *makeVec = newLamMakeVec(nargs + 1, args);
    (void) PROTECT(makeVec);
    LamExp *exp = newLamExp(LAMEXP_TYPE_MAKEVEC, LAMEXP_VAL_MAKEVEC(makeVec));
    UNPROTECT(save);
    return exp;
}

static LamExp *makeTypeConstructor(int index, int nargs) {
    LamVarList *varList = genLamVarList(nargs);
    int save = PROTECT(varList);
    LamSequence *args = varListToLamList(varList);
    (void) PROTECT(args);
    LamExp *exp = makeMakeVec(nargs, index, args);
    (void) PROTECT(exp);
    LamLam *lambda = newLamLam(nargs, varList, exp);
    (void) PROTECT(lambda);
    LamExp *result = newLamExp(LAMEXP_TYPE_LAM, LAMEXP_VAL_LAM(lambda));
    UNPROTECT(save);
    return result;
}

static LamExp *analyzeTypeConstructor(AstTypeConstructor *typeConstructor, int size, int index, bool someoneHasFields, LamContext *env) {
    ENTER(analyzeTypeConstructor)
    int nargs = countAstTypeList(typeConstructor->typeList);
    // we collect info about the type constructor regardless
    collectTypeInfo(typeConstructor->symbol, someoneHasFields, size, index, nargs, env);
    LamExp *exp = NULL;
    if (nargs > 0) {
        // if this type constructor has args, then we have to create a function
        // that can be called (and curried) but in the simple case the type info
        // will allow us to inline the constructor when encountered in an expression
        exp = makeTypeConstructor(index, nargs);
    } else {
        // otherwise we can treat it as a constant enum
        if (someoneHasFields) {
            // if another constructor for this type has args, then we must create a
            // constant vector, to be consistent with other instances of this type
            exp = makeMakeVec(0, index, NULL);
        } else {
            // if none of the constructors for this type take arguments, then we can
            // treat it as a simple integer enumeration along with the others
            exp = newLamExp(LAMEXP_TYPE_INTEGER, LAMEXP_VAL_INTEGER(index));
        }
    }
    LEAVE(analyzeTypeConstructor)
    return exp;
}

static void collectTypeConstructor(AstTypeConstructor *typeConstructor, int size, int index, bool hasFields, LamContext *env) {
    int nargs = countAstTypeList(typeConstructor->typeList);
    // we collect info about the type constructor regardless
    collectTypeInfo(typeConstructor->symbol, hasFields, size, index, nargs, env);
}

static LamLetRecBindings *prependTypeConstructor(AstTypeConstructor *typeConstructor, int size, int index, bool hasFields, LamLetRecBindings *next, LamContext *env) {
    ENTER(prependTypeConstructor)
    LamExp *exp = analyzeTypeConstructor(typeConstructor, size, index, hasFields, env);
    if (exp != NULL) {
        int save = PROTECT(exp);
        LamLetRecBindings *current = newLamLetRecBindings(typeConstructor->symbol, exp, next);
        UNPROTECT(save);
        LEAVE(prependTypeConstructor)
        return current;
    } else {
        LEAVE(prependTypeConstructor)
        return next;
    }
}

static LamLetRecBindings *prependDefine(AstDefine *define, LamContext *env, LamLetRecBindings *next) {
    ENTER(prependDefine)
    LamExp *exp = convertExpression(define->expression, env);
    int save = PROTECT(exp);
    LamLetRecBindings *this = newLamLetRecBindings(define->symbol, exp, next);
    UNPROTECT(save);
    LEAVE(prependDefine)
    return this;
}

static LamExp * convertFunCall(AstFunCall *funCall, LamContext *env) {
    AstExpression *function = funCall->function;
    LamSequence *args = convertExpressions(funCall->arguments, env);
    int actualNargs = countAstExpressions(funCall->arguments);
    int save = PROTECT(args);
    // see if it's a type constructor we can inline
    if (function->type == AST_EXPRESSION_TYPE_SYMBOL) {
        HashSymbol *symbol = function->val.symbol;
        LamTypeConstructorInfo *info = lookupInLamContext(env, symbol);
        if (info != NULL) {
            if (info->vec) {
                if (actualNargs == info->arity) {
                    LamExp *inLine = makeMakeVec(info->arity, info->index, args);
                    UNPROTECT(save);
                    return inLine;
                } else {
                    cant_happen("wrong number of arguments to constructor %s", symbol->name);
                }
            } else {
                cant_happen("arguments to empty constructor %s", symbol->name);
            }
        }
    }
    // otherwise we convert as normal
    LamExp *fun = convertExpression(function, env);
    (void) PROTECT(fun);
    LamApply *apply = newLamApply(fun, actualNargs, args);
    (void) PROTECT(apply);
    LamExp *result = newLamExp(LAMEXP_TYPE_APPLY, LAMEXP_VAL_APPLY(apply));
    UNPROTECT(save);
    return result;
}

/*******************************************/

static int categorizeArg(AstArg *arg, LamContext *env) {
    switch (arg->type) {
        case AST_ARG_TYPE_WILDCARD: {
            return ARG_CATEGORY_VAR;
        }
        break;
        case AST_ARG_TYPE_SYMBOL: {
            LamTypeConstructorInfo *info = lookupInLamContext(env, arg->val.symbol);
            if (info != NULL) {
                return ARG_CATEGORY_STRUCT;
            }
            return ARG_CATEGORY_VAR;
        }
        break;
        case AST_ARG_TYPE_NAMED: {
            return categorizeArg(arg->val.named->arg, env);
        }
        break;
        case AST_ARG_TYPE_ENV: {
            return ARG_CATEGORY_ENV;
        }
        break;
        case AST_ARG_TYPE_UNPACK: {
            return ARG_CATEGORY_STRUCT;
        }
        break;
        case AST_ARG_TYPE_NUMBER: {
            return ARG_CATEGORY_CONST;
        }
        break;
        case AST_ARG_TYPE_CHARACTER: {
            return ARG_CATEGORY_CONST;
        }
        break;
        default:
            cant_happen("unrecognised arg type %d in categorizeArg", arg->type);
    }
}

static void *safe_malloc(size_t size) {
    void *ptr = malloc(size);
    if (ptr == NULL) {
        perror("malloc");
        exit(1);
    }
    return ptr;
}

static LamLam *convertCompositeBodies(int nargs, AstCompositeFunction *fun, LamContext *env) {
    int nBodies = countAstCompositeFunction(fun);
    if (nBodies == 0) {
        can_happen("empty composite function");
        return NULL;
    }
    LamExp **actions = NEW_ARRAY(LamExp *, nBodies);
    AstArgList **argLists = NEW_ARRAY(AstArgList *, nBodies);
    int p = PROTECT(NULL);
    AstCompositeFunction *f = fun;
    for (int i = 0; i < nBodies; i++, f = f->next) {
        AstFunction *func = f->function;
        actions[i] = lamConvertNest(func->nest, env);
        PROTECT(actions[i]);
        argLists[i] = func->argList;
    }
    LamLam *result = tpmcConvert(nargs, nBodies, argLists, actions, env);
    FREE_ARRAY(LamExp*, actions, nBodies);
    FREE_ARRAY(AstArgList*, argLists, nBodies);
    UNPROTECT(p);
    return result;
}

/*******************************************/

static LamExp * convertCompositeFun(AstCompositeFunction *fun, LamContext *env) {
    if (fun == NULL) cant_happen("composite function with no components");
    int nargs = countAstArgList(fun->function->argList);
    LamLam *lambda = convertCompositeBodies(nargs, fun, env);
    int save = PROTECT(lambda);
    LamExp *result = newLamExp(LAMEXP_TYPE_LAM, LAMEXP_VAL_LAM(lambda));
    UNPROTECT(save);
    return result;
}

static LamExp *convertSymbol(HashSymbol *symbol, LamContext *env) {
    LamTypeConstructorInfo *info = lookupInLamContext(env, symbol);
    if (info == NULL) {
#ifdef DEBUG_LAMBDA_CONVERT
        printf("convertSymbol %s is not a constructor\n", symbol->name);
#endif
        return newLamExp(LAMEXP_TYPE_VAR, LAMEXP_VAL_VAR(symbol));
    }
#ifdef DEBUG_LAMBDA_CONVERT
    printf("convertSymbol %s is a constructor\n", symbol->name);
#endif
    if (info->vec) {
        if (info->arity > 0) {
            cant_happen("too few arguments to constructor %s", symbol->name);
        }
        return makeMakeVec(0, info->index, NULL);
    } else {
        return newLamExp(LAMEXP_TYPE_INTEGER, LAMEXP_VAL_INTEGER(info->index));
    }
}

static LamExp *convertExpression(AstExpression *expression, LamContext *env) {
    ENTER(convertExpression)
    LamExp *result = NULL;
    switch (expression->type) {
        case AST_EXPRESSION_TYPE_BACK:
            result = newLamExp(LAMEXP_TYPE_BACK, LAMEXP_VAL_BACK());
            break;
        case AST_EXPRESSION_TYPE_FUNCALL:
            result = convertFunCall(expression->val.funCall, env);
            break;
        case AST_EXPRESSION_TYPE_SYMBOL:
            result = convertSymbol(expression->val.symbol, env);
            break;
        case AST_EXPRESSION_TYPE_NUMBER:
            result = newLamExp(LAMEXP_TYPE_INTEGER, LAMEXP_VAL_INTEGER(expression->val.number));
            break;
        case AST_EXPRESSION_TYPE_CHARACTER:
            result = newLamExp(LAMEXP_TYPE_CHARACTER, LAMEXP_VAL_CHARACTER(expression->val.character));
            break;
        case AST_EXPRESSION_TYPE_FUN:
            result = convertCompositeFun(expression->val.fun, env);
            break;
        case AST_EXPRESSION_TYPE_NEST:
            result = lamConvertNest(expression->val.nest, env);
            break;
        default:
            cant_happen("unrecognised expression type %d in convertExpression", expression->type);
    }
    LEAVE(convertExpression)
    return result;
}

static LamSequence *convertExpressions(AstExpressions *expressions, LamContext *env) {
    if (expressions == NULL) return NULL;
    LamSequence *next = convertExpressions(expressions->next, env);
    int save = PROTECT(next);
    LamExp *exp = convertExpression(expressions->expression, env);
    (void) PROTECT(exp);
    LamSequence *this = newLamSequence(exp, next);
    UNPROTECT(save);
    return this;
}

