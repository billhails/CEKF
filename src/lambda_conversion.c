/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// conversion of the AST generated by the parser
// to an intermediate "plain" lambda calculus which
// will then be fed into the type checker and the
// A-Normal Form converter.

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "common.h"
#include "lambda_conversion.h"
#include "macro_substitution.h"
#include "lambda_helper.h"
#include "symbols.h"
#include "tpmc_logic.h"
#include "tpmc_mermaid.h"
#include "ast_debug.h"
#include "print_generator.h"

char *lambda_conversion_function = NULL; // set by --lambda-conversion flag

static LamLetRecBindings *convertFuncDefs(AstDefinitions *, LamContext *);
static LamList *convertExpressions(AstExpressions *, LamContext *);
static LamSequence *convertSequence(AstExpressions *, LamContext *);
static LamLetRecBindings *prependDefinition(AstDefinition *, LamContext *, LamLetRecBindings *);
static LamLetRecBindings *prependDefine(AstDefine *, LamContext *, LamLetRecBindings *);
static LamExp *convertExpression(AstExpression *, LamContext *);
static bool typeHasFields(AstTypeBody *);
static LamTypeDefList *collectTypeDefs(AstDefinitions *, LamContext *);
static void collectAliases(AstDefinitions *, LamContext *);
static LamTypeConstructor *collectTypeConstructor(AstTypeConstructor *, LamType *, int, int, bool, LamContext *);
static void collectTypeInfo(HashSymbol *, AstTypeConstructorArgs *, LamTypeConstructor *, bool, int, int, int, LamContext *);
static LamTypeConstructorArgs *convertAstTypeList(AstTypeList *, LamContext *);
static LamTypeConstructorArgs *convertAstTypeMap(AstTypeMap *, LamContext *);
static LamTypeConstructorArgs *convertAstTypeConstructorArgs(AstTypeConstructorArgs *, LamContext *);
static HashSymbol *dollarSubstitute(HashSymbol *, ParserInfo I);
static LamExp *convertNest(AstNest *, LamContext *);
static LamExp *lamConvert(AstDefinitions *, AstNamespaceArray *, AstExpressions *, LamContext *);
static LamExp *convertSymbol(ParserInfo, HashSymbol *, LamContext *);

#ifdef DEBUG_LAMBDA_CONVERT
#  include "debugging_on.h"
#else
#  include "debugging_off.h"
#endif

static bool inPreamble;  // preamble is treated specially

static void conversionError(ParserInfo, char *, ...) __attribute__((format(printf, 2, 3)));

static void conversionError(ParserInfo I, char *message, ...) {
    va_list args;
    va_start(args, message);
    vfprintf(errout, message, args);
    va_end(args);
    can_happen(" at +%d %s", I.lineno, I.filename);
}

static LamExp *lamExpError(ParserInfo I) {
    return newLamExp_Var(I, errorSymbol());
}

static void addCurrentNamespaceToContext(LamContext *context, int id) {
    LamInfo *lamInfo = newLamInfo_Nsid(CPI(context), id);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, namespaceSymbol(), lamInfo);
    UNPROTECT(save);
}

LamExp *lamConvertProg(AstProg *prog) {
    ENTER(lamConvertProg);
    inPreamble = true;
    LamContext *env = newLamContext(CPI(prog), NULL);
    int save = PROTECT(env);
    addCurrentNamespaceToContext(env, NS_GLOBAL);
    LamExp *result = lamConvert(prog->preamble, prog->namespaces, prog->body, env);
    UNPROTECT(save);
    LEAVE(lamConvertProg);
    return result;
}

static LamExp *convertNest(AstNest *nest, LamContext *env) {
    ENTER(convertNest);
    env = newLamContext(CPI(nest), env);
    int save = PROTECT(env);
    LamExp *result = lamConvert(nest->definitions, NULL, nest->expressions, env);
    PROTECT(result);
    UNPROTECT(save);
    LEAVE(convertNest);
    return result;
}

static void addConstructorInfoToLamContext(LamContext *context, HashSymbol *symbol,
                         LamTypeConstructorInfo *info) {
    LamInfo *lamInfo = newLamInfo_TypeConstructorInfo(CPI(context), info);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, symbol, lamInfo);
    UNPROTECT(save);
}

static void addNamespaceInfoToLamContext(LamContext *context, LamContext *info, Index namespace) {
    char buf[80];
    sprintf(buf, NS_FORMAT, namespace);
    HashSymbol *symbol = newSymbol(buf);
    LamInfo *lamInfo = newLamInfo_NamespaceInfo(CPI(context), info);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, symbol, lamInfo);
    UNPROTECT(save);
}

static LamExp *lamConvert(AstDefinitions *definitions,
                          AstNamespaceArray *nsArray,
                          AstExpressions *expressions,
                          LamContext *env) {
    ENTER(lamConvert);
    collectAliases(definitions, env);
    LamTypeDefList *typeDefList = collectTypeDefs(definitions, env);
    int save = PROTECT(typeDefList);
    LamLetRecBindings *funcDefsList = convertFuncDefs(definitions, env);
    PROTECT(funcDefsList);
    funcDefsList = makePrintFunctions(typeDefList, funcDefsList, env, inPreamble);
    PROTECT(funcDefsList);
    LamNamespaceArray *namespaces = NULL;
    if (nsArray != NULL) {
        inPreamble = false; // dodgy, we must be in the preamble because we're being called with namespaces
        namespaces = newLamNamespaceArray();
        PROTECT(namespaces);
        for (Index i = 0; i < nsArray->size; ++i) {
            AstNamespaceImpl *namespace = nsArray->entries[i];
            LamContext *nsEnv = newLamContext(CPI(env), env);
            int save2 = PROTECT(nsEnv);
            addCurrentNamespaceToContext(nsEnv, (int) i);
            AstExpression *envToken = newAstExpression_Env(CPI(namespace));
            PROTECT(envToken);
            AstExpressions *body = newAstExpressions(CPI(namespace), envToken, NULL);
            PROTECT(body);
            LamExp *lamNamespace = lamConvert(namespace->definitions, NULL, body, nsEnv);
            PROTECT(lamNamespace);
            pushLamNamespaceArray(namespaces, lamNamespace);
            addNamespaceInfoToLamContext(env, nsEnv, i);
            UNPROTECT(save2);
        }
    }
    LamSequence *body = convertSequence(expressions, env);
    PROTECT(body);
    if (namespaces != NULL && namespaces->size > 0) {
        LamExp *lamNamespaces = newLamExp_Namespaces(CPI(env), namespaces);
        PROTECT(lamNamespaces);
        body = newLamSequence(CPI(env), lamNamespaces, body);
        PROTECT(body);
    }
    LamExp *letRecBody = newLamExp_List(CPI(body), body);
    PROTECT(letRecBody);
    LamExp *result = NULL;
    if (funcDefsList != NULL) {
        LamLetRec *letRec =
            newLamLetRec(CPI(letRecBody), countLamLetRecBindings(funcDefsList), funcDefsList,
                         letRecBody);
        PROTECT(letRec);
        result = newLamExp_Letrec(CPI(letRec), letRec);
    } else {
        result = newLamExp_List(CPI(body), body);
    }
    PROTECT(result);
    if (typeDefList != NULL) {
        LamTypeDefs *typeDefs = newLamTypeDefs(CPI(typeDefList), typeDefList, result);
        PROTECT(typeDefs);
        result =
            newLamExp_Typedefs(CPI(typeDefs), typeDefs);
    }
    UNPROTECT(save);
    LEAVE(lamConvert);
    return result;
}

static LamExp *lamConvertIff(AstIff *iff, LamContext *context) {
    ENTER(lamConvertIff);
    LamExp *test = convertExpression(iff->test, context);
    int save = PROTECT(test);
    LamExp *consequent = convertNest(iff->consequent, context);
    PROTECT(consequent);
    LamExp *alternative = convertNest(iff->alternative, context);
    PROTECT(alternative);
    LamIff *lamIff = newLamIff(CPI(test), test, consequent, alternative);
    PROTECT(lamIff);
    LamExp *result = newLamExp_Iff(CPI(test), lamIff);
    UNPROTECT(save);
    LEAVE(lamConvertIff);
    return result;
}

static LamExp *lamConvertPrint(AstPrint *print, LamContext *context) {
    ENTER(lamConvertPrint);
    LamExp *exp = convertExpression(print->exp, context);
    int save = PROTECT(exp);
    LamPrint *lamPrint = newLamPrint(CPI(exp), exp);
    PROTECT(lamPrint);
    LamExp *result = newLamExp_Print(CPI(lamPrint), lamPrint);
    UNPROTECT(save);
    LEAVE(lamConvertPrint);
    return result;
}

static LamExp *lamConvertTuple(AstExpressions *tuple, LamContext *env) {
    LamList *expressions = convertExpressions(tuple, env);
    int save = PROTECT(expressions);
    LamExp *res = newLamExp_Make_tuple(CPI(expressions), expressions);
    UNPROTECT(save);
    return res;
}

static LamExp *lamConvertLookup(AstLookup *lookup, LamContext *env) {
    LamContext *nsEnv = lookupNamespaceInLamContext(env, lookup->nsid);
    LamExp *expression = convertExpression(lookup->expression, nsEnv);
    int save = PROTECT(expression);
    LamLookup *llu = newLamLookup(CPI(lookup), lookup->nsid, lookup->nsSymbol, expression);
    PROTECT(llu);
    LamExp *res = newLamExp_Lookup(CPI(lookup), llu);
    UNPROTECT(save);
    return res;
}

static void checkMacro(AstDefinition *definition, LamContext *env) {
    if (definition->type == AST_DEFINITION_TYPE_MACRO) {
        setLamMacroTable(env->macros, definition->val.macro->name, NULL);
    }
}

static LamLetRecBindings *convertFuncDefs(AstDefinitions *definitions, LamContext *env) {
    ENTER(convertFuncDefs);
    if (definitions == NULL) {
        LEAVE(convertFuncDefs);
        return NULL;
    }
    checkMacro(definitions->definition, env);
    LamLetRecBindings *next = convertFuncDefs(definitions->next, env);
    int save = PROTECT(next);
    LamLetRecBindings *this =
        prependDefinition(definitions->definition, env, next);
    UNPROTECT(save);
    LEAVE(convertFuncDefs);
    return this;
}

static LamTypeArgs *convertTypeSymbols(AstTypeSymbols *symbols) {
    if (symbols == NULL)
        return NULL;
    LamTypeArgs *next = convertTypeSymbols(symbols->next);
    int save = PROTECT(next);
    LamTypeArgs *this = newLamTypeArgs(CPI(symbols), symbols->typeSymbol, next);
    UNPROTECT(save);
    return this;
}

static LamType *convertUserType(AstUserType *userType) {
    LamTypeArgs *args = convertTypeSymbols(userType->typeSymbols);
    int save = PROTECT(args);
    LamType *res = newLamType(CPI(userType), userType->symbol, args);
    UNPROTECT(save);
    return res;
}

static LamLookupSymbol *convertAstLookupSymbol(AstLookupSymbol *ls) {
    return newLamLookupSymbol(CPI(ls), ls->nsid, ls->nsSymbol, ls->symbol);
}

static LamLookupOrSymbol *convertAstLookupOrSymbol(AstLookupOrSymbol *los) {
    switch (los->type) {
        case AST_LOOKUPORSYMBOL_TYPE_SYMBOL:
            return newLamLookupOrSymbol_Symbol(CPI(los), los->val.symbol);
        case AST_LOOKUPORSYMBOL_TYPE_LOOKUP:{
            LamLookupSymbol *ls = convertAstLookupSymbol(los->val.lookup);
            int save = PROTECT(ls);
            LamLookupOrSymbol *llos = newLamLookupOrSymbol_Lookup(CPI(los), ls);
            UNPROTECT(save);
            return llos;
        }
        default:
            cant_happen("unrecognized %s", astLookupOrSymbolTypeName(los->type));
    }
}

static LamTypeConstructorType *expandSymbolAlias(AstLookupOrSymbol *los, LamContext *env) {
    switch (los->type) {
        case LAMLOOKUPORSYMBOL_TYPE_SYMBOL: {
                LamTypeConstructorType *found =
                    lookupConstructorTypeInLamContext(env, los->val.symbol);
                if (found != NULL) {
                    return found;
                }
                return NULL;
            }
        case LAMLOOKUPORSYMBOL_TYPE_LOOKUP:
            return NULL;
        default:
            cant_happen("unrecognized %s", astLookupOrSymbolTypeName(los->type));
    }
}

static LamTypeConstructorType *expandFunctionAlias(AstTypeFunction *function, LamContext *env) {
    if (function->typeList != NULL) {
        return NULL;
    }
    return expandSymbolAlias(function->symbol, env);
}

static LamTypeFunction *convertAstTypeFunction(AstTypeFunction *astTypeFunction, LamContext *env) {
    LamTypeConstructorArgs *lamTypeConstructorArgs =
        convertAstTypeList(astTypeFunction->typeList, env);
    int save = PROTECT(lamTypeConstructorArgs);
    LamLookupOrSymbol *los = convertAstLookupOrSymbol(astTypeFunction->symbol);
    PROTECT(los);
    LamTypeFunction *this = newLamTypeFunction(CPI(los), los, lamTypeConstructorArgs);
    UNPROTECT(save);
    return this;
}

static LamTypeConstructorType *convertAstTypeClause(AstTypeClause *astTypeClause, LamContext *env) {
    switch (astTypeClause->type) {
        case AST_TYPECLAUSE_TYPE_INTEGER:
            return newLamTypeConstructorType_Integer(CPI(astTypeClause));
        case AST_TYPECLAUSE_TYPE_CHARACTER:
            return newLamTypeConstructorType_Character(CPI(astTypeClause));
        case AST_TYPECLAUSE_TYPE_VAR:
            return newLamTypeConstructorType_Var(CPI(astTypeClause), astTypeClause->val.var);
        case AST_TYPECLAUSE_TYPE_TYPEFUNCTION:{
                LamTypeConstructorType *alias = expandFunctionAlias(astTypeClause->val.typeFunction, env);
                if (alias != NULL) {
                    return alias;
                }
                LamTypeFunction *lamTypeFunction =
                    convertAstTypeFunction(astTypeClause->val.typeFunction, env);
                int save = PROTECT(lamTypeFunction);
                LamTypeConstructorType *this =
                    newLamTypeConstructorType_Function(CPI(astTypeClause), lamTypeFunction);
                UNPROTECT(save);
                return this;
            }
        case AST_TYPECLAUSE_TYPE_TYPETUPLE: {
            LamTypeConstructorArgs *lamTypeConstructorArgs =
                convertAstTypeList(astTypeClause->val.typeTuple, env);
            int save = PROTECT(lamTypeConstructorArgs);
            LamTypeConstructorType *this =
                newLamTypeConstructorType_Tuple(CPI(astTypeClause), lamTypeConstructorArgs);
            UNPROTECT(save);
            return this;
        }
        default:
            cant_happen
                ("unrecognised astTypeClause type %d in convertAstTypeClause",
                 astTypeClause->type);
    }
}

static LamTypeFunction *makeArrow(LamTypeConstructorType *lhs,
                                  LamTypeConstructorType *rhs) {
    LamTypeConstructorArgs *rhsArg = newLamTypeConstructorArgs(CPI(rhs), rhs, NULL);
    int save = PROTECT(rhsArg);
    LamTypeConstructorArgs *argss = newLamTypeConstructorArgs(CPI(lhs), lhs, rhsArg);
    PROTECT(argss);
    LamLookupOrSymbol *los = newLamLookupOrSymbol_Symbol(CPI(lhs), arrowSymbol());
    PROTECT(los);
    LamTypeFunction *res = newLamTypeFunction(CPI(lhs), los, argss);
    UNPROTECT(save);
    return res;
}

static LamTypeConstructorType *convertAstType(AstType *astType, LamContext *env) {
    if (astType->next) {        // it's a function
        LamTypeConstructorType *next = convertAstType(astType->next, env);
        int save = PROTECT(next);
        LamTypeConstructorType *this =
            convertAstTypeClause(astType->typeClause, env);
        PROTECT(this);
        LamTypeFunction *arrow = makeArrow(this, next);
        PROTECT(arrow);
        LamTypeConstructorType *res =
            newLamTypeConstructorType_Function(CPI(astType), arrow);
        UNPROTECT(save);
        return res;
    } else {
        return convertAstTypeClause(astType->typeClause, env);
    }
}

static LamTypeConstructorArgs *convertAstTypeList(AstTypeList *typeList, LamContext *env) {
    if (typeList == NULL)
        return NULL;
    LamTypeConstructorArgs *next = convertAstTypeList(typeList->next, env);
    int save = PROTECT(next);
    LamTypeConstructorType *arg = convertAstType(typeList->type, env);
    PROTECT(arg);
    LamTypeConstructorArgs *this = newLamTypeConstructorArgs(CPI(arg), arg, next);
    UNPROTECT(save);
    return this;
}

static LamTypeConstructorArgs *convertAstTypeMap(AstTypeMap *typeMap, LamContext *env) {
    if (typeMap == NULL)
        return NULL;
    LamTypeConstructorArgs *next = convertAstTypeMap(typeMap->next, env);
    int save = PROTECT(next);
    LamTypeConstructorType *arg = convertAstType(typeMap->type, env);
    PROTECT(arg);
    LamTypeConstructorArgs *this = newLamTypeConstructorArgs(CPI(arg), arg, next);
    UNPROTECT(save);
    return this;
}

static LamTypeConstructorArgs *convertAstTypeConstructorArgs(AstTypeConstructorArgs *args, LamContext *env) {
    if (args == NULL) {
        return NULL;
    }
    switch (args->type) {
        case AST_TYPECONSTRUCTORARGS_TYPE_LIST:{
            return convertAstTypeList(args->val.list, env);
        }
        case AST_TYPECONSTRUCTORARGS_TYPE_MAP:{
            return convertAstTypeMap(args->val.map, env);
        }
        default:
            cant_happen("unrecognized %s", astTypeConstructorArgsTypeName(args->type));
    }
}

static LamTypeTags *astTypeConstructorArgMapToTags(AstTypeMap *map) {
    if (map == NULL) return NULL;
    LamTypeTags *next = astTypeConstructorArgMapToTags(map->next);
    int save = PROTECT(next);
    LamTypeTags *this = newLamTypeTags(CPI(map), map->key, next);
    UNPROTECT(save);
    return this;
}

static LamTypeTags *makeLamTypeTags(AstTypeConstructorArgs *args) {
    if (args == NULL) {
        return NULL;
    }
    switch (args->type) {
        case AST_TYPECONSTRUCTORARGS_TYPE_LIST:
            return NULL;
        case AST_TYPECONSTRUCTORARGS_TYPE_MAP:
            return astTypeConstructorArgMapToTags(args->val.map);
        default:
            cant_happen("unrecognized %s", astTypeConstructorArgsTypeName(args->type));
    }
}

static void collectTypeInfo(HashSymbol *symbol, AstTypeConstructorArgs *args, LamTypeConstructor *type,
                            bool needsVec, int enumCount, int index,
                            int arity, LamContext *env) {
    ENTER(collectTypeInfo);
    int namespace = lookupCurrentNamespaceInLamContext(env);
    LamTypeTags *tags = makeLamTypeTags(args);
    int save = PROTECT(tags);
    LamTypeConstructorInfo *info =
        newLamTypeConstructorInfo(CPI(type), symbol, namespace, type, tags, needsVec,
                                  arity, enumCount, index);
    PROTECT(info);
    addConstructorInfoToLamContext(env, symbol, info);
    UNPROTECT(save);
    LEAVE(collectTypeInfo);
}

static Index countAstTypeConstructorArgs(AstTypeConstructorArgs *args) {
    if (args == NULL) return 0;
    switch (args->type) {
        case AST_TYPECONSTRUCTORARGS_TYPE_LIST:{
            return countAstTypeList(args->val.list);
        }
        case AST_TYPECONSTRUCTORARGS_TYPE_MAP:{
            return countAstTypeMap(args->val.map);
        }
        default:
            cant_happen("unrecognized %s", astTypeConstructorArgsTypeName(args->type));
    }
}

static LamTypeConstructor *collectTypeConstructor(AstTypeConstructor *typeConstructor,
                                                  LamType *type,
                                                  int enumCount, int index,
                                                  bool needsVec,
                                                  LamContext *env) {
    int nargs = countAstTypeConstructorArgs(typeConstructor->args);
    LamTypeConstructorArgs *args =
        convertAstTypeConstructorArgs(typeConstructor->args, env);
    int save = PROTECT(args);
    LamTypeConstructor *lamTypeConstructor =
        newLamTypeConstructor(CPI(type), typeConstructor->symbol, type, args);
    PROTECT(lamTypeConstructor);
    collectTypeInfo(typeConstructor->symbol, typeConstructor->args, lamTypeConstructor, needsVec,
                    enumCount, index, nargs, env);
    UNPROTECT(save);
    return lamTypeConstructor;
}

static LamTypeDef *collectTypeDef(AstTypeDef *typeDef, LamContext *env) {
    LamType *type = convertUserType(typeDef->userType);
    int save = PROTECT(type);
    AstTypeBody *typeBody = typeDef->typeBody;
    bool needsVec = typeHasFields(typeBody);
    int enumCount = countAstTypeBody(typeBody);
    int index = 0;
    LamTypeConstructorList *lamTypeConstructorList = NULL;
    int save2 = PROTECT(type);
    while (typeBody != NULL) {
        LamTypeConstructor *lamTypeConstructor =
            collectTypeConstructor(typeBody->typeConstructor,
                                   type,
                                   enumCount,
                                   index,
                                   needsVec,
                                   env);
        int save3 = PROTECT(lamTypeConstructor);
        lamTypeConstructorList =
            newLamTypeConstructorList(CPI(lamTypeConstructor), lamTypeConstructor,
                                      lamTypeConstructorList);
        REPLACE_PROTECT(save2, lamTypeConstructorList);
        UNPROTECT(save3);
        typeBody = typeBody->next;
        index++;
    }
    LamTypeDef *res = newLamTypeDef(CPI(type), type, lamTypeConstructorList);
    UNPROTECT(save);
    return res;
}

static void collectAlias(AstAlias *alias, LamContext *env) {
    LamTypeConstructorType *type = convertAstType(alias->type, env);
    int save = PROTECT(type);
    setLamAliasTable(env->aliases, alias->name, type);
    UNPROTECT(save);
}

static void collectAliases(AstDefinitions *definitions, LamContext *env) {
    if (definitions == NULL) {
        return;
    }
    switch (definitions->definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
        case AST_DEFINITION_TYPE_BLANK:
        case AST_DEFINITION_TYPE_TYPEDEF:
        case AST_DEFINITION_TYPE_MACRO:
            break;
        case AST_DEFINITION_TYPE_ALIAS:
            collectAlias(definitions->definition->val.alias, env);
            break;
        default:
            cant_happen("unrecognised %s", astDefinitionTypeName(definitions->definition->type));
    }
    collectAliases(definitions->next, env);
}

static HashSymbol *convertMacroArg(AstArg *arg) {
    switch (arg->type) {
        case AST_ARG_TYPE_SYMBOL:
            return arg->val.symbol;
        case AST_ARG_TYPE_WILDCARD:
        case AST_ARG_TYPE_LOOKUP:
        case AST_ARG_TYPE_NAMED:
        case AST_ARG_TYPE_UNPACK:
        case AST_ARG_TYPE_UNPACKSTRUCT:
        case AST_ARG_TYPE_NUMBER:
        case AST_ARG_TYPE_CHARACTER:
        case AST_ARG_TYPE_TUPLE:
            // should have been caught in the parser
            cant_happen("unexpected %s", astArgTypeName(arg->type));
        default:
            cant_happen("unrecognized %s", astArgTypeName(arg->type));
    }
}

static void checkDuplicateMacroArg(HashSymbol *arg, LamVarList *args) {
    if (args == NULL) return;
    if (arg == args->var) {
        conversionError(CPI(args), "duplicate argument \"%s\" in macro definition", arg->name);
        return;
    }
    checkDuplicateMacroArg(arg, args->next);
}

static LamVarList *collectMacroArgs(AstArgList *argList) {
    if (argList == NULL) return NULL;
    LamVarList *next = collectMacroArgs(argList->next);
    int save = PROTECT(next);
    HashSymbol *arg = convertMacroArg(argList->arg);
    checkDuplicateMacroArg(arg, next);
    LamVarList *this = newLamVarList(CPI(argList), arg, next);
    UNPROTECT(save);
    return this;
}

static void populateArgsTable(LamMacroArgsTable *symbols, LamVarList *args) {
    if (args == NULL) return;
    setLamMacroArgsTable(symbols, args->var, NULL);
    populateArgsTable(symbols, args->next);
}

static LamExp *convertAstMacro(AstDefMacro *astMacro, LamContext *env) {
    ENTER(convertAstMacro);
    // ParserInfo PI = CPI(astMacro);
    // eprintf("convert macro %s +%d %s\n", astMacro->name->name, PI.lineno, PI.filename);
    LamVarList *args = collectMacroArgs(astMacro->definition->altArgs->argList);
    int save = PROTECT(args);
    LamExp *body = convertNest(astMacro->definition->nest, env);
    PROTECT(body);
    LamMacroArgsTable *symbols = newLamMacroArgsTable();
    PROTECT(symbols);
    populateArgsTable(symbols, args);
    body = lamPerformMacroSubstitutions(body, symbols);
    PROTECT(body);
    LamLam *lam = newLamLam(CPI(astMacro), args, body);
    PROTECT(lam);
    LamExp *res = newLamExp_Lam(CPI(lam), lam);
    PROTECT(res);
    setLamMacroTable(env->macros, astMacro->name, NULL);
    LEAVE(convertAstMacro);
    UNPROTECT(save);
    return res;
}


static LamTypeDefList *collectTypeDefs(AstDefinitions *definitions, LamContext *env) {
    if (definitions == NULL) {
        return NULL;
    }
    switch (definitions->definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
        case AST_DEFINITION_TYPE_ALIAS:
        case AST_DEFINITION_TYPE_BLANK:
        case AST_DEFINITION_TYPE_MACRO:
            return collectTypeDefs(definitions->next, env);
        case AST_DEFINITION_TYPE_TYPEDEF:{
                LamTypeDef *lamTypeDef = collectTypeDef(definitions->definition->val.typeDef, env);
                int save = PROTECT(lamTypeDef);
                LamTypeDefList *rest = collectTypeDefs(definitions->next, env);
                PROTECT(rest);
                LamTypeDefList *res = newLamTypeDefList(CPI(lamTypeDef), lamTypeDef, rest);
                UNPROTECT(save);
                return res;
            }
        default:
            cant_happen("unrecognised %s", astDefinitionTypeName(definitions->definition->type));
    }
}

static LamLetRecBindings *prependMacro(AstDefMacro * macro, LamContext * env,
                                        LamLetRecBindings * next) {
    ENTER(prependMacro);
    LamExp *exp = convertAstMacro(macro, env);
    int save = PROTECT(exp);
    LamLetRecBindings *this =
        newLamLetRecBindings(CPI(macro), dollarSubstitute(macro->name, CPI(macro)), exp, next);
    UNPROTECT(save);
    LEAVE(prependMacro);
    return this;
}

static LamLetRecBindings *prependDefinition(AstDefinition *definition,
                                            LamContext *env,
                                            LamLetRecBindings *next) {
    ENTER(prependDefinition);
    LamLetRecBindings *result = NULL;
    switch (definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
            result = prependDefine(definition->val.define, env, next);
            break;
        case AST_DEFINITION_TYPE_MACRO:
            result = prependMacro(definition->val.macro, env, next);
            break;
        case AST_DEFINITION_TYPE_ALIAS:
        case AST_DEFINITION_TYPE_TYPEDEF:
        case AST_DEFINITION_TYPE_BLANK:
            result = next;
            break;
        default:
            cant_happen("unrecognised %s", astDefinitionTypeName(definition->type));
    }
    LEAVE(prependDefinition);
    return result;
}

static bool typeHasFields(AstTypeBody *typeBody) {
    ENTER(typeHasFields);
    while (typeBody != NULL) {
        if (typeBody->typeConstructor->args != NULL) {
            LEAVE(typeHasFields);
            return true;
        }
        typeBody = typeBody->next;
    }
    LEAVE(typeHasFields);
    return false;
}

static LamLetRecBindings *prependDefine(AstDefine * define, LamContext * env,
                                        LamLetRecBindings * next) {
    ENTER(prependDefine);
    bool doMermaid = (tpmc_mermaid_function != NULL
                      && strcmp(tpmc_mermaid_function,
                                define->symbol->name) == 0);
    if (doMermaid)
        tpmc_mermaid_flag = 1;
    LamExp *exp = convertExpression(define->expression, env);
    if (lambda_conversion_function != NULL && strcmp(lambda_conversion_function, define->symbol->name) == 0) {
        ppLamExp(exp);
        eprintf("\n");
    }
    if (doMermaid)
        tpmc_mermaid_flag = 0;
    int save = PROTECT(exp);
    LamLetRecBindings *this =
        newLamLetRecBindings(CPI(define), dollarSubstitute(define->symbol, CPI(define)), exp, next);
    UNPROTECT(save);
    LEAVE(prependDefine);
    return this;
}

static HashSymbol *dollarSubstitute(HashSymbol *symbol, ParserInfo I __attribute__((unused))) {
    if (!inPreamble) {
        // eprintf("dollarSubstitute %s not in preamble\n", symbol->name);
        return symbol;
    }
    bool needs_substitution = false;
    for (char *s = symbol->name; *s != 0; s++) {
        if (*s == '_') {
            needs_substitution = true;
            break;
        }
    }
    if (needs_substitution) {
        char *buf = NEW_ARRAY(char, strlen(symbol->name) + 1);
        strcpy(buf, symbol->name);
        for (int i = 0; buf[i] != 0; i++) {
            if (buf[i] == '_') {
                buf[i] = '$';
            }
        }
        HashSymbol *replacement = newSymbol(buf);
        FREE_ARRAY(char, buf, strlen(buf) + 1);
        // eprintf("dollarSubstitute +%d %s: %s => %s\n", I.lineno, I.filename, symbol->name, replacement->name);
        return replacement;
    } else {
        return symbol;
    }
}

#define CHECK_ONE_ARG(name, args) do { \
    int count = countLamList(args); \
    if (count != 1) \
        conversionError(CPI(args), "expected 1 arg in " #name ", got %d", count); \
} while(0)

#define CHECK_TWO_ARGS(name, args) do { \
    int count = countLamList(args); \
    if (count != 2) \
        conversionError(CPI(args), "expected 2 args in " #name ", got %d", count); \
} while(0)

static LamExp *makeCallCC(LamList *args) {
    CHECK_ONE_ARG(makeCallCC, args);
    return newLamExp_Callcc(CPI(args), args->exp);
}

static LamExp *makeBinOp(LamPrimOp opCode, LamList *args) {
    CHECK_TWO_ARGS(makeBinOp, args);
    LamPrimApp *app = newLamPrimApp(CPI(args), opCode, args->exp, args->next->exp);
    int save = PROTECT(app);
    LamExp *exp = newLamExp_Prim(CPI(app), app);
    UNPROTECT(save);
    return exp;
}

static LamExp *makeLamAmb(LamList *args) {
    CHECK_TWO_ARGS(makeLamAmb, args);
    LamAmb *lamAmb = newLamAmb(CPI(args), args->exp, args->next->exp);
    int save = PROTECT(lamAmb);
    LamExp *res = newLamExp_Amb(CPI(lamAmb), lamAmb);
    UNPROTECT(save);
    return res;
}

static LamExp *makeUnaryNeg(LamList *args) {
    CHECK_ONE_ARG(makeUnaryNeg, args);
    MaybeBigInt *num = fakeBigInt(0, false);
    int save = PROTECT(num);
    LamExp *zero = newLamExp_Biginteger(CPI(args), num);
    PROTECT(zero);
    args = newLamList(CPI(args), zero, args);
    PROTECT(args);
    LamExp *result = makeBinOp(LAMPRIMOP_TYPE_SUB, args);
    UNPROTECT(save);
    return result;
}

static bool isMacro(ParserInfo PI __attribute__((unused)), HashSymbol *symbol, LamContext *env) {
    if (env == NULL) {
        // eprintf("ismacro %s false +%d, %s\n", symbol->name, PI.lineno, PI.filename);
        return false;
    }
    if (getLamMacroTable(env->macros, symbol, NULL)) {
        // eprintf("ismacro %s true +%d, %s\n", symbol->name, PI.lineno, PI.filename);
        return true;
    }
    return isMacro(PI, symbol, env->parent);
}

static LamExp *thunkMacroArg(LamExp *arg) {
    LamLam *lambda = newLamLam(CPI(arg), NULL, arg);
    int save = PROTECT(lambda);
    LamExp *res = newLamExp_Lam(CPI(lambda), lambda);
    UNPROTECT(save);
    return res;
}

static LamList *wrapMacroArgs(LamList *args) {
    if (args == NULL) {
        return NULL;
    }
    LamList *next = wrapMacroArgs(args->next);
    int save = PROTECT(next);
    LamExp *arg = thunkMacroArg(args->exp);
    PROTECT(arg);
    LamList *this = newLamList(CPI(arg), arg, next);
    UNPROTECT(save);
    return this;
}

// wrap each argument to the macro in a thunk, the macro will invoke
static LamExp *wrapMacro(ParserInfo PI, HashSymbol *symbol, LamList *args) {
    args = wrapMacroArgs(args);
    int save = PROTECT(args);
    LamExp *macro = newLamExp_Var(PI, symbol);
    PROTECT(macro);
    LamApply *apply = newLamApply(PI, macro, args);
    PROTECT(apply);
    LamExp *res = newLamExp_Apply(PI, apply);
    UNPROTECT(save);
    return res;
}

static LamExp *makePrimApp(ParserInfo PI, HashSymbol *symbol, LamList *args, LamContext *env) {
    if (isMacro(PI, symbol, env)) {
        return wrapMacro(PI, symbol, args);
    }
    if (symbol == negSymbol())
        return makeUnaryNeg(args);
    if (symbol == hereSymbol())
        return makeCallCC(args);
    if (symbol == thenSymbol())
        return makeLamAmb(args);
    if (symbol == eqSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_EQ, args);
    if (symbol == neSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_NE, args);
    if (symbol == gtSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_GT, args);
    if (symbol == ltSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_LT, args);
    if (symbol == geSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_GE, args);
    if (symbol == leSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_LE, args);
    if (symbol == addSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_ADD, args);
    if (symbol == subSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_SUB, args);
    if (symbol == mulSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_MUL, args);
    if (symbol == divSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_DIV, args);
    if (symbol == modSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_MOD, args);
    if (symbol == powSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_POW, args);
    if (symbol == cmpSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_CMP, args);
    return NULL;
}

static LamExp *makeConstructor(HashSymbol *symbol, LamContext *env) {
    LamTypeConstructorInfo *info = lookupConstructorInLamContext(env, symbol);
    if (info != NULL) {
        return newLamExp_Constructor(CPI(info), info);
    }
    return NULL;
}

static LamExp *makeApplication(LamExp *fun, LamList *args) {
    LamApply *apply = newLamApply(CPI(fun), fun, args);
    int save = PROTECT(apply);
    LamExp *result = newLamExp_Apply(CPI(apply), apply);
    UNPROTECT(save);
    return result;
}

static LamList *varListToList(LamVarList *list) {
    if (list == NULL) return NULL;
    LamList *next = varListToList(list->next);
    int save = PROTECT(next);
    LamExp *var = newLamExp_Var(CPI(list), list->var);
    PROTECT(var);
    LamList *this = newLamList(CPI(var), var, next);
    UNPROTECT(save);
    return this;
}

static LamVarList *genSymVarList(ParserInfo I, int nargs) {
    if (nargs == 0) {
        return NULL;
    }
    LamVarList *rest = genSymVarList(I, nargs - 1);
    int save = PROTECT(rest);
    HashSymbol *s = genSym("$x");
    LamVarList *this = newLamVarList(I, s, rest);
    UNPROTECT(save);
    return this;
}

static int findUnderlyingArity(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_CONSTRUCTOR:
            return exp->val.constructor->arity;
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingArity(exp->val.lookup->exp);
        default:
            cant_happen("expected lookup or constructor");
    }
}

static int findUnderlyingType(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingType(exp->val.lookup->exp);
        default:
            return exp->type;
    }
}

static LamExp *findUnderlyingValue(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingValue(exp->val.lookup->exp);
        default:
            return exp;
    }
}

static void checkLamTagPresent(HashSymbol *tag, AstTaggedExpressions *astTags) {
    if (astTags == NULL) {
        cant_happen("missing tag %s", tag->name);
    }
    if (tag == astTags->tag) {
        return;
    }
    checkLamTagPresent(tag, astTags->next);
}

static void checkAllTagsPresent(LamTypeTags *lamTags, AstTaggedExpressions *astTags) {
    if (lamTags == NULL) return;
    checkLamTagPresent(lamTags->tag, astTags);
    checkAllTagsPresent(lamTags->next, astTags);
}

static void checkAstTagPresent(LamTypeTags *lamTags, HashSymbol *astTag) {
    if (lamTags == NULL) {
        cant_happen("missing constructor tag %s", astTag->name);
    }
    if (astTag == lamTags->tag) return;
    checkAstTagPresent(lamTags->next, astTag);
}

static void checkNoUnrecognisedTags(LamTypeTags *lamTags, AstTaggedExpressions *astTags) {
    if (astTags == NULL) return;
    checkAstTagPresent(lamTags, astTags->tag);
    checkNoUnrecognisedTags(lamTags, astTags->next);
}

static void checkTagNotDuplicate(HashSymbol *tag, AstTaggedExpressions *tags) {
    if (tags == NULL) return;
    if (tag == tags->tag) {
        conversionError(CPI(tags), "duplicate tag %s", tag->name);
        return;
    }
    checkTagNotDuplicate(tag, tags->next);
}

static void checkNoDuplicateTags(AstTaggedExpressions *tags) {
    if (tags == NULL) return;
    checkTagNotDuplicate(tags->tag, tags->next);
    checkNoDuplicateTags(tags->next);
}

static AstExpression *findTaggedExpression(HashSymbol *tag, AstTaggedExpressions *tags) {
#ifdef SAFETY_CHECKS
    if (tags == NULL) {
        cant_happen("cannot find value for tag %s", tag->name);
    }
#endif
    if (tag == tags->tag) return tags->expression;
    return findTaggedExpression(tag, tags->next);
}

static LamList *convertTagsToArgs(LamTypeTags *lamTags, AstTaggedExpressions *astTags, LamContext *env) {
    // lamTags are in canonical order
    if (lamTags == NULL) return NULL;
    LamList *rest = convertTagsToArgs(lamTags->next, astTags, env);
    int save = PROTECT(rest);
    AstExpression *expression = findTaggedExpression(lamTags->tag, astTags);
    LamExp *lamExp = convertExpression(expression, env);
    PROTECT(lamExp);
    LamList *this = newLamList(CPI(lamExp), lamExp, rest);
    UNPROTECT(save);
    return this;
}

// (costructor4 arg1 arg2) =>
// ((lambda (x1 x2 x3 x4) (constructor4 x1 x2 x3 x4)) arg1 arg2)

static LamExp *makeConstructorApplication(LamExp *constructor, LamList *args) {
    int nargs = (int) countLamList(args);
    LamExp *result;
    int arity = findUnderlyingArity(constructor);
    if (nargs < arity) {
        LamVarList *fargs = genSymVarList(CPI(constructor), arity);
        int save = PROTECT(fargs);
        LamList *aargs = varListToList(fargs);
        PROTECT(aargs);
        LamApply *innerApply = newLamApply(CPI(constructor), constructor, aargs);
        PROTECT(innerApply);
        LamExp *applyExp = newLamExp_Apply(CPI(innerApply), innerApply);
        PROTECT(applyExp);
        LamLam *lambda = newLamLam(CPI(fargs), fargs, applyExp);
        PROTECT(lambda);
        LamExp *lamExp = newLamExp_Lam(CPI(lambda), lambda);
        PROTECT(lamExp);
        LamApply *apply = newLamApply(CPI(lamExp), lamExp, args);
        PROTECT(apply);
        result = newLamExp_Apply(CPI(apply), apply);
        UNPROTECT(save);
    } else {
        LamApply *apply = newLamApply(CPI(constructor), constructor, args);
        int save = PROTECT(apply);
        result = newLamExp_Apply(CPI(apply), apply);
        UNPROTECT(save);
    }
    return result;
}

static LamExp *makeStructureApplication(LamExp *constructor, AstTaggedExpressions *tags, LamContext *env) {
    if (constructor->val.constructor->tags == NULL) {
        conversionError(CPI(constructor), "non-struct constructor applied to struct");
        return lamExpError(CPI(tags));
    }
    checkAllTagsPresent(constructor->val.constructor->tags, tags);
    checkNoUnrecognisedTags(constructor->val.constructor->tags, tags);
    checkNoDuplicateTags(tags);
    int arity = findUnderlyingArity(constructor);
    int nargs = (int) countAstTaggedExpressions(tags);
    if (nargs != arity) {
        conversionError(CPI(constructor), "wrong number of args in structure application");
        return lamExpError(CPI(tags));
    }
    LamList *args = convertTagsToArgs(constructor->val.constructor->tags, tags, env);
    int save = PROTECT(args);
    LamApply *apply = newLamApply(CPI(constructor), constructor, args);
    PROTECT(apply);
    LamExp *result = newLamExp_Apply(CPI(apply), apply);
    UNPROTECT(save);
    return result;
}

static LamTypeConstructorInfo *findConstructor(AstLookupOrSymbol *los, LamContext *env) {
    switch (los->type) {
        case AST_LOOKUPORSYMBOL_TYPE_SYMBOL:{
            return lookupConstructorInLamContext(env, los->val.symbol);
        }
        break;
        case AST_LOOKUPORSYMBOL_TYPE_LOOKUP:{
            AstLookupSymbol *lookup = los->val.lookup;
            LamContext *nsEnv = lookupNamespaceInLamContext(env, lookup->nsid);
            return lookupConstructorInLamContext(nsEnv, lookup->symbol);
        }
        break;
        default:
            cant_happen("unrecognized %s", astLookupOrSymbolTypeName(los->type));
    }
}

static LamExp *convertStructure(AstStruct *structure, LamContext *env) {
    LamTypeConstructorInfo *info = findConstructor(structure->symbol, env);
    if (info == NULL) {
        conversionError(CPI(structure), "cannot find constructor");
        return lamExpError(CPI(structure));
    }
    LamExp *constructor = newLamExp_Constructor(CPI(info), info);
    int save = PROTECT(constructor);
    LamExp *result = makeStructureApplication(constructor, structure->expressions, env);
    if (structure->symbol->type == AST_LOOKUPORSYMBOL_TYPE_LOOKUP) {
        PROTECT(result);
        LamLookup *lookup = newLamLookup(CPI(result), info->nsid, structure->symbol->val.lookup->symbol, result);
        PROTECT(lookup);
        result = newLamExp_Lookup(CPI(lookup), lookup);
    }
    UNPROTECT(save);
    return result;
}

static LamExp *convertFunCall(AstFunCall *funCall, LamContext *env) {
    LamList *args = convertExpressions(funCall->arguments, env);
    int save = PROTECT(args);
    LamExp *function = convertExpression(funCall->function, env);
    PROTECT(function);
    LamExp *result = NULL;
    switch (findUnderlyingType(function)) {
        case LAMEXP_TYPE_VAR:{
            LamExp *symbol = findUnderlyingValue(function);
            result = makePrimApp(CPI(funCall), symbol->val.var, args, env);
            if (result != NULL) {
                UNPROTECT(save);
                return result;
            }
            result = makeApplication(function, args);
            UNPROTECT(save);
            return result;
        }
        case LAMEXP_TYPE_CONSTRUCTOR:{
            result = makeConstructorApplication(function, args);
            UNPROTECT(save);
            return result;
        }
        default:{
            result = makeApplication(function, args);
            UNPROTECT(save);
            return result;
        }
    }
}

static AstArgList *rewriteAstArgList(AstArgList *args, LamContext *env);
static AstArg *rewriteAstArg(AstArg *arg, LamContext *env);

static AstArg *rewriteAstNamed(AstNamedArg *namedArg, LamContext *env) {
    AstArg *arg = rewriteAstArg(namedArg->arg, env);
    int save = PROTECT(arg);
    AstNamedArg *this = newAstNamedArg(CPI(namedArg), namedArg->name, arg);
    PROTECT(this);
    AstArg *res = newAstArg_Named(CPI(this), this);
    UNPROTECT(save);
    return res;
}

static AstArg *rewriteAstUnpack(AstUnpack *unpack, LamContext *env) {
    AstArgList *args = rewriteAstArgList(unpack->argList, env);
    int save = PROTECT(args);
    AstUnpack *this = newAstUnpack(CPI(unpack), unpack->symbol, args);
    PROTECT(this);
    AstArg *res = newAstArg_Unpack(CPI(this), this);
    UNPROTECT(save);
    return res;
}

static AstArg *getAstArgFromTaggedArgList(HashSymbol *tag, AstTaggedArgList *list, LamContext *env, ParserInfo I) {
    if (list == NULL) {
        return newAstArg_Wildcard(I);
    }
    if (tag == list->tag) {
        return rewriteAstArg(list->arg, env);
    }
    return getAstArgFromTaggedArgList(tag, list->next, env, I);
}

static AstArgList *rewriteAstTaggedArgList(LamTypeTags *allTags, AstTaggedArgList *argTags, LamContext *env) {
    if (allTags == NULL) return NULL;
    AstArgList *next = rewriteAstTaggedArgList(allTags->next, argTags, env);
    int save = PROTECT(next);
    AstArg *arg = getAstArgFromTaggedArgList(allTags->tag, argTags, env, CPI(argTags));
    PROTECT(arg);
    AstArgList *this = newAstArgList(CPI(argTags), arg, next);
    UNPROTECT(save);
    return this;
}

static AstArg *rewriteAstUnpackStruct(AstUnpackStruct *structure, LamContext *env) {
    LamTypeConstructorInfo *info = findConstructor(structure->symbol, env);
    if (info->tags == NULL) {
        conversionError(CPI(structure), "constructor not a struct");
        return newAstArg_Wildcard(CPI(structure));
    }
    AstArgList *args = rewriteAstTaggedArgList(info->tags, structure->argList, env);
    int save = PROTECT(args);
    AstUnpack *unpack = newAstUnpack(CPI(structure), structure->symbol, args);
    PROTECT(unpack);
    AstArg *res = newAstArg_Unpack(CPI(unpack), unpack);
    UNPROTECT(save);
    return res;
}

static AstArg *rewriteAstTuple(AstArgList *tuple, LamContext *env) {
    AstArgList *new = rewriteAstArgList(tuple, env);
    int save = PROTECT(new);
    AstArg *res = newAstArg_Tuple(CPI(tuple), new);
    UNPROTECT(save);
    return res;
}

static AstArg *rewriteAstArg(AstArg *arg, LamContext *env) {
    switch (arg->type) {
        case AST_ARG_TYPE_WILDCARD:
        case AST_ARG_TYPE_SYMBOL:
        case AST_ARG_TYPE_NUMBER:
        case AST_ARG_TYPE_CHARACTER:
        case AST_ARG_TYPE_LOOKUP:
            return arg;
        case AST_ARG_TYPE_NAMED:
            return rewriteAstNamed(arg->val.named, env);
        case AST_ARG_TYPE_UNPACK:
            return rewriteAstUnpack(arg->val.unpack, env);
        case AST_ARG_TYPE_UNPACKSTRUCT:
            return rewriteAstUnpackStruct(arg->val.unpackStruct, env);
        case AST_ARG_TYPE_TUPLE:
            return rewriteAstTuple(arg->val.tuple, env);
        default:
            cant_happen("unrecognized %s", astArgTypeName(arg->type));
    }
}

static AstArgList *rewriteAstArgList(AstArgList *args, LamContext *env) {
    if (args == NULL) return NULL;
    AstArgList *next = rewriteAstArgList(args->next, env);
    int save = PROTECT(next);
    AstArg *arg = rewriteAstArg(args->arg, env);
    PROTECT(arg);
    AstArgList *this = newAstArgList(CPI(args), arg, next);
    UNPROTECT(save);
    return this;
}

static LamLam *convertCompositeBodies(int nargs, AstCompositeFunction *fun,
                                      LamContext *env) {
    ENTER(convertCompositeBodies);
    int nBodies = countAstCompositeFunction(fun);
    if (nBodies == 0) {
        can_happen("empty composite function");
        LEAVE(convertCompositeBodies);
        return NULL;
    }
    LamExp **actions = NEW_ARRAY(LamExp *, nBodies);
    AstArgList **argLists = NEW_ARRAY(AstArgList *, nBodies);
    int p = PROTECT(NULL);
    AstCompositeFunction *f = fun;
    for (int i = 0; i < nBodies; i++, f = f->next) {
        AstFunction *func = f->function;
        actions[i] = convertNest(func->nest, env);
        PROTECT(actions[i]);
        argLists[i] = rewriteAstArgList(func->argList, env);
        PROTECT(argLists[i]);
    }
    LamLam *result = tpmcConvert(fun->unsafe, CPI(fun), nargs, nBodies, argLists, actions, env);
    PROTECT(result);
    FREE_ARRAY(LamExp *, actions, nBodies);
    FREE_ARRAY(AstArgList *, argLists, nBodies);
    UNPROTECT(p);
    LEAVE(convertCompositeBodies);
    return result;
}

static LamExp *convertCompositeFun(ParserInfo PI, AstCompositeFunction *fun, LamContext *env) {
    ENTER(convertCompositeFun);
    if (fun == NULL) {
        conversionError(PI, "composite function with no components");
        return lamExpError(PI);
    }
    int nargs = countAstArgList(fun->function->argList);
    LamLam *lambda = convertCompositeBodies(nargs, fun, env);
    DEBUG("convertCompositeBodies returned %p", lambda);
    int save = PROTECT(lambda);
    LamExp *result = newLamExp_Lam(CPI(lambda), lambda);
    UNPROTECT(save);
    LEAVE(convertCompositeFun);
    return result;
}

static LamExp *convertSymbol(ParserInfo I, HashSymbol *symbol, LamContext *env) {
    ENTER(convertSymbol);
    LamExp *result = makeConstructor(symbol, env);
    DEBUG("convertSymbol %s %d - %s: %s", I.filename, I.lineno, symbol->name, result ? "constructor" : "variable");
    if (result == NULL) {
        symbol = dollarSubstitute(symbol, I);
        result = newLamExp_Var(I, symbol);
    }
    LEAVE(convertSymbol);
    return result;
}


static LamExp *convertAssertion(AstExpression *value, LamContext *env) {
    LamExp *exp = convertExpression(value, env);
    int save = PROTECT(exp);
    LamList *args = newLamList(CPI(exp), exp, NULL);
    PROTECT(args);
    LamExp *fileName = stringToLamList(CPI(exp), exp->_yy_parser_info.filename);
    PROTECT(fileName);
    args = newLamList(CPI(exp), fileName, args);
    PROTECT(args);
    MaybeBigInt *num = fakeBigInt(exp->_yy_parser_info.lineno, false);
    PROTECT(num);
    LamExp *lineNo = newLamExp_Biginteger(CPI(exp), num);
    PROTECT(lineNo);
    args = newLamList(CPI(lineNo), lineNo, args);
    PROTECT(args);
    LamExp *function = newLamExp_Var(CPI(value), assertSymbol());
    PROTECT(function);
    LamExp *res = makeApplication(function, args);
    UNPROTECT(save);
    return res;
}

static LamExp *convertError(AstExpression *value, LamContext *env) {
    LamExp *exp = convertExpression(value, env);
    int save = PROTECT(exp);
    LamList *args = newLamList(CPI(exp), exp, NULL);
    PROTECT(args);
    LamExp *fileName = stringToLamList(CPI(value), value->_yy_parser_info.filename);
    PROTECT(fileName);
    args = newLamList(CPI(exp), fileName, args);
    PROTECT(args);
    MaybeBigInt *num = fakeBigInt(value->_yy_parser_info.lineno, false);
    PROTECT(num);
    LamExp *lineNo = newLamExp_Biginteger(CPI(exp), num);
    PROTECT(lineNo);
    args = newLamList(CPI(lineNo), lineNo, args);
    PROTECT(args);
    LamExp *function = newLamExp_Var(CPI(value), fnErrorSymbol());
    PROTECT(function);
    LamExp *res = makeApplication(function, args);
    UNPROTECT(save);
    return res;
}

static LamExp *convertExpression(AstExpression *expression, LamContext *env) {
    ENTER(convertExpression);
    LamExp *result = NULL;
    switch (expression->type) {
        case AST_EXPRESSION_TYPE_BACK:
            DEBUG("back");
            result = newLamExp_Back(CPI(expression));
            break;
        case AST_EXPRESSION_TYPE_FUNCALL:
            DEBUG("funcall");
            result = convertFunCall(expression->val.funCall, env);
            break;
        case AST_EXPRESSION_TYPE_SYMBOL:
            DEBUG("symbol");
            result = convertSymbol(CPI(expression), expression->val.symbol, env);
            break;
        case AST_EXPRESSION_TYPE_NUMBER:
            DEBUG("number");
            result = newLamExp_Biginteger(CPI(expression), expression->val.number);
            break;
        case AST_EXPRESSION_TYPE_CHARACTER:
            DEBUG("character");
            result = newLamExp_Character(CPI(expression), expression->val.character);
            break;
        case AST_EXPRESSION_TYPE_ENV:
            DEBUG("env");
            result = newLamExp_Env(CPI(expression));
            break;
        case AST_EXPRESSION_TYPE_FUN:
            DEBUG("fun");
            result = convertCompositeFun(CPI(expression), expression->val.fun, env);
            break;
        case AST_EXPRESSION_TYPE_NEST:
            DEBUG("nest");
            result = convertNest(expression->val.nest, env);
            break;
        case AST_EXPRESSION_TYPE_IFF:
            DEBUG("iff");
            result = lamConvertIff(expression->val.iff, env);
            break;
        case AST_EXPRESSION_TYPE_PRINT:
            DEBUG("print");
            result = lamConvertPrint(expression->val.print, env);
            break;
        case AST_EXPRESSION_TYPE_TUPLE:
            DEBUG("tuple");
            result = lamConvertTuple(expression->val.tuple, env);
            break;
        case AST_EXPRESSION_TYPE_LOOKUP:
            DEBUG("lookup");
            result = lamConvertLookup(expression->val.lookup, env);
            break;
        case AST_EXPRESSION_TYPE_STRUCTURE:
            DEBUG("structure");
            result = convertStructure(expression->val.structure, env);
            break;
        case AST_EXPRESSION_TYPE_ASSERTION:
            result = convertAssertion(expression->val.assertion, env);
            break;
        case AST_EXPRESSION_TYPE_ERROR:
            result = convertError(expression->val.error, env);
            break;
        default:
            cant_happen
                ("unrecognised expression type %s",
                 astExpressionTypeName(expression->type));
    }
    LEAVE(convertExpression);
    return result;
}

static LamList *convertExpressions(AstExpressions *expressions,
                                   LamContext *env) {
    if (expressions == NULL)
        return NULL;
    LamList *next = convertExpressions(expressions->next, env);
    int save = PROTECT(next);
    LamExp *exp = convertExpression(expressions->expression, env);
    (void) PROTECT(exp);
    LamList *this = newLamList(CPI(exp), exp, next);
    UNPROTECT(save);
    return this;
}

static LamSequence *convertSequence(AstExpressions *expressions,
                                    LamContext *env) {
    if (expressions == NULL)
        return NULL;
    LamSequence *next = convertSequence(expressions->next, env);
    int save = PROTECT(next);
    LamExp *exp = convertExpression(expressions->expression, env);
    (void) PROTECT(exp);
    LamSequence *this = newLamSequence(CPI(exp), exp, next);
    UNPROTECT(save);
    return this;
}
