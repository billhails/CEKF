/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * @file lambda_conversion.c
 * 
 * conversion of the AST generated by the parser
 * to an intermediate "plain" lambda calculus which
 * will then be fed into the type checker and the
 * A-Normal Form converter.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "common.h"
#include "lambda_conversion.h"
#include "macro_substitution.h"
#include "lambda_helper.h"
#include "symbols.h"
#include "tpmc_logic.h"
#include "tpmc_mermaid.h"
#include "ast_debug.h"
#include "print_generator.h"

char *lambda_conversion_function = NULL; // set by --dump-lambda flag

static LamLetRecBindings *convertFuncDefs(AstDefinitions *, LamContext *);
static LamArgs *convertExpressions(AstExpressions *, LamContext *);
static LamSequence *convertSequence(AstExpressions *, LamContext *);
static LamLetRecBindings *prependDefinition(AstDefinition *, LamContext *, LamLetRecBindings *);
static LamLetRecBindings *prependDefine(AstDefine *, LamContext *, LamLetRecBindings *);
static LamExp *convertExpression(AstExpression *, LamContext *);
static bool typeHasFields(AstTypeBody *);
static LamTypeDefList *collectTypeDefs(AstDefinitions *, LamContext *);
static void collectAliases(AstDefinitions *, LamContext *);
static LamTypeConstructor *convertTypeConstructor(AstTypeConstructor *, LamTypeSig *, int, int, bool, LamContext *);
static void collectTypeInfo(HashSymbol *, AstTypeConstructorArgs *, LamTypeConstructor *, bool, int, int, int, LamContext *);
static LamTypeConstructorArgs *convertAstTypeList(AstTypeList *, LamContext *);
static LamTypeConstructorArgs *convertAstTypeMap(AstTypeMap *, LamContext *);
static LamTypeConstructorArgs *convertAstTypeConstructorArgs(AstTypeConstructorArgs *, LamContext *);
static LamExp *convertNest(AstNest *, LamContext *);
static LamExp *lamConvert(AstDefinitions *, AstNamespaceArray *, AstExpressions *, LamContext *);
static LamExp *convertSymbol(ParserInfo, HashSymbol *, LamContext *);
static LamExp *convertAnnotatedSymbol(AstAnnotatedSymbol *, LamContext *);

#ifdef DEBUG_LAMBDA_CONVERT
#  include "debugging_on.h"
#else
#  include "debugging_off.h"
#endif

static bool inPreamble;  // preamble is treated specially

static void conversionError(ParserInfo, char *, ...) __attribute__((format(printf, 2, 3)));

/**
 * @brief Report an error in the lambda conversion.
 */
static void conversionError(ParserInfo I, char *message, ...) {
    va_list args;
    va_start(args, message);
    vfprintf(errout, message, args);
    va_end(args);
    can_happen(" at +%d %s", I.lineno, I.filename);
}

/**
 * @brief Creates a value that can be returned in the case of an error
 */
static LamExp *lamExpError(ParserInfo I) {
    return newLamExp_Var(I, errorSymbol());
}

/**
 * @brief Adds the current namespace to the lambda context.
 * 
 * Adds the `$namespace` symbol to the current context, bound to the
 * current namespace id.
 *
 * @param context The lambda context to modify.
 * @param namespaceId The ID of the current namespace.
 * @return void
 */
static void addCurrentNamespaceToContext(LamContext *context, int namespaceId) {
    LamInfo *lamInfo = newLamInfo_Nsid(CPI(context), namespaceId);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, namespaceSymbol(), lamInfo);
    UNPROTECT(save);
}

/**
 * @brief Converts an AST program to a lambda expression.
 *
 * This is the top-level public entry point to the lambda conversion
 * code.
 *
 * @param prog The AST program to convert.
 * @return The resulting lambda expression.
 */
LamExp *lamConvertProg(AstProg *prog) {
    ENTER(lamConvertProg);
    inPreamble = true;
    LamContext *env = newLamContext(CPI(prog), NULL);
    int save = PROTECT(env);
    addCurrentNamespaceToContext(env, NS_GLOBAL);
    LamExp *result = lamConvert(prog->preamble, prog->namespaces, prog->body, env);
    UNPROTECT(save);
    LEAVE(lamConvertProg);
    return result;
}

/**
 * @brief Converts an AST nest to a lambda expression.
 *
 * @param nest The AST nest to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda expression.
 */
static LamExp *convertNest(AstNest *nest, LamContext *env) {
    ENTER(convertNest);
    env = newLamContext(CPI(nest), env);
    int save = PROTECT(env);
    LamExp *result = lamConvert(nest->definitions, NULL, nest->expressions, env);
    PROTECT(result);
    UNPROTECT(save);
    LEAVE(convertNest);
    return result;
}

/**
 * @brief Adds constructor information to the lambda context.
 *
 * @param context The lambda context to modify.
 * @param symbol The name of the constructor.
 * @param info The constructor information to add.
 * @return void
 */
static void addConstructorInfoToLamContext(LamContext *context,
                                           HashSymbol *symbol,
                                           LamTypeConstructorInfo *info) {
    LamInfo *lamInfo = newLamInfo_TypeConstructorInfo(CPI(context), info);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, symbol, lamInfo);
    UNPROTECT(save);
}

/**
 * @brief Adds namespace information to the lambda context.
 *
 * The information stored is the context resulting from converting the AST namespace.
 * That context is stored against a key generated from the namespace id (so it is recoverable).
 * The key contains non-alphanumeric characters so it cannot conflict with identifiers in the AST.
 *
 * @param context The lambda context to modify.
 * @param info The lambda context of the namespace.
 * @param namespace The ID of the namespace.
 * @return void
 */
static void addNamespaceInfoToLamContext(LamContext *context, LamContext *info, Index namespace) {
    char buf[80];
    sprintf(buf, NS_FORMAT, namespace); // ns$%u
    HashSymbol *symbol = newSymbol(buf);
    LamInfo *lamInfo = newLamInfo_NamespaceInfo(CPI(context), info);
    int save = PROTECT(lamInfo);
    setLamInfoTable(context->frame, symbol, lamInfo);
    UNPROTECT(save);
}

/**
 * @brief converts a namespace and pushes it on to the growing lambda namespace array.
 *
 * @param nsArray The AST namespace array to retrieve the namespace from.
 * @param i The index of the namespace in the array.
 * @param env The lambda context to use.
 * @param namespaces The lambda namespace array to push the converted namespace into.
 * @return void
 */
static void convertNamespace(AstNamespaceArray *nsArray,
                             Index i,
                             LamContext *env,
                             LamNamespaceArray *namespaces) {
    AstNamespaceImpl *namespace = nsArray->entries[i];
    LamContext *nsEnv = newLamContext(CPI(env), env);
    int save2 = PROTECT(nsEnv);
    addCurrentNamespaceToContext(nsEnv, (int)i);
    AstExpression *envToken = newAstExpression_Env(CPI(namespace));
    PROTECT(envToken);
    AstExpressions *body = newAstExpressions(CPI(namespace), envToken, NULL);
    PROTECT(body);
    LamExp *lamNamespace = lamConvert(namespace->definitions, NULL, body, nsEnv);
    PROTECT(lamNamespace);
    pushLamNamespaceArray(namespaces, lamNamespace);
    addNamespaceInfoToLamContext(env, nsEnv, i);
    UNPROTECT(save2);
}

/**
 * @brief Workhorse routine that converts various nest-like scenarios to a common LamExp
 *
 * @param definitions If there were definitions.
 * @param nsArray namespaces collected during parsing to be converted and attached
 * @param expressions The AST expressions to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda expression.
 */
static LamExp *lamConvert(AstDefinitions *definitions,
                          AstNamespaceArray *nsArray,
                          AstExpressions *expressions,
                          LamContext *env) {
    ENTER(lamConvert);
    collectAliases(definitions, env);
    LamTypeDefList *typeDefList = collectTypeDefs(definitions, env);
    int save = PROTECT(typeDefList);
    LamLetRecBindings *funcDefsList = convertFuncDefs(definitions, env);
    PROTECT(funcDefsList);
    funcDefsList = makePrintFunctions(typeDefList, funcDefsList, env);
    PROTECT(funcDefsList);
    LamNamespaceArray *namespaces = NULL;
    if (nsArray != NULL) {
        inPreamble = false; // dodgy, we must be in the preamble because we're being called with namespaces
        namespaces = newLamNamespaceArray();
        PROTECT(namespaces);
        for (Index i = 0; i < nsArray->size; ++i) {
            convertNamespace(nsArray, i, env, namespaces);
        }
    }
    LamSequence *body = convertSequence(expressions, env);
    PROTECT(body);
    if (namespaces != NULL && namespaces->size > 0) {
        LamExp *lamNamespaces = newLamExp_Namespaces(CPI(env), namespaces);
        PROTECT(lamNamespaces);
        body = newLamSequence(CPI(env), lamNamespaces, body);
        PROTECT(body);
    }
    LamExp *letRecBody = newLamExp_Sequence(CPI(body), body);
    PROTECT(letRecBody);
    LamExp *result = NULL;
    if (funcDefsList != NULL) {
        LamLetRec *letRec =
            newLamLetRec(CPI(letRecBody), funcDefsList, letRecBody);
        PROTECT(letRec);
        result = newLamExp_Letrec(CPI(letRec), letRec);
    } else {
        result = newLamExp_Sequence(CPI(body), body);
    }
    PROTECT(result);
    if (typeDefList != NULL) {
        LamTypeDefs *typeDefs = newLamTypeDefs(CPI(typeDefList), typeDefList, result);
        PROTECT(typeDefs);
        result =
            newLamExp_Typedefs(CPI(typeDefs), typeDefs);
    }
    UNPROTECT(save);
    LEAVE(lamConvert);
    return result;
}

/**
 * @brief Converts an AST If Expression to a lambda expression.
 *
 * @param iff The If Expression to convert.
 * @param context The lambda context to use.
 * @return The resulting lambda expression.
 */

static LamExp *lamConvertIff(AstIff *iff, LamContext *context) {
    ENTER(lamConvertIff);
    LamExp *test = convertExpression(iff->test, context);
    int save = PROTECT(test);
    LamExp *consequent = convertNest(iff->consequent, context);
    PROTECT(consequent);
    LamExp *alternative = convertNest(iff->alternative, context);
    PROTECT(alternative);
    LamIff *lamIff = newLamIff(CPI(test), test, consequent, alternative);
    PROTECT(lamIff);
    LamExp *result = newLamExp_Iff(CPI(test), lamIff);
    UNPROTECT(save);
    LEAVE(lamConvertIff);
    return result;
}

/**
 * @brief Converts an AST Print Expression to a lambda expression.
 *
 * @param print The AST Print Expression to convert.
 * @param context The lambda context to use.
 * @return The resulting lambda expression.
 */
static LamExp *lamConvertPrint(AstPrint *print, LamContext *context) {
    ENTER(lamConvertPrint);
    LamExp *exp = convertExpression(print->exp, context);
    int save = PROTECT(exp);
    LamPrint *lamPrint = newLamPrint(CPI(exp), exp);
    PROTECT(lamPrint);
    LamExp *result = newLamExp_Print(CPI(lamPrint), lamPrint);
    UNPROTECT(save);
    LEAVE(lamConvertPrint);
    return result;
}

/**
 * @brief Converts an AST Typeof Expression to a lambda expression that returns the type as a string.
 *
 * @param typeofExp The AST Typeof Expression to convert.
 * @param context The lambda context to use.
 * @return The resulting lambda expression.
 */
static LamExp *lamConvertTypeof(AstTypeof *typeofExp, LamContext *context) {
    ENTER(lamConvertTypeof);
    LamExp *exp = convertExpression(typeofExp->exp, context);
    int save = PROTECT(exp);
    LamTypeof *lamTypeof = newLamTypeof(CPI(exp), exp);
    PROTECT(lamTypeof);
    LamExp *result = newLamExp_TypeOf(CPI(lamTypeof), lamTypeof);
    UNPROTECT(save);
    LEAVE(lamConvertTypeof);
    return result;
}

/**
 * @brief Converts an AST Tuple Expression to a lambda expression that constructs a tuple.
 *
 * @param tuple The Tuple Expression to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda expression.
 */
static LamExp *lamConvertTuple(ParserInfo PI, AstExpressions *tuple, LamContext *env) {
    LamArgs *expressions = convertExpressions(tuple, env);
    int save = PROTECT(expressions);
    LamExp *res = newLamExp_Make_tuple(PI, expressions);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Converts an AST Lookup Expression (namespace dereference) to a lambda expression.
 *
 * @param lookup The Lookup Expression to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda expression.
 */
static LamExp *lamConvertLookup(AstLookup *lookup, LamContext *env) {
    LamContext *nsEnv = lookupNamespaceInLamContext(env, lookup->nsid);
    LamExp *expression = convertExpression(lookup->expression, nsEnv);
    int save = PROTECT(expression);
    LamLookup *llu = newLamLookup(CPI(lookup), lookup->nsid, lookup->nsSymbol, expression);
    PROTECT(llu);
    LamExp *res = newLamExp_Lookup(CPI(lookup), llu);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Checks if a particular definition is a macro, and if so, adds it to the macro table in the environment.
 *
 * @param definition The AST definition to check.
 * @param env The lambda context to use.
 * @return void
 */
static void checkMacro(AstDefinition *definition, LamContext *env) {
    if (definition->type == AST_DEFINITION_TYPE_MACRO) {
        setLamMacroSet(env->macros, definition->val.macro->name);
    }
}

/**
 * @brief Converts a list of AST function definitions to a list of letrec bindings.
 *
 * @param definitions The AST function definitions to convert.
 * @param env The lambda context to use.
 * @return The resulting list of letrec bindings.
 */
static LamLetRecBindings *convertFuncDefs(AstDefinitions *definitions, LamContext *env) {
    ENTER(convertFuncDefs);
    if (definitions == NULL) {
        LEAVE(convertFuncDefs);
        return NULL;
    }
    checkMacro(definitions->definition, env);
    LamLetRecBindings *next = convertFuncDefs(definitions->next, env);
    int save = PROTECT(next);
    LamLetRecBindings *this =
        prependDefinition(definitions->definition, env, next);
    UNPROTECT(save);
    LEAVE(convertFuncDefs);
    return this;
}

/**
 * @brief Converts a list of AST type symbols to a list of lambda type signature arguments.
 *
 * @param symbols The AST type symbols to convert.
 * @return The resulting lambda type signature arguments.
 */
static LamTypeSigArgs *convertTypeSymbols(AstTypeSymbols *symbols) {
    if (symbols == NULL)
        return NULL;
    LamTypeSigArgs *next = convertTypeSymbols(symbols->next);
    int save = PROTECT(next);
    LamTypeSigArgs *this = newLamTypeSigArgs(CPI(symbols), symbols->typeSymbol, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Converts an AST Type Signature to a lambda type signature.
 *
 * @param typeSig The AST Type Signature to convert.
 * @return The resulting lambda type signature.
 */
static LamTypeSig *convertTypeSig(AstTypeSig *typeSig) {
    LamTypeSigArgs *args = convertTypeSymbols(typeSig->typeSymbols);
    int save = PROTECT(args);
    LamTypeSig *res = newLamTypeSig(CPI(typeSig), typeSig->symbol, args);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Converts an AST Lookup Symbol to a lambda lookup symbol.
 *
 * @param ls The AST Lookup Symbol to convert.
 * @return The resulting lambda lookup symbol.
 */
static LamLookupSymbol *convertAstLookupSymbol(AstLookupSymbol *ls) {
    return newLamLookupSymbol(CPI(ls), ls->nsid, ls->nsSymbol, ls->symbol);
}


/**
 * @brief Converts an AST LookupOrSymbol to a lambda LookupOrSymbol.
 *
 * @param los The AST LookupOrSymbol to convert.
 * @return The resulting lambda LookupOrSymbol.
 */
static LamLookupOrSymbol *convertAstLookupOrSymbol(AstLookupOrSymbol *los) {
    switch (los->type) {
        case AST_LOOKUPORSYMBOL_TYPE_SYMBOL:
            return newLamLookupOrSymbol_Symbol(CPI(los), los->val.symbol);
        case AST_LOOKUPORSYMBOL_TYPE_LOOKUP:{
            LamLookupSymbol *ls = convertAstLookupSymbol(los->val.lookup);
            int save = PROTECT(ls);
            LamLookupOrSymbol *llos = newLamLookupOrSymbol_Lookup(CPI(los), ls);
            UNPROTECT(save);
            return llos;
        }
        default:
            cant_happen("unrecognized %s", astLookupOrSymbolTypeName(los->type));
    }
}

/**
 * @brief Checks to see if a symbol is an alias for a type constructor invocation.
 *
 * @param los The AST LookupOrSymbol to check.
 * @param env The lambda context to use.
 * @return The resulting lambda type constructor type, or NULL if not found.
 */
static LamTypeConstructorType *expandSymbolAlias(AstLookupOrSymbol *los, LamContext *env) {
    switch (los->type) {
        case LAMLOOKUPORSYMBOL_TYPE_SYMBOL: {
                LamTypeConstructorType *found =
                    lookupConstructorTypeInLamContext(env, los->val.symbol);
                if (found != NULL) {
                    return found;
                }
                return NULL;
            }
        case LAMLOOKUPORSYMBOL_TYPE_LOOKUP:
            return NULL;
        default:
            cant_happen("unrecognized %s", astLookupOrSymbolTypeName(los->type));
    }
}

/**
 * @brief checks to see if a type function is actually an alias for another.
 * 
 * @param function The AST type function to check.
 * @param env The lambda context to use.
 * @return The resulting lambda type constructor type, either original or alias.
 */
static LamTypeConstructorType *expandFunctionAlias(AstTypeFunction *function, LamContext *env) {
    if (function->typeList != NULL) {
        return NULL;
    }
    return expandSymbolAlias(function->symbol, env);
}

/**
 * @brief Converts an AST Type Function to a lambda type function.
 *
 * @param astTypeFunction The AST Type Function to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda type function.
 */
static LamTypeFunction *convertAstTypeFunction(AstTypeFunction *astTypeFunction, LamContext *env) {
    LamTypeConstructorArgs *lamTypeConstructorArgs =
        convertAstTypeList(astTypeFunction->typeList, env);
    int save = PROTECT(lamTypeConstructorArgs);
    LamLookupOrSymbol *los = convertAstLookupOrSymbol(astTypeFunction->symbol);
    PROTECT(los);
    LamTypeFunction *this = newLamTypeFunction(CPI(los), los, lamTypeConstructorArgs);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Converts an AST Type Clause to a lambda type constructor type.
 *
 * @param astTypeClause The AST Type Clause to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda type constructor type.
 */
static LamTypeConstructorType *convertAstTypeClause(AstTypeClause *astTypeClause, LamContext *env) {
    switch (astTypeClause->type) {
        case AST_TYPECLAUSE_TYPE_INTEGER:
            return newLamTypeConstructorType_Integer(CPI(astTypeClause));
        case AST_TYPECLAUSE_TYPE_CHARACTER:
            return newLamTypeConstructorType_Character(CPI(astTypeClause));
        case AST_TYPECLAUSE_TYPE_VAR:
            return newLamTypeConstructorType_Var(CPI(astTypeClause), astTypeClause->val.var);
        case AST_TYPECLAUSE_TYPE_TYPEFUNCTION:{
                LamTypeConstructorType *alias = expandFunctionAlias(astTypeClause->val.typeFunction, env);
                if (alias != NULL) {
                    return alias;
                }
                LamTypeFunction *lamTypeFunction =
                    convertAstTypeFunction(astTypeClause->val.typeFunction, env);
                int save = PROTECT(lamTypeFunction);
                LamTypeConstructorType *this =
                    newLamTypeConstructorType_Function(CPI(astTypeClause), lamTypeFunction);
                UNPROTECT(save);
                return this;
            }
        case AST_TYPECLAUSE_TYPE_TYPETUPLE: {
            LamTypeConstructorArgs *lamTypeConstructorArgs =
                convertAstTypeList(astTypeClause->val.typeTuple, env);
            int save = PROTECT(lamTypeConstructorArgs);
            LamTypeConstructorType *this =
                newLamTypeConstructorType_Tuple(CPI(astTypeClause), lamTypeConstructorArgs);
            UNPROTECT(save);
            return this;
        }
        default:
            cant_happen
                ("unrecognised astTypeClause type %d in convertAstTypeClause",
                 astTypeClause->type);
    }
}

/**
 * @brief Creates a lambda type function representing a function from one type to another.
 *
 * @param lhs The left-hand side type constructor.
 * @param rhs The right-hand side type constructor.
 * @return The resulting lambda type function.
 */
static LamTypeFunction *makeArrow(LamTypeConstructorType *lhs,
                                  LamTypeConstructorType *rhs) {
    LamTypeConstructorArgs *rhsArg = newLamTypeConstructorArgs(CPI(rhs), rhs, NULL);
    int save = PROTECT(rhsArg);
    LamTypeConstructorArgs *argss = newLamTypeConstructorArgs(CPI(lhs), lhs, rhsArg);
    PROTECT(argss);
    LamLookupOrSymbol *los = newLamLookupOrSymbol_Symbol(CPI(lhs), arrowSymbol());
    PROTECT(los);
    LamTypeFunction *res = newLamTypeFunction(CPI(lhs), los, argss);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Converts an AST Type to a lambda type constructor type.
 *
 * This function handles both simple types and function types.
 *
 * @param astType The AST Type to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda type constructor type.
 */
static LamTypeConstructorType *convertAstType(AstType *astType, LamContext *env) {
    if (astType->next) {        // it's a function
        LamTypeConstructorType *next = convertAstType(astType->next, env);
        int save = PROTECT(next);
        LamTypeConstructorType *this =
            convertAstTypeClause(astType->typeClause, env);
        PROTECT(this);
        LamTypeFunction *arrow = makeArrow(this, next);
        PROTECT(arrow);
        LamTypeConstructorType *res =
            newLamTypeConstructorType_Function(CPI(astType), arrow);
        UNPROTECT(save);
        return res;
    } else {
        return convertAstTypeClause(astType->typeClause, env);
    }
}

/**
 * @brief Converts an AST Type List to a list of lambda type constructor arguments.
 *
 * @param typeList The AST Type List to convert.
 * @param env The lambda context to use.
 * @return The resulting list of lambda type constructor arguments.
 */
static LamTypeConstructorArgs *convertAstTypeList(AstTypeList *typeList, LamContext *env) {
    if (typeList == NULL)
        return NULL;
    LamTypeConstructorArgs *next = convertAstTypeList(typeList->next, env);
    int save = PROTECT(next);
    LamTypeConstructorType *arg = convertAstType(typeList->type, env);
    PROTECT(arg);
    LamTypeConstructorArgs *this = newLamTypeConstructorArgs(CPI(arg), arg, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Converts an AST Type Map to a list of lambda type constructor arguments.
 *
 * @param typeMap The AST Type Map to convert.
 * @param env The lambda context to use.
 * @return The resulting list of lambda type constructor arguments.
 */
static LamTypeConstructorArgs *convertAstTypeMap(AstTypeMap *typeMap, LamContext *env) {
    if (typeMap == NULL)
        return NULL;
    LamTypeConstructorArgs *next = convertAstTypeMap(typeMap->next, env);
    int save = PROTECT(next);
    LamTypeConstructorType *arg = convertAstType(typeMap->type, env);
    PROTECT(arg);
    LamTypeConstructorArgs *this = newLamTypeConstructorArgs(CPI(arg), arg, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Converts AST Type Constructor Arguments (list or map) to a list of lambda type constructor arguments.
 *
 * @param args The AST Type Constructor Arguments to convert.
 * @param env The lambda context to use.
 * @return The resulting list of lambda type constructor arguments.
 */
static LamTypeConstructorArgs *convertAstTypeConstructorArgs(AstTypeConstructorArgs *args, LamContext *env) {
    if (args == NULL) {
        return NULL;
    }
    switch (args->type) {
        case AST_TYPECONSTRUCTORARGS_TYPE_LIST:{
            return convertAstTypeList(args->val.list, env);
        }
        case AST_TYPECONSTRUCTORARGS_TYPE_MAP:{
            return convertAstTypeMap(args->val.map, env);
        }
        default:
            cant_happen("unrecognized %s", astTypeConstructorArgsTypeName(args->type));
    }
}

/**
 * @brief Converts an AST Type Map to a list of lambda type tags.
 *
 * This function recursively converts the AST Type Map into a linked list of
 * LamTypeTags.
 *
 * @param map The AST Type Map to convert.
 * @return The resulting list of lambda type tags.
 */
static LamTypeTags *astTypeConstructorArgMapToTags(AstTypeMap *map) {
    if (map == NULL) return NULL;
    LamTypeTags *next = astTypeConstructorArgMapToTags(map->next);
    int save = PROTECT(next);
    LamTypeTags *this = newLamTypeTags(CPI(map), map->key, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief converts the AST Type Constructor Arguments to a list of lambda type tags, IFF
 * the arguments are a map.
 *
 * @param args The AST Type Constructor Arguments to convert.
 * @return The resulting list of lambda type tags, or NULL if the arguments are not a map.
 */
static LamTypeTags *makeLamTypeTags(AstTypeConstructorArgs *args) {
    if (args == NULL) {
        return NULL;
    }
    switch (args->type) {
        case AST_TYPECONSTRUCTORARGS_TYPE_LIST:
            return NULL;
        case AST_TYPECONSTRUCTORARGS_TYPE_MAP:
            return astTypeConstructorArgMapToTags(args->val.map);
        default:
            cant_happen("unrecognized %s", astTypeConstructorArgsTypeName(args->type));
    }
}

/**
 * @brief Collects as much type information as possible about the type constructor and stores it in the context.
 */
static void collectTypeInfo(HashSymbol *symbol,
                            AstTypeConstructorArgs *args,
                            LamTypeConstructor *type,
                            bool needsVec,
                            int enumCount,
                            int index,
                            int arity,
                            LamContext *env) {
    ENTER(collectTypeInfo);
    int namespace = lookupCurrentNamespaceInLamContext(env);
    LamTypeTags *tags = makeLamTypeTags(args);
    int save = PROTECT(tags);
    LamTypeConstructorInfo *info =
        newLamTypeConstructorInfo(CPI(type), symbol, namespace, type, tags, needsVec,
                                  arity, enumCount, index);
    PROTECT(info);
    addConstructorInfoToLamContext(env, symbol, info);
    UNPROTECT(save);
    LEAVE(collectTypeInfo);
}

/**
 * @brief counts the number of items in the AST Type Constructor Arguments (list or map).
 *
 * @param args The AST Type Constructor Arguments to count.
 * @return The number of items in the arguments.
 */
static Index countAstTypeConstructorArgs(AstTypeConstructorArgs *args) {
    if (args == NULL) return 0;
    switch (args->type) {
        case AST_TYPECONSTRUCTORARGS_TYPE_LIST:{
            return countAstTypeList(args->val.list);
        }
        case AST_TYPECONSTRUCTORARGS_TYPE_MAP:{
            return countAstTypeMap(args->val.map);
        }
        default:
            cant_happen("unrecognized %s", astTypeConstructorArgsTypeName(args->type));
    }
}

/**
 * @brief Converts an AST Type Constructor to a lambda type constructor and collects its type information.
 *
 * @param typeConstructor The AST Type Constructor to convert.
 * @param type The type signature of the constructor type.
 * @param enumCount The number of constructors of this type.
 * @param index The index of the constructor (serves as an identifier).
 * @param needsVec Whether the constructor needs to create a vector.
 * @return The resulting lambda type constructor.
 */
static LamTypeConstructor *convertTypeConstructor(AstTypeConstructor *typeConstructor,
                                                  LamTypeSig *type,
                                                  int enumCount,
                                                  int index,
                                                  bool needsVec,
                                                  LamContext *env) {
    int nargs = countAstTypeConstructorArgs(typeConstructor->args);
    LamTypeConstructorArgs *args =
        convertAstTypeConstructorArgs(typeConstructor->args, env);
    int save = PROTECT(args);
    LamTypeConstructor *lamTypeConstructor =
        newLamTypeConstructor(CPI(type), typeConstructor->symbol, type, args);
    PROTECT(lamTypeConstructor);
    collectTypeInfo(typeConstructor->symbol, typeConstructor->args, lamTypeConstructor, needsVec,
                    enumCount, index, nargs, env);
    UNPROTECT(save);
    return lamTypeConstructor;
}

/**
 * @brief Converts an AST Type Definition to a lambda type definition.
 *
 * @param typeDef The AST Type Definition to convert.
 * @param env The lambda context.
 * @return The resulting lambda type definition.
 */
static LamTypeDef *convertTypeDef(AstTypeDef *typeDef, LamContext *env) {
    LamTypeSig *type = convertTypeSig(typeDef->typeSig);
    int save = PROTECT(type);
    AstTypeBody *typeBody = typeDef->typeBody;
    bool needsVec = typeHasFields(typeBody);
    int enumCount = countAstTypeBody(typeBody);
    int index = 0;
    LamTypeConstructorList *lamTypeConstructorList = NULL;
    int save2 = PROTECT(type);
    while (typeBody != NULL) {
        LamTypeConstructor *lamTypeConstructor =
            convertTypeConstructor(typeBody->typeConstructor,
                                   type,
                                   enumCount,
                                   index,
                                   needsVec,
                                   env);
        int save3 = PROTECT(lamTypeConstructor);
        lamTypeConstructorList =
            newLamTypeConstructorList(CPI(lamTypeConstructor), lamTypeConstructor,
                                      lamTypeConstructorList);
        REPLACE_PROTECT(save2, lamTypeConstructorList);
        UNPROTECT(save3);
        typeBody = typeBody->next;
        index++;
    }
    LamTypeDef *res = newLamTypeDef(CPI(type), type, lamTypeConstructorList);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Collects an alias definition and adds it to the lambda context.
 *
 * @param alias The AST Alias to collect.
 * @param env The lambda context to use.
 * @return void
 */
static void collectAlias(AstAlias *alias, LamContext *env) {
    LamTypeConstructorType *type = convertAstType(alias->type, env);
    int save = PROTECT(type);
    setLamAliasTable(env->aliases, alias->name, type);
    UNPROTECT(save);
}

/**
 * @brief recurses over a list of definitions, collecting any aliases in the context.
 *
 * @param definitions The list of AST definitions to process.
 * @param env The lambda context to populate.
 * @return void
 */
static void collectAliases(AstDefinitions *definitions, LamContext *env) {
    if (definitions == NULL) {
        return;
    }
    switch (definitions->definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
        case AST_DEFINITION_TYPE_BLANK:
        case AST_DEFINITION_TYPE_TYPEDEF:
        case AST_DEFINITION_TYPE_MACRO:
        case AST_DEFINITION_TYPE_MULTI:
            break;
        case AST_DEFINITION_TYPE_ALIAS:
            collectAlias(definitions->definition->val.alias, env);
            break;
        default:
            cant_happen("unrecognised %s", astDefinitionTypeName(definitions->definition->type));
    }
    collectAliases(definitions->next, env);
}

/**
 * @brief extracts the hash symbol from a macro argument (which must be a symbol).
 *
 * calls cant_happen if the argument is not a symbol, which is a fatal error.
 * 
 * @param arg The AST macro argument to convert.
 * @return The contained hash symbol.
 */
static HashSymbol *convertMacroArg(AstFarg *arg) {
    switch (arg->type) {
        case AST_FARG_TYPE_SYMBOL:
            return arg->val.symbol;
        case AST_FARG_TYPE_WILDCARD:
        case AST_FARG_TYPE_LOOKUP:
        case AST_FARG_TYPE_NAMED:
        case AST_FARG_TYPE_UNPACK:
        case AST_FARG_TYPE_UNPACKSTRUCT:
        case AST_FARG_TYPE_NUMBER:
        case AST_FARG_TYPE_CHARACTER:
        case AST_FARG_TYPE_TUPLE:
            // should have been caught in the parser
            cant_happen("unexpected %s", astFargTypeName(arg->type));
        default:
            cant_happen("unrecognized %s", astFargTypeName(arg->type));
    }
}

/**
 * @brief Checks against duplicate macro arguments in a list.
 *
 * @param arg The macro argument to check.
 * @param args The list of existing macro arguments.
 * @return void
 */
static void checkDuplicateMacroArg(HashSymbol *arg, LamVarList *args) {
    if (args == NULL) return;
    if (arg == args->var) {
        conversionError(CPI(args), "duplicate argument \"%s\" in macro definition", arg->name);
        return;
    }
    checkDuplicateMacroArg(arg, args->next);
}

/**
 * @brief Collects macro arguments from an AST argument list.
 *
 * This function recursively collects macro arguments and both
 * checks for duplicates and asserts that the arguments are symbols.
 *
 * @param argList The AST argument list to collect from.
 * @return A linked list of lambda variable arguments.
 */
static LamVarList *collectMacroArgs(AstFargList *argList) {
    if (argList == NULL) return NULL;
    LamVarList *next = collectMacroArgs(argList->next);
    int save = PROTECT(next);
    HashSymbol *arg = convertMacroArg(argList->arg);
    checkDuplicateMacroArg(arg, next);
    LamVarList *this = newLamVarList(CPI(argList), arg, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Populates a lambda macro arguments table from a list of arguments.
 *
 * This function iterates over the list of lambda variable arguments and adds each one
 * to the macro arguments table with a NULL value.
 * 
 * @param symbols The macro arguments table to populate.
 * @param args The list of lambda variable arguments.
 * @return void
 */
static void populateArgsTable(LamMacroArgsSet *symbols, LamVarList *args) {
    if (args == NULL) return;
    setLamMacroArgsSet(symbols, args->var);
    populateArgsTable(symbols, args->next);
}

/**
 * @brief Converts an AST Macro Definition to a lambda expression.
 *
 * This function converts the macro definition into a lambda expression.
 * Macros evaluate their arguments on-demand, so the generated macro
 * must wrap each of its arguments in a promise.
 *
 * @param astMacro The AST Macro Definition to convert.
 * @param env The lambda context to use.
 * @return The resulting lambda expression for the macro.
 */
static LamExp *convertAstMacro(AstDefMacro *astMacro, LamContext *env) {
    ENTER(convertAstMacro);
    LamVarList *args = collectMacroArgs(astMacro->definition->altArgs->argList);
    int save = PROTECT(args);
    LamExp *body = convertNest(astMacro->definition->nest, env);
    PROTECT(body);
    LamMacroArgsSet *symbolTable = newLamMacroArgsSet();
    PROTECT(symbolTable);
    populateArgsTable(symbolTable, args);
    body = lamPerformMacroSubstitutions(body, symbolTable);
    PROTECT(body);
    LamLam *lam = newLamLam(CPI(astMacro), args, body);
    lam->isMacro = true;  // Mark this lambda as a macro (lazy arguments)
    PROTECT(lam);
    LamExp *res = newLamExp_Lam(CPI(lam), lam);
    PROTECT(res);
    setLamMacroSet(env->macros, astMacro->name);
    LEAVE(convertAstMacro);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Collects type definitions from a list of AST definitions.
 *
 * This function recursively collects type definitions from the AST
 * and converts them into lambda type definitions.
 *
 * @param definitions The AST definitions to collect from.
 * @param env The lambda context to use.
 * @return A linked list of lambda type definitions.
 */
static LamTypeDefList *collectTypeDefs(AstDefinitions *definitions, LamContext *env) {
    if (definitions == NULL) {
        return NULL;
    }
    switch (definitions->definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
        case AST_DEFINITION_TYPE_ALIAS:
        case AST_DEFINITION_TYPE_BLANK:
        case AST_DEFINITION_TYPE_MACRO:
        case AST_DEFINITION_TYPE_MULTI:
            return collectTypeDefs(definitions->next, env);
        case AST_DEFINITION_TYPE_TYPEDEF:{
                LamTypeDef *lamTypeDef = convertTypeDef(definitions->definition->val.typeDef, env);
                int save = PROTECT(lamTypeDef);
                LamTypeDefList *rest = collectTypeDefs(definitions->next, env);
                PROTECT(rest);
                LamTypeDefList *res = newLamTypeDefList(CPI(lamTypeDef), lamTypeDef, rest);
                UNPROTECT(save);
                return res;
            }
        default:
            cant_happen("unrecognised %s", astDefinitionTypeName(definitions->definition->type));
    }
}

/**
 * @brief Convert and prepend a macro to the list of letRec bindings.
 * @param macro The AST macro definition to convert.
 * @param env The lambda context to use.
 * @param next The letRec list to prepend to.
 * @return The new letRec bindings with the macro prepended.
 */
static LamLetRecBindings *prependMacro(AstDefMacro * macro, LamContext * env,
                                        LamLetRecBindings * next) {
    ENTER(prependMacro);
    LamExp *exp = convertAstMacro(macro, env);
    int save = PROTECT(exp);
    LamLetRecBindings *this =
        newLamLetRecBindings(CPI(macro), macro->name, exp, next);
    UNPROTECT(save);
    LEAVE(prependMacro);
    return this;
}

LamExp *makeUnpackTuple(ParserInfo PI, LamExp *temp, int index, int size) {
    LamTupleIndex *tupleIndex =
        newLamTupleIndex(PI, index, size, temp);
    int save = PROTECT(tupleIndex);
    LamExp *exp = newLamExp_Tuple_index(PI, tupleIndex);
    UNPROTECT(save);
    return exp;
}

static LamLetRecBindings *prependMultiSymbols(AstSymbolList *symbols,
                                              int index,
                                              int size,
                                              LamExp * temp,
                                              LamLetRecBindings * next) {
    if (symbols == NULL) {
        return next;
    }
    LamLetRecBindings *rest = prependMultiSymbols(symbols->next,
                                                  index + 1,
                                                  size,
                                                  temp,
                                                  next);
    int save = PROTECT(rest);
    LamExp *rhs = makeUnpackTuple(CPI(symbols), temp, index, size);
    PROTECT(rhs);
    LamLetRecBindings *this =
        newLamLetRecBindings(CPI(symbols), symbols->symbol, rhs, rest);
    UNPROTECT(save);
    return this;
}

static LamLetRecBindings *prependMulti(AstMultiDefine * multi, LamContext * env,
                                        LamLetRecBindings * next) {
    ENTER(prependMulti);
    LamExp *exp = convertExpression(multi->expression, env);
    int save = PROTECT(exp);
    HashSymbol *temp = genSymDollar("multi");
    LamExp *tempExp = newLamExp_Var(CPI(multi), temp);
    PROTECT(tempExp);
    LamLetRecBindings *parts = prependMultiSymbols(multi->symbols,
                                                   0,
                                                   countAstSymbolList(multi->symbols),
                                                   tempExp,
                                                   next);
    PROTECT(parts);
    LamLetRecBindings *this = newLamLetRecBindings(CPI(multi), temp, exp, parts);
    UNPROTECT(save);
    LEAVE(prependMulti);
    return this;
}

/**
 * @brief Prepends a definition to the list of letRec bindings.
 *
 * This function handles macros and definitions and converts them
 * into lambda letRec bindings.
 *
 * @param definition The AST definition to prepend.
 * @param env The lambda context to use.
 * @param next The next letRec binding in the list.
 * @return The new letRec bindings with the definition prepended.
 */
static LamLetRecBindings *prependDefinition(AstDefinition *definition,
                                            LamContext *env,
                                            LamLetRecBindings *next) {
    ENTER(prependDefinition);
    LamLetRecBindings *result = NULL;
    switch (definition->type) {
        case AST_DEFINITION_TYPE_DEFINE:
            result = prependDefine(definition->val.define, env, next);
            break;
        case AST_DEFINITION_TYPE_MACRO:
            result = prependMacro(definition->val.macro, env, next);
            break;
        case AST_DEFINITION_TYPE_MULTI:
            result = prependMulti(definition->val.multi, env, next);
            break;
        case AST_DEFINITION_TYPE_ALIAS:
        case AST_DEFINITION_TYPE_TYPEDEF:
        case AST_DEFINITION_TYPE_BLANK:
            result = next;
            break;
        default:
            cant_happen("unrecognised %s", astDefinitionTypeName(definition->type));
    }
    LEAVE(prependDefinition);
    return result;
}

/**
 * @brief Checks if a type body has any fields (i.e., type constructor arguments).
 *
 * This function iterates over the type body and checks if any type constructor
 * has arguments defined. This is done to determine if the type should be constructed
 * as a simple scalar or if it needs to be a vector.
 * 
 * For example in
 * ```
 * typedef colour { red | green | blue }
 * ```
 * because none of the constructors have arguments, they can all be represented as simple scalars.
 * Bit in the case of
 * ```
 * typedef list(#t) { null | cons(#t, list(#t))}
 * ```
 * because `cons` has fields, both `null` and `cons` need to be represented as vectors.
 *
 * @param typeBody The AST Type Body to check.
 * @return true if there are fields, false otherwise.
 */
static bool typeHasFields(AstTypeBody *typeBody) {
    ENTER(typeHasFields);
    while (typeBody != NULL) {
        if (typeBody->typeConstructor->args != NULL) {
            LEAVE(typeHasFields);
            return true;
        }
        typeBody = typeBody->next;
    }
    LEAVE(typeHasFields);
    return false;
}

/**
 * @brief Converts and prepends a definition to the list of letRec bindings.
 * @param define The AST definition to convert.
 * @param env The lambda context to use.
 * @param next The current letrec bindings.
 * @return The new letRec bindings with the definition prepended.
 */
static LamLetRecBindings *prependDefine(AstDefine * define, LamContext * env,
                                        LamLetRecBindings * next) {
    ENTER(prependDefine);
    bool doMermaid = (tpmc_mermaid_function != NULL
                      && strcmp(tpmc_mermaid_function,
                                define->symbol->name) == 0);
    if (doMermaid)
        tpmc_mermaid_flag = 1;
    LamExp *exp = convertExpression(define->expression, env);
    if (lambda_conversion_function != NULL && strcmp(lambda_conversion_function, define->symbol->name) == 0) {
        ppLamExp(exp);
        eprintf("\n");
    }
    if (doMermaid)
        tpmc_mermaid_flag = 0;
    int save = PROTECT(exp);
    LamLetRecBindings *this =
        newLamLetRecBindings(CPI(define), define->symbol, exp, next);
    UNPROTECT(save);
    LEAVE(prependDefine);
    return this;
}

#define CHECK_ONE_ARG(name, args) do { \
    int count = countLamArgs(args); \
    if (count != 1) \
        conversionError(CPI(args), "expected 1 arg in " #name ", got %d", count); \
} while(0)

#define CHECK_TWO_ARGS(name, args) do { \
    int count = countLamArgs(args); \
    if (count != 2) \
        conversionError(CPI(args), "expected 2 args in " #name ", got %d", count); \
} while(0)

/**
 * @brief Creates a call/cc expression.
 * 
 * @param args The arguments to the call/cc expression.
 * @return the lambda expression.
 */
static LamExp *makeCallCC(LamArgs *args) {
    CHECK_ONE_ARG(makeCallCC, args);
    return newLamExp_Callcc(CPI(args), args->exp);
}

/**
 * @brief Creates a binary operation expression.
 * 
 * @param opCode The operation code for the binary operation.
 * @param args The arguments to the binary operation.
 * @return The resulting lambda expression for the binary operation.
 */
static LamExp *makeBinOp(LamPrimOp opCode, LamArgs *args) {
    CHECK_TWO_ARGS(makeBinOp, args);
    LamPrimApp *app = newLamPrimApp(CPI(args), opCode, args->exp, args->next->exp);
    int save = PROTECT(app);
    LamExp *exp = newLamExp_Prim(CPI(app), app);
    UNPROTECT(save);
    return exp;
}

/**
 * @brief Creates a lambda expression for an "amb" operation.
 * @param args The arguments to the "amb" operation.
 * @return The resulting lambda expression.
 */
static LamExp *makeLamAmb(LamArgs *args) {
    CHECK_TWO_ARGS(makeLamAmb, args);
    LamAmb *lamAmb = newLamAmb(CPI(args), args->exp, args->next->exp);
    int save = PROTECT(lamAmb);
    LamExp *res = newLamExp_Amb(CPI(lamAmb), lamAmb);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Creates a unary negation expression.
 * @param args The arguments to the unary negation expression.
 * @return The resulting lambda expression.
 */
static LamExp *makeUnaryNeg(LamArgs *args) {
    CHECK_ONE_ARG(makeUnaryNeg, args);
    MaybeBigInt *num = fakeBigInt(0, false);
    int save = PROTECT(num);
    LamExp *zero = newLamExp_Biginteger(CPI(args), num);
    PROTECT(zero);
    args = newLamArgs(CPI(args), zero, args);
    PROTECT(args);
    LamExp *result = makeBinOp(LAMPRIMOP_TYPE_SUB, args);
    UNPROTECT(save);
    return result;
}

/**
 * @brief Checks if a symbol is a macro in the given environment.
 * @param symbol The symbol to check.
 * @param env The environment to search in.
 * @return True if the symbol is a macro, false otherwise.
 */
static bool isMacro(HashSymbol *symbol, LamContext *env) {
    if (env == NULL) {
        return false;
    }
    if (getLamMacroSet(env->macros, symbol)) {
        return true;
    }
    return isMacro(symbol, env->parent);
}

/**
 * @brief Wraps a macro argument in a thunk.
 * 
 * @description A thunk is a lambda with no arguments that returns the argument when called.
 * This allows macros to evaluate their arguments on-demand. The equivalent invocation of the thunk
 * is generated by `performVarSubstitution` in `macro_substitution.c`.
 * 
 * @param arg The argument to wrap.
 * @return The resulting thunked argument.
 */
static LamExp *thunkMacroArg(LamExp *arg) {
    LamLam *lambda = newLamLam(CPI(arg), NULL, arg);
    int save = PROTECT(lambda);
    LamExp *res = newLamExp_Lam(CPI(lambda), lambda);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Wraps the arguments of a macro in thunks.
 * @param args The arguments to wrap.
 * @return The resulting wrapped arguments.
 */
static LamArgs *wrapMacroArgs(LamArgs *args) {
    if (args == NULL) {
        return NULL;
    }
    LamArgs *next = wrapMacroArgs(args->next);
    int save = PROTECT(next);
    LamExp *arg = thunkMacroArg(args->exp);
    PROTECT(arg);
    LamArgs *this = newLamArgs(CPI(arg), arg, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Converts a macro application into a lambda expression, wrapping the arguments in thunks.
 * @param PI The parser information.
 * @param symbol The macro name.
 * @param args The arguments to the macro.
 * @return The resulting lambda expression.
 */
static LamExp *wrapMacro(ParserInfo PI, HashSymbol *symbol, LamArgs *args) {
    args = wrapMacroArgs(args);
    int save = PROTECT(args);
    LamExp *macro = newLamExp_Var(PI, symbol);
    PROTECT(macro);
    LamApply *apply = newLamApply(PI, macro, args);
    PROTECT(apply);
    LamExp *res = newLamExp_Apply(PI, apply);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Converts a macro application where the callee is an arbitrary expression
 *    (e.g., a namespaced lookup), wrapping the arguments in thunks.
 * @param PI The parser information.
 * @param callee The callee expression (can be a Lookup or Var).
 * @param args The arguments to the macro.
 * @return The resulting lambda expression.
 */
static LamExp *wrapMacroExp(ParserInfo PI, LamExp *callee, LamArgs *args) {
    args = wrapMacroArgs(args);
    int save = PROTECT(args);
    LamApply *apply = newLamApply(PI, callee, args);
    PROTECT(apply);
    LamExp *res = newLamExp_Apply(PI, apply);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Creates a lambda primitive application based on the symbol and arguments.
 * @param PI The parser information.
 * @param symbol The macro or operator name.
 * @param args The arguments to the macro.
 * @return The resulting lambda expression.
 */
static LamExp *makePrimApp(ParserInfo PI, HashSymbol *symbol, LamArgs *args, LamContext *env) {
    if (isMacro(symbol, env)) {
        return wrapMacro(PI, symbol, args);
    }
    if (symbol == negSymbol())
        return makeUnaryNeg(args);
    if (symbol == hereSymbol())
        return makeCallCC(args);
    if (symbol == thenSymbol())
        return makeLamAmb(args);
    if (symbol == eqSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_EQ, args);
    if (symbol == neSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_NE, args);
    if (symbol == gtSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_GT, args);
    if (symbol == ltSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_LT, args);
    if (symbol == geSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_GE, args);
    if (symbol == leSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_LE, args);
    if (symbol == addSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_ADD, args);
    if (symbol == subSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_SUB, args);
    if (symbol == mulSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_MUL, args);
    if (symbol == divSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_DIV, args);
    if (symbol == modSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_MOD, args);
    if (symbol == powSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_POW, args);
    if (symbol == cmpSymbol())
        return makeBinOp(LAMPRIMOP_TYPE_CMP, args);
    return NULL;
}

/**
 * @brief Provisionally creates a constructor application if the symbol is a constructor in the current env.
 * @param symbol The symbol.
 * @param env The environment to look in.
 * @return The resulting lambda expression, or NULL.
 */
static LamExp *makeConstructor(HashSymbol *symbol, LamContext *env) {
    LamTypeConstructorInfo *info = lookupConstructorInLamContext(env, symbol);
    if (info != NULL) {
        return newLamExp_Constructor(CPI(info), info);
    }
    return NULL;
}

/**
 * @brief Creates a lambda application.
 * @param fun The function expression.
 * @param args The arguments to apply the function to.
 * @return The resulting lambda application expression.
 */
static LamExp *makeApplication(LamExp *fun, LamArgs *args) {
    LamApply *apply = newLamApply(CPI(fun), fun, args);
    int save = PROTECT(apply);
    LamExp *result = newLamExp_Apply(CPI(apply), apply);
    UNPROTECT(save);
    return result;
}

/**
 * @brief Converts a list of bound variables to a list of lambda arguments.
 * @param list The list of bound variables.
 * @return The resulting list of lambda arguments.
 */
static LamArgs *varListToList(LamVarList *list) {
    if (list == NULL) return NULL;
    LamArgs *next = varListToList(list->next);
    int save = PROTECT(next);
    LamExp *var = newLamExp_Var(CPI(list), list->var);
    PROTECT(var);
    LamArgs *this = newLamArgs(CPI(var), var, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Generates a list of symbolic variables.
 * @param I The parser information.
 * @param nargs The number of arguments.
 * @return The resulting list of symbolic variables.
 */
static LamVarList *genSymVarList(ParserInfo I, int nargs) {
    if (nargs == 0) {
        return NULL;
    }
    LamVarList *rest = genSymVarList(I, nargs - 1);
    int save = PROTECT(rest);
    HashSymbol *s = genSym("$x");
    LamVarList *this = newLamVarList(I, s, rest);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Finds the underlying arity of a lambda expression.
 * 
 * This function checks if the expression is a constructor or a lookup,
 * and returns the arity of the constructor or recursively finds the arity
 * of the underlying expression in case of a lookup.
 *
 * @param exp The lambda expression to check.
 * @return The arity of the underlying constructor.
 */
static int findUnderlyingArity(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_CONSTRUCTOR:
            return exp->val.constructor->arity;
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingArity(exp->val.lookup->exp);
        default:
            cant_happen("expected lookup or constructor");
    }
}

/**
 * @brief Finds the underlying type of a lambda expression.
 * @param exp The lambda expression to check.
 * @return The type of the underlying constructor.
 */
static int findUnderlyingType(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingType(exp->val.lookup->exp);
        default:
            return exp->type;
    }
}

/**
 * @brief Finds the underlying value of a lambda expression.
 * 
 * This function recursively finds the underlying value of a lambda expression,
 * particularly useful for lookups that may wrap other expressions.
 *
 * @param exp The lambda expression to check.
 * @return The underlying lambda expression.
 */
static LamExp *findUnderlyingValue(LamExp *exp) {
    switch (exp->type) {
        case LAMEXP_TYPE_LOOKUP:
            return findUnderlyingValue(exp->val.lookup->exp);
        default:
            return exp;
    }
}

/**
 * @brief Checks if a tag (symbol) is present in the given list of tags.
 * @param tag The lambda tag to check for.
 * @param astTags The list of AST tags to search.
 */
static void checkLamTagPresent(HashSymbol *tag, AstTaggedExpressions *astTags) {
    if (astTags == NULL) {
        cant_happen("missing tag %s", tag->name);
    }
    if (tag == astTags->tag) {
        return;
    }
    checkLamTagPresent(tag, astTags->next);
}

/**
 * @brief Checks if all tags are present in the given list of tags.
 * @param lamTags The list of lambda tags to check.
 * @param astTags The list of AST tags to search.
 */
static void checkAllTagsPresent(LamTypeTags *lamTags, AstTaggedExpressions *astTags) {
    if (lamTags == NULL) return;
    checkLamTagPresent(lamTags->tag, astTags);
    checkAllTagsPresent(lamTags->next, astTags);
}

/**
 * @brief Checks if a specific AST tag is present in the list of lambda tags.
 * @param lamTags The list of lambda tags to check.
 * @param astTag The AST tag to search for.
 */
static void checkAstTagPresent(LamTypeTags *lamTags, HashSymbol *astTag) {
    if (lamTags == NULL) {
        cant_happen("missing constructor tag %s", astTag->name);
    }
    if (astTag == lamTags->tag) return;
    checkAstTagPresent(lamTags->next, astTag);
}

/**
 * @brief Checks if any unrecognised AST tags are present in the list of lambda tags.
 * @param lamTags The list of lambda tags to check.
 * @param astTags The list of AST tags to search.
 */
static void checkNoUnrecognisedTags(LamTypeTags *lamTags, AstTaggedExpressions *astTags) {
    if (astTags == NULL) return;
    checkAstTagPresent(lamTags, astTags->tag);
    checkNoUnrecognisedTags(lamTags, astTags->next);
}

/**
 * @brief Checks if a specific AST tag is present in the list of lambda tags.
 * @param lamTags The list of lambda tags to check.
 * @param astTag The AST tag to search for.
 */
static void checkTagNotDuplicate(HashSymbol *tag, AstTaggedExpressions *tags) {
    if (tags == NULL) return;
    if (tag == tags->tag) {
        conversionError(CPI(tags), "duplicate tag %s", tag->name);
        return;
    }
    checkTagNotDuplicate(tag, tags->next);
}

/**
 * @brief Checks if any duplicate tags are present in the list of AST tags.
 * @param tags The list of AST tags to check.
 */
static void checkNoDuplicateTags(AstTaggedExpressions *tags) {
    if (tags == NULL) return;
    checkTagNotDuplicate(tags->tag, tags->next);
    checkNoDuplicateTags(tags->next);
}

/**
 * @brief Finds the tagged expression for a given tag.
 * @param tag The tag to search for.
 * @param tags The list of tagged expressions to search.
 * @return The tagged expression.
 */
static AstExpression *findTaggedExpression(HashSymbol *tag, AstTaggedExpressions *tags) {
#ifdef SAFETY_CHECKS
    if (tags == NULL) {
        cant_happen("cannot find value for tag %s", tag->name);
    }
#endif
    if (tag == tags->tag) return tags->expression;
    return findTaggedExpression(tag, tags->next);
}

/**
 * @brief Arranges the AST tagged expressions in the canonical order of the lambda tags.
 * 
 * The result is a normal function application, without tags.
 * 
 * @param lamTags The list of lambda tags to arrange.
 * @param astTags The list of AST tags to search.
 * @param env The lambda context.
 */
static LamArgs *convertTagsToArgs(LamTypeTags *lamTags, AstTaggedExpressions *astTags, LamContext *env) {
    // lamTags are in canonical order
    if (lamTags == NULL) return NULL;
    LamArgs *rest = convertTagsToArgs(lamTags->next, astTags, env);
    int save = PROTECT(rest);
    AstExpression *expression = findTaggedExpression(lamTags->tag, astTags);
    LamExp *lamExp = convertExpression(expression, env);
    PROTECT(lamExp);
    LamArgs *this = newLamArgs(CPI(lamExp), lamExp, rest);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Allows a constructor application to be curried by wrapping it in a curried function application.
 *
 * Example:
 * (constructor4 arg1 arg2) =>
 * ((lambda (x1 x2 x3 x4) (constructor4 x1 x2 x3 x4)) arg1 arg2)
 *
 * @param constructor The constructor to apply.
 * @param args The arguments to apply to the constructor.
 * @return The curried constructor application.
 */
static LamExp *makeConstructorApplication(LamExp *constructor, LamArgs *args) {
    int nargs = (int) countLamArgs(args);
    LamExp *result;
    int arity = findUnderlyingArity(constructor);
    if (nargs < arity) {
        LamVarList *fargs = genSymVarList(CPI(constructor), arity);
        int save = PROTECT(fargs);
        LamArgs *aargs = varListToList(fargs);
        PROTECT(aargs);
        LamApply *innerApply = newLamApply(CPI(constructor), constructor, aargs);
        PROTECT(innerApply);
        LamExp *applyExp = newLamExp_Apply(CPI(innerApply), innerApply);
        PROTECT(applyExp);
        LamLam *lambda = newLamLam(CPI(fargs), fargs, applyExp);
        PROTECT(lambda);
        LamExp *lamExp = newLamExp_Lam(CPI(lambda), lambda);
        PROTECT(lamExp);
        LamApply *apply = newLamApply(CPI(lamExp), lamExp, args);
        PROTECT(apply);
        result = newLamExp_Apply(CPI(apply), apply);
        UNPROTECT(save);
    } else {
        LamApply *apply = newLamApply(CPI(constructor), constructor, args);
        int save = PROTECT(apply);
        result = newLamExp_Apply(CPI(apply), apply);
        UNPROTECT(save);
    }
    return result;
}
/**
 * @brief Creates a structure application from a constructor and a list of tagged expressions.
 * 
 * This function checks that the constructor is indeed a structure constructor,
 * verifies that all tags are present, checks for duplicates, and then creates
 * the application expression.
 *
 * @param constructor The constructor to apply.
 * @param tags The tagged expressions to apply to the constructor.
 * @param env The lambda context.
 * @return The resulting lambda expression for the structure application.
 */

static LamExp *makeStructureApplication(LamExp *constructor, AstTaggedExpressions *tags, LamContext *env) {
    if (constructor->val.constructor->tags == NULL) {
        conversionError(CPI(constructor), "non-struct constructor applied to struct");
        return lamExpError(CPI(tags));
    }
    checkAllTagsPresent(constructor->val.constructor->tags, tags);
    checkNoUnrecognisedTags(constructor->val.constructor->tags, tags);
    checkNoDuplicateTags(tags);
    int arity = findUnderlyingArity(constructor);
    int nargs = (int) countAstTaggedExpressions(tags);
    if (nargs != arity) {
        conversionError(CPI(constructor), "wrong number of args in structure application");
        return lamExpError(CPI(tags));
    }
    LamArgs *args = convertTagsToArgs(constructor->val.constructor->tags, tags, env);
    int save = PROTECT(args);
    LamApply *apply = newLamApply(CPI(constructor), constructor, args);
    PROTECT(apply);
    LamExp *result = newLamExp_Apply(CPI(apply), apply);
    UNPROTECT(save);
    return result;
}
/**
 * @brief Finds a constructor in the lambda context.
 *
 * This function looks up a constructor by its name in the given lambda context.
 * If the constructor is a lookup, find the constructor in the referenced namespace.
 *
 * @param los The lookup or symbol to find.
 * @param env The lambda context.
 * @return The found constructor information, or NULL if not found.
 */
static LamTypeConstructorInfo *findConstructor(AstLookupOrSymbol *los, LamContext *env) {
    switch (los->type) {
        case AST_LOOKUPORSYMBOL_TYPE_SYMBOL:{
            return lookupConstructorInLamContext(env, los->val.symbol);
        }
        break;
        case AST_LOOKUPORSYMBOL_TYPE_LOOKUP:{
            AstLookupSymbol *lookup = los->val.lookup;
            LamContext *nsEnv = lookupNamespaceInLamContext(env, lookup->nsid);
            return lookupConstructorInLamContext(nsEnv, lookup->symbol);
        }
        break;
        default:
            cant_happen("unrecognized %s", astLookupOrSymbolTypeName(los->type));
    }
}

/**
 * @brief Converts a structure AST node to a lambda expression.
 *
 * @param structure The structure AST node to convert.
 * @param env The lambda context.
 * @return The resulting lambda expression for the structure.
 */
static LamExp *convertStructure(AstStruct *structure, LamContext *env) {
    LamTypeConstructorInfo *info = findConstructor(structure->symbol, env);
    if (info == NULL) {
        conversionError(CPI(structure), "cannot find constructor");
        return lamExpError(CPI(structure));
    }
    LamExp *constructor = newLamExp_Constructor(CPI(info), info);
    int save = PROTECT(constructor);
    LamExp *result = makeStructureApplication(constructor, structure->expressions, env);
    if (structure->symbol->type == AST_LOOKUPORSYMBOL_TYPE_LOOKUP) {
        PROTECT(result);
        LamLookup *lookup = newLamLookup(CPI(result), info->nsid, structure->symbol->val.lookup->symbol, result);
        PROTECT(lookup);
        result = newLamExp_Lookup(CPI(lookup), lookup);
    }
    UNPROTECT(save);
    return result;
}

/**
 * @brief Converts a function call AST node to a lambda expression.
 *
 * This function takes a function call AST node and converts it into a
 * lambda expression by applying the function to its arguments.
 * The "function" in this case can be a variable, a constructor, or any
 * other expression that can be applied.
 *
 * @param funCall The function call AST node to convert.
 * @param env The lambda context.
 * @return The resulting lambda expression for the function call.
 */
static LamExp *convertFunCall(AstFunCall *funCall, LamContext *env) {
    LamArgs *args = convertExpressions(funCall->arguments, env);
    int save = PROTECT(args);
    LamExp *function = convertExpression(funCall->function, env);
    PROTECT(function);
    LamExp *result = NULL;
    // If the callee is a namespaced lookup, check macro-ness in that namespace env
    if (function->type == LAMEXP_TYPE_LOOKUP) {
        LamContext *nsEnv = lookupNamespaceInLamContext(env, function->val.lookup->nsid);
        LamExp *under = findUnderlyingValue(function);
        if (under->type == LAMEXP_TYPE_VAR && isMacro(under->val.var, nsEnv)) {
            result = wrapMacroExp(CPI(funCall), function, args);
            UNPROTECT(save);
            return result;
        }
    }
    switch (findUnderlyingType(function)) {
        case LAMEXP_TYPE_VAR:{
            LamExp *symbol = findUnderlyingValue(function);
            result = makePrimApp(CPI(funCall), symbol->val.var, args, env);
            if (result != NULL) {
                UNPROTECT(save);
                return result;
            }
            result = makeApplication(function, args);
            UNPROTECT(save);
            return result;
        }
        case LAMEXP_TYPE_CONSTRUCTOR:{
            result = makeConstructorApplication(function, args);
            UNPROTECT(save);
            return result;
        }
        default:{
            result = makeApplication(function, args);
            UNPROTECT(save);
            return result;
        }
    }
}

static AstFargList *rewriteAstFargList(AstFargList *args, LamContext *env);
static AstFarg *rewriteAstFarg(AstFarg *arg, LamContext *env);

/**
 * @brief Recursively rewrites the named component of an AstNamedArg.
 *
 * @param arg The AST formal argument to rewrite.
 * @param env The lambda context to use for rewriting.
 * @return The rewritten AstNamedArg wrapped in an AstFarg.
 */
static AstFarg *rewriteAstNamed(AstNamedArg *namedArg, LamContext *env) {
    AstFarg *arg = rewriteAstFarg(namedArg->arg, env);
    int save = PROTECT(arg);
    AstNamedArg *this = newAstNamedArg(CPI(namedArg), namedArg->name, arg);
    PROTECT(this);
    AstFarg *res = newAstFarg_Named(CPI(this), this);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Rewrites the components of an AstUnpack.
 * 
 * @param unpack The AstUnpack to rewrite.
 * @param env The lambda context to use for rewriting.
 * @return The rewritten AstUnpack, wrapped in an AstFarg.
 */
static AstFarg *rewriteAstUnpack(AstUnpack *unpack, LamContext *env) {
    AstFargList *args = rewriteAstFargList(unpack->argList, env);
    int save = PROTECT(args);
    AstUnpack *this = newAstUnpack(CPI(unpack), unpack->symbol, args);
    PROTECT(this);
    AstFarg *res = newAstFarg_Unpack(CPI(this), this);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Retrieves an AstFarg from an AST tagged argument list.
 * 
 * This function searches through the tagged argument list for a
 * matching tag and returns the corresponding AstFarg.
 * If no matching tag is found, a wildcard AstFarg is returned.
 * This allows a struct formal argument to not have to name unwanted fields.
 *
 * @param tag The tag to search for.
 * @param list The AST tagged argument list to search.
 * @param env The lambda context to use for rewriting.
 * @param I The parser information.
 * @return The corresponding AstFarg, or a wildcard if not found.
 */
static AstFarg *getAstFargFromTaggedArgList(HashSymbol *tag, AstTaggedArgList *list, LamContext *env, ParserInfo I) {
    if (list == NULL) {
        return newAstFarg_Wildcard(I);
    }
    if (tag == list->tag) {
        return rewriteAstFarg(list->arg, env);
    }
    return getAstFargFromTaggedArgList(tag, list->next, env, I);
}

/**
 * @brief Rewrites an AST tagged argument list into a plain AstFargList.
 * 
 * The canonical positions of the tags dictate the order of the arguments.
 * The actual unpacking is done by `getAstFargFromTaggedArgList`.
 * 
 * @param allTags The list of all tags of the constructor in canonical order.
 * @param argTags The AST tagged argument list to rewrite.
 * @param env The lambda context to use for rewriting.
 * @return The rewritten AST tagged argument list, wrapped in an AstFargList.
 */
static AstFargList *rewriteAstTaggedArgList(LamTypeTags *allTags, AstTaggedArgList *argTags, LamContext *env) {
    if (allTags == NULL) return NULL;
    AstFargList *next = rewriteAstTaggedArgList(allTags->next, argTags, env);
    int save = PROTECT(next);
    AstFarg *arg = getAstFargFromTaggedArgList(allTags->tag, argTags, env, CPI(argTags));
    PROTECT(arg);
    AstFargList *this = newAstFargList(CPI(argTags), arg, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Rewrites an AST unpack struct argument into a plain AstUnpack.
 * 
 * The canonical positions of the tags dictate the order of the arguments.
 * The actual unpacking is done by `rewriteAstTaggedArgList`.
 * 
 * @param structure The AST unpack struct argument to rewrite.
 * @param env The lambda context to use for rewriting.
 * @return The rewritten AST unpack struct argument, wrapped in an AstFarg.
 */
static AstFarg *rewriteAstUnpackStruct(AstUnpackStruct *structure, LamContext *env) {
    LamTypeConstructorInfo *info = findConstructor(structure->symbol, env);
    if (info->tags == NULL) {
        conversionError(CPI(structure), "constructor not a struct");
        return newAstFarg_Wildcard(CPI(structure));
    }
    AstFargList *args = rewriteAstTaggedArgList(info->tags, structure->argList, env);
    int save = PROTECT(args);
    AstUnpack *unpack = newAstUnpack(CPI(structure), structure->symbol, args);
    PROTECT(unpack);
    AstFarg *res = newAstFarg_Unpack(CPI(unpack), unpack);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Rewrites the components of an AST tuple argument.
 * @param tuple The AST tuple argument to rewrite.
 * @param env The lambda context to use for rewriting.
 * @return The rewritten AST tuple argument.
 */
static AstFarg *rewriteAstTuple(AstFargList *tuple, LamContext *env) {
    AstFargList *new = rewriteAstFargList(tuple, env);
    int save = PROTECT(new);
    AstFarg *res = newAstFarg_Tuple(CPI(tuple), new);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Rewrites an AST formal argument into a form more suitable for tpmc conversion.
 * 
 * Named arguments are recursed into.
 * Unpack arguments are recursed into.
 * Tuple arguments are recursed into.
 * UnpackStruct arguments are replaced with unpack arguments,
 * hence the recursion.
 * 
 * @param arg The AST formal argument to rewrite.
 * @param env The lambda context to use for rewriting.
 * @return The rewritten AST formal argument.
 */
static AstFarg *rewriteAstFarg(AstFarg *arg, LamContext *env) {
    switch (arg->type) {
        case AST_FARG_TYPE_WILDCARD:
        case AST_FARG_TYPE_SYMBOL:
        case AST_FARG_TYPE_NUMBER:
        case AST_FARG_TYPE_CHARACTER:
        case AST_FARG_TYPE_LOOKUP:
            return arg;
        case AST_FARG_TYPE_NAMED:
            return rewriteAstNamed(arg->val.named, env);
        case AST_FARG_TYPE_UNPACK:
            return rewriteAstUnpack(arg->val.unpack, env);
        case AST_FARG_TYPE_UNPACKSTRUCT:
            return rewriteAstUnpackStruct(arg->val.unpackStruct, env);
        case AST_FARG_TYPE_TUPLE:
            return rewriteAstTuple(arg->val.tuple, env);
        default:
            cant_happen("unrecognized %s", astFargTypeName(arg->type));
    }
}

/**
 * @brief Rewrites an AST formal argument list into a form more suitable for tpmc conversion.
 * @param args The AST formal argument list to rewrite.
 * @param env The lambda context to use for rewriting.
 * @return The rewritten AST formal argument list.
 */
static AstFargList *rewriteAstFargList(AstFargList *args, LamContext *env) {
    if (args == NULL) return NULL;
    AstFargList *next = rewriteAstFargList(args->next, env);
    int save = PROTECT(next);
    AstFarg *arg = rewriteAstFarg(args->arg, env);
    PROTECT(arg);
    AstFargList *this = newAstFargList(CPI(args), arg, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Converts the bodies of a composite function into a single lambda expression.
 * 
 * This function calls into the TPMC code to convert the formal arguments and
 * separate function bodies to a single pattern matcher dispatching to the
 * appropriate body.
 * 
 * @param nargs The number of arguments for the function.
 * @param fun The composite function to convert.
 * @param env The lambda context to use for conversion.
 * @return The converted composite function.
 */
static LamLam *convertCompositeBodies(int nargs, AstCompositeFunction *fun,
                                      LamContext *env) {
    ENTER(convertCompositeBodies);
    int nBodies = countAstCompositeFunction(fun);
    if (nBodies == 0) {
        can_happen("empty composite function");
        LEAVE(convertCompositeBodies);
        return NULL;
    }
    LamExp **actions = NEW_ARRAY(LamExp *, nBodies);
    AstFargList **argLists = NEW_ARRAY(AstFargList *, nBodies);
    int p = PROTECT(NULL);
    AstCompositeFunction *f = fun;
    for (int i = 0; i < nBodies; i++, f = f->next) {
        AstFunction *func = f->function;
        actions[i] = convertNest(func->nest, env);
        PROTECT(actions[i]);
        argLists[i] = rewriteAstFargList(func->argList, env);
        PROTECT(argLists[i]);
    }
    LamLam *result = tpmcConvert(fun->unsafe, CPI(fun), nargs, nBodies, argLists, actions, env);
    PROTECT(result);
    FREE_ARRAY(LamExp *, actions, nBodies);
    FREE_ARRAY(AstFargList *, argLists, nBodies);
    UNPROTECT(p);
    LEAVE(convertCompositeBodies);
    return result;
}

/**
 * @brief Converts a composite function into a lambda expression.
 * @param PI The parser information.
 * @param fun The composite function to convert.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda expression for the composite function.
 */
static LamExp *convertCompositeFun(ParserInfo PI, AstCompositeFunction *fun, LamContext *env) {
    ENTER(convertCompositeFun);
    if (fun == NULL) {
        conversionError(PI, "composite function with no components");
        return lamExpError(PI);
    }
    int nargs = countAstFargList(fun->function->argList);
    LamLam *lambda = convertCompositeBodies(nargs, fun, env);
    DEBUG("convertCompositeBodies returned %p", lambda);
    int save = PROTECT(lambda);
    LamExp *result = newLamExp_Lam(CPI(lambda), lambda);
    UNPROTECT(save);
    LEAVE(convertCompositeFun);
    return result;
}

/**
 * @brief Converts a symbol into a lambda expression.
 * @param I The parser information.
 * @param symbol The symbol to convert.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda expression for the symbol.
 */
static LamExp *convertSymbol(ParserInfo I, HashSymbol *symbol, LamContext *env) {
    ENTER(convertSymbol);
    LamExp *result = makeConstructor(symbol, env);
    DEBUG("convertSymbol %s %d - %s: %s", I.filename, I.lineno, symbol->name, result ? "constructor" : "variable");
    if (result == NULL) {
        result = newLamExp_Var(I, symbol);
    }
    LEAVE(convertSymbol);
    return result;
}

/**
 * @brief Converts an annotated symbol (hygienic operator wrapper) into a lambda expression.
 * 
 * This handles the case where a hygienic operator wrapper ($opN) wraps a type constructor.
 * If the original implementation is a type constructor, we return a reference to that constructor
 * directly, allowing it to be used in patterns. Otherwise, we return a reference to the hygienic
 * wrapper function.
 * 
 * @param annotated The annotated symbol containing both wrapper and original implementation.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda expression (either constructor or variable reference).
 */
static LamExp *convertAnnotatedSymbol(AstAnnotatedSymbol *annotated, LamContext *env) {
    ENTER(convertAnnotatedSymbol);
    LamExp *result = NULL;
    
    // Check if the original implementation is a bare symbol that's a type constructor
    if (annotated->originalImpl->type == AST_EXPRESSION_TYPE_SYMBOL) {
        HashSymbol *originalSym = annotated->originalImpl->val.symbol;
        LamExp *constructor = makeConstructor(originalSym, env);
        if (constructor != NULL) {
            // Original is a type constructor - return it directly for pattern matching
            DEBUG("convertAnnotatedSymbol: %s wraps constructor %s, using constructor directly",
                  annotated->symbol->name, originalSym->name);
            result = constructor;
            LEAVE(convertAnnotatedSymbol);
            return result;
        }
    }
    
    // Not a constructor - use the hygienic wrapper symbol
    DEBUG("convertAnnotatedSymbol: %s is not a constructor wrapper, using hygienic function",
          annotated->symbol->name);
    HashSymbol *symbol = annotated->symbol;
    result = newLamExp_Var(CPI(annotated), symbol);
    LEAVE(convertAnnotatedSymbol);
    return result;
}

/**
 * @brief Converts an assertion expression into a lambda expression.
 * @param value The assertion expression to convert.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda expression for the assertion.
 */
static LamExp *convertAssertion(AstExpression *value, LamContext *env) {
    LamExp *exp = convertExpression(value, env);
    int save = PROTECT(exp);
    LamArgs *args = newLamArgs(CPI(exp), exp, NULL);
    PROTECT(args);
    LamExp *fileName = stringToLamArgs(CPI(exp), exp->_yy_parser_info.filename);
    PROTECT(fileName);
    args = newLamArgs(CPI(exp), fileName, args);
    PROTECT(args);
    MaybeBigInt *num = fakeBigInt(exp->_yy_parser_info.lineno, false);
    PROTECT(num);
    LamExp *lineNo = newLamExp_Biginteger(CPI(exp), num);
    PROTECT(lineNo);
    args = newLamArgs(CPI(lineNo), lineNo, args);
    PROTECT(args);
    LamExp *function = newLamExp_Var(CPI(value), assertSymbol());
    PROTECT(function);
    LamExp *res = makeApplication(function, args);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Converts an error expression into a lambda expression.
 * 
 * The error in question is a runtime error caused by a non-exhaustive
 * pattern match failure in an unsafe function.
 * 
 * @param value The error expression to convert.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda expression for the error.
 */
static LamExp *convertError(AstExpression *value, LamContext *env) {
    LamExp *exp = convertExpression(value, env);
    int save = PROTECT(exp);
    LamArgs *args = newLamArgs(CPI(exp), exp, NULL);
    PROTECT(args);
    LamExp *fileName = stringToLamArgs(CPI(value), value->_yy_parser_info.filename);
    PROTECT(fileName);
    args = newLamArgs(CPI(exp), fileName, args);
    PROTECT(args);
    MaybeBigInt *num = fakeBigInt(value->_yy_parser_info.lineno, false);
    PROTECT(num);
    LamExp *lineNo = newLamExp_Biginteger(CPI(exp), num);
    PROTECT(lineNo);
    args = newLamArgs(CPI(lineNo), lineNo, args);
    PROTECT(args);
    LamExp *function = newLamExp_Var(CPI(value), fnErrorSymbol());
    PROTECT(function);
    LamExp *res = makeApplication(function, args);
    UNPROTECT(save);
    return res;
}

/**
 * @brief Converts a generic AST expression into a lambda expression.
 * @param expression The expression to convert.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda expression for the input expression.
 */
static LamExp *convertExpression(AstExpression *expression, LamContext *env) {
    ENTER(convertExpression);
    LamExp *result = NULL;
    switch (expression->type) {
        case AST_EXPRESSION_TYPE_BACK:
            DEBUG("back");
            result = newLamExp_Back(CPI(expression));
            break;
        case AST_EXPRESSION_TYPE_FUNCALL:
            DEBUG("funcall");
            result = convertFunCall(expression->val.funCall, env);
            break;
        case AST_EXPRESSION_TYPE_ANNOTATEDSYMBOL:
            DEBUG("annotatedSymbol");
            result = convertAnnotatedSymbol(expression->val.annotatedSymbol, env);
            break;
        case AST_EXPRESSION_TYPE_SYMBOL:
            DEBUG("symbol");
            result = convertSymbol(CPI(expression), expression->val.symbol, env);
            break;
        case AST_EXPRESSION_TYPE_NUMBER:
            DEBUG("number");
            result = newLamExp_Biginteger(CPI(expression), expression->val.number);
            break;
        case AST_EXPRESSION_TYPE_CHARACTER:
            DEBUG("character");
            result = newLamExp_Character(CPI(expression), expression->val.character);
            break;
        case AST_EXPRESSION_TYPE_ENV:
            DEBUG("env");
            result = newLamExp_Env(CPI(expression));
            break;
        case AST_EXPRESSION_TYPE_FUN:
            DEBUG("fun");
            result = convertCompositeFun(CPI(expression), expression->val.fun, env);
            break;
        case AST_EXPRESSION_TYPE_NEST:
            DEBUG("nest");
            result = convertNest(expression->val.nest, env);
            break;
        case AST_EXPRESSION_TYPE_IFF:
            DEBUG("iff");
            result = lamConvertIff(expression->val.iff, env);
            break;
        case AST_EXPRESSION_TYPE_PRINT:
            DEBUG("print");
            result = lamConvertPrint(expression->val.print, env);
            break;
        case AST_EXPRESSION_TYPE_TYPEOF:
            DEBUG("typeof");
            result = lamConvertTypeof(expression->val.typeOf, env);
            break;
        case AST_EXPRESSION_TYPE_TUPLE:
            DEBUG("tuple");
            result = lamConvertTuple(CPI(expression), expression->val.tuple, env);
            break;
        case AST_EXPRESSION_TYPE_LOOKUP:
            DEBUG("lookup");
            result = lamConvertLookup(expression->val.lookup, env);
            break;
        case AST_EXPRESSION_TYPE_STRUCTURE:
            DEBUG("structure");
            result = convertStructure(expression->val.structure, env);
            break;
        case AST_EXPRESSION_TYPE_ASSERTION:
            result = convertAssertion(expression->val.assertion, env);
            break;
        case AST_EXPRESSION_TYPE_ERROR:
            result = convertError(expression->val.error, env);
            break;
        default:
            cant_happen
                ("unrecognised expression type %s",
                 astExpressionTypeName(expression->type));
    }
    LEAVE(convertExpression);
    return result;
}

/**
 * @brief Converts a list of AST expressions into a lambda argument list.
 * @param expressions The expressions to convert.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda argument list for the input expressions.
 */
static LamArgs *convertExpressions(AstExpressions *expressions,
                                   LamContext *env) {
    if (expressions == NULL)
        return NULL;
    LamArgs *next = convertExpressions(expressions->next, env);
    int save = PROTECT(next);
    LamExp *exp = convertExpression(expressions->expression, env);
    (void) PROTECT(exp);
    LamArgs *this = newLamArgs(CPI(exp), exp, next);
    UNPROTECT(save);
    return this;
}

/**
 * @brief Converts a sequence of AST expressions into a lambda sequence.
 * @param expressions The expressions to convert.
 * @param env The lambda context to use for conversion.
 * @return The resulting lambda sequence for the input expressions.
 */
static LamSequence *convertSequence(AstExpressions *expressions,
                                    LamContext *env) {
    if (expressions == NULL)
        return NULL;
    LamSequence *next = convertSequence(expressions->next, env);
    int save = PROTECT(next);
    LamExp *exp = convertExpression(expressions->expression, env);
    (void) PROTECT(exp);
    LamSequence *this = newLamSequence(CPI(exp), exp, next);
    UNPROTECT(save);
    return this;
}
