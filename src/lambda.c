/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 *
 * generated from src/lambda.yaml by makeAST.py
 */

#include "lambda.h"
#include <stdio.h>
#include <strings.h>
#include "common.h"
#ifdef DEBUG_ALLOC
#include "debugging_on.h"
#else
#include "debugging_off.h"
#endif

struct LamLam * newLamLam(int nargs, struct LamVarList * args, struct LamExp * exp) {
    struct LamLam * x = NEW(LamLam, OBJTYPE_LAMLAM);
    DEBUG("new LamLam %pn", x);
    x->nargs = nargs;
    x->args = args;
    x->exp = exp;
    return x;
}

struct LamVarList * newLamVarList(HashSymbol * var, struct LamVarList * next) {
    struct LamVarList * x = NEW(LamVarList, OBJTYPE_LAMVARLIST);
    DEBUG("new LamVarList %pn", x);
    x->var = var;
    x->next = next;
    return x;
}

struct LamPrimApp * newLamPrimApp(enum LamPrimOp  type, struct LamExp * exp1, struct LamExp * exp2) {
    struct LamPrimApp * x = NEW(LamPrimApp, OBJTYPE_LAMPRIMAPP);
    DEBUG("new LamPrimApp %pn", x);
    x->type = type;
    x->exp1 = exp1;
    x->exp2 = exp2;
    return x;
}

struct LamUnaryApp * newLamUnaryApp(enum LamUnaryOp  type, struct LamExp * exp) {
    struct LamUnaryApp * x = NEW(LamUnaryApp, OBJTYPE_LAMUNARYAPP);
    DEBUG("new LamUnaryApp %pn", x);
    x->type = type;
    x->exp = exp;
    return x;
}

struct LamSequence * newLamSequence(struct LamExp * exp, struct LamSequence * next) {
    struct LamSequence * x = NEW(LamSequence, OBJTYPE_LAMSEQUENCE);
    DEBUG("new LamSequence %pn", x);
    x->exp = exp;
    x->next = next;
    return x;
}

struct LamList * newLamList(struct LamExp * exp, struct LamList * next) {
    struct LamList * x = NEW(LamList, OBJTYPE_LAMLIST);
    DEBUG("new LamList %pn", x);
    x->exp = exp;
    x->next = next;
    return x;
}

struct LamApply * newLamApply(struct LamExp * function, int nargs, struct LamList * args) {
    struct LamApply * x = NEW(LamApply, OBJTYPE_LAMAPPLY);
    DEBUG("new LamApply %pn", x);
    x->function = function;
    x->nargs = nargs;
    x->args = args;
    return x;
}

struct LamConstant * newLamConstant(HashSymbol * name, int tag) {
    struct LamConstant * x = NEW(LamConstant, OBJTYPE_LAMCONSTANT);
    DEBUG("new LamConstant %pn", x);
    x->name = name;
    x->tag = tag;
    return x;
}

struct LamConstruct * newLamConstruct(HashSymbol * name, int tag, struct LamList * args) {
    struct LamConstruct * x = NEW(LamConstruct, OBJTYPE_LAMCONSTRUCT);
    DEBUG("new LamConstruct %pn", x);
    x->name = name;
    x->tag = tag;
    x->args = args;
    return x;
}

struct LamDeconstruct * newLamDeconstruct(HashSymbol * name, int vec, struct LamExp * exp) {
    struct LamDeconstruct * x = NEW(LamDeconstruct, OBJTYPE_LAMDECONSTRUCT);
    DEBUG("new LamDeconstruct %pn", x);
    x->name = name;
    x->vec = vec;
    x->exp = exp;
    return x;
}

struct LamMakeVec * newLamMakeVec(int nargs, struct LamList * args) {
    struct LamMakeVec * x = NEW(LamMakeVec, OBJTYPE_LAMMAKEVEC);
    DEBUG("new LamMakeVec %pn", x);
    x->nargs = nargs;
    x->args = args;
    return x;
}

struct LamIff * newLamIff(struct LamExp * condition, struct LamExp * consequent, struct LamExp * alternative) {
    struct LamIff * x = NEW(LamIff, OBJTYPE_LAMIFF);
    DEBUG("new LamIff %pn", x);
    x->condition = condition;
    x->consequent = consequent;
    x->alternative = alternative;
    return x;
}

struct LamCond * newLamCond(struct LamExp * value, struct LamCondCases * cases) {
    struct LamCond * x = NEW(LamCond, OBJTYPE_LAMCOND);
    DEBUG("new LamCond %pn", x);
    x->value = value;
    x->cases = cases;
    return x;
}

struct LamIntCondCases * newLamIntCondCases(BigInt * constant, struct LamExp * body, struct LamIntCondCases * next) {
    struct LamIntCondCases * x = NEW(LamIntCondCases, OBJTYPE_LAMINTCONDCASES);
    DEBUG("new LamIntCondCases %pn", x);
    x->constant = constant;
    x->body = body;
    x->next = next;
    return x;
}

struct LamCharCondCases * newLamCharCondCases(char constant, struct LamExp * body, struct LamCharCondCases * next) {
    struct LamCharCondCases * x = NEW(LamCharCondCases, OBJTYPE_LAMCHARCONDCASES);
    DEBUG("new LamCharCondCases %pn", x);
    x->constant = constant;
    x->body = body;
    x->next = next;
    return x;
}

struct LamMatch * newLamMatch(struct LamExp * index, struct LamMatchList * cases) {
    struct LamMatch * x = NEW(LamMatch, OBJTYPE_LAMMATCH);
    DEBUG("new LamMatch %pn", x);
    x->index = index;
    x->cases = cases;
    return x;
}

struct LamMatchList * newLamMatchList(struct LamIntList * matches, struct LamExp * body, struct LamMatchList * next) {
    struct LamMatchList * x = NEW(LamMatchList, OBJTYPE_LAMMATCHLIST);
    DEBUG("new LamMatchList %pn", x);
    x->matches = matches;
    x->body = body;
    x->next = next;
    return x;
}

struct LamIntList * newLamIntList(int item, HashSymbol * name, struct LamIntList * next) {
    struct LamIntList * x = NEW(LamIntList, OBJTYPE_LAMINTLIST);
    DEBUG("new LamIntList %pn", x);
    x->item = item;
    x->name = name;
    x->next = next;
    return x;
}

struct LamLet * newLamLet(HashSymbol * var, struct LamExp * value, struct LamExp * body) {
    struct LamLet * x = NEW(LamLet, OBJTYPE_LAMLET);
    DEBUG("new LamLet %pn", x);
    x->var = var;
    x->value = value;
    x->body = body;
    return x;
}

struct LamLetRec * newLamLetRec(int nbindings, struct LamLetRecBindings * bindings, struct LamExp * body) {
    struct LamLetRec * x = NEW(LamLetRec, OBJTYPE_LAMLETREC);
    DEBUG("new LamLetRec %pn", x);
    x->nbindings = nbindings;
    x->bindings = bindings;
    x->body = body;
    return x;
}

struct LamLetRecBindings * newLamLetRecBindings(HashSymbol * var, struct LamExp * val, struct LamLetRecBindings * next) {
    struct LamLetRecBindings * x = NEW(LamLetRecBindings, OBJTYPE_LAMLETRECBINDINGS);
    DEBUG("new LamLetRecBindings %pn", x);
    x->var = var;
    x->val = val;
    x->next = next;
    return x;
}

struct LamContext * newLamContext(HashTable * frame, struct LamContext * parent) {
    struct LamContext * x = NEW(LamContext, OBJTYPE_LAMCONTEXT);
    DEBUG("new LamContext %pn", x);
    x->frame = frame;
    x->parent = parent;
    return x;
}

struct LamAnd * newLamAnd(struct LamExp * left, struct LamExp * right) {
    struct LamAnd * x = NEW(LamAnd, OBJTYPE_LAMAND);
    DEBUG("new LamAnd %pn", x);
    x->left = left;
    x->right = right;
    return x;
}

struct LamOr * newLamOr(struct LamExp * left, struct LamExp * right) {
    struct LamOr * x = NEW(LamOr, OBJTYPE_LAMOR);
    DEBUG("new LamOr %pn", x);
    x->left = left;
    x->right = right;
    return x;
}

struct LamAmb * newLamAmb(struct LamExp * left, struct LamExp * right) {
    struct LamAmb * x = NEW(LamAmb, OBJTYPE_LAMAMB);
    DEBUG("new LamAmb %pn", x);
    x->left = left;
    x->right = right;
    return x;
}

struct LamTypeDefs * newLamTypeDefs(struct LamTypeDefList * typeDefs, struct LamExp * body) {
    struct LamTypeDefs * x = NEW(LamTypeDefs, OBJTYPE_LAMTYPEDEFS);
    DEBUG("new LamTypeDefs %pn", x);
    x->typeDefs = typeDefs;
    x->body = body;
    return x;
}

struct LamTypeDefList * newLamTypeDefList(struct LamTypeDef * typeDef, struct LamTypeDefList * next) {
    struct LamTypeDefList * x = NEW(LamTypeDefList, OBJTYPE_LAMTYPEDEFLIST);
    DEBUG("new LamTypeDefList %pn", x);
    x->typeDef = typeDef;
    x->next = next;
    return x;
}

struct LamTypeDef * newLamTypeDef(struct LamType * type, struct LamTypeConstructorList * constructors) {
    struct LamTypeDef * x = NEW(LamTypeDef, OBJTYPE_LAMTYPEDEF);
    DEBUG("new LamTypeDef %pn", x);
    x->type = type;
    x->constructors = constructors;
    return x;
}

struct LamTypeConstructorList * newLamTypeConstructorList(struct LamTypeConstructor * constructor, struct LamTypeConstructorList * next) {
    struct LamTypeConstructorList * x = NEW(LamTypeConstructorList, OBJTYPE_LAMTYPECONSTRUCTORLIST);
    DEBUG("new LamTypeConstructorList %pn", x);
    x->constructor = constructor;
    x->next = next;
    return x;
}

struct LamType * newLamType(HashSymbol * name, struct LamTypeArgs * args) {
    struct LamType * x = NEW(LamType, OBJTYPE_LAMTYPE);
    DEBUG("new LamType %pn", x);
    x->name = name;
    x->args = args;
    return x;
}

struct LamTypeArgs * newLamTypeArgs(HashSymbol * name, struct LamTypeArgs * next) {
    struct LamTypeArgs * x = NEW(LamTypeArgs, OBJTYPE_LAMTYPEARGS);
    DEBUG("new LamTypeArgs %pn", x);
    x->name = name;
    x->next = next;
    return x;
}

struct LamTypeConstructor * newLamTypeConstructor(HashSymbol * name, struct LamType * type, struct LamTypeConstructorArgs * args) {
    struct LamTypeConstructor * x = NEW(LamTypeConstructor, OBJTYPE_LAMTYPECONSTRUCTOR);
    DEBUG("new LamTypeConstructor %pn", x);
    x->name = name;
    x->type = type;
    x->args = args;
    return x;
}

struct LamTypeConstructorArgs * newLamTypeConstructorArgs(struct LamTypeConstructorType * arg, struct LamTypeConstructorArgs * next) {
    struct LamTypeConstructorArgs * x = NEW(LamTypeConstructorArgs, OBJTYPE_LAMTYPECONSTRUCTORARGS);
    DEBUG("new LamTypeConstructorArgs %pn", x);
    x->arg = arg;
    x->next = next;
    return x;
}

struct LamTypeFunction * newLamTypeFunction(HashSymbol * name, struct LamTypeConstructorArgs * args) {
    struct LamTypeFunction * x = NEW(LamTypeFunction, OBJTYPE_LAMTYPEFUNCTION);
    DEBUG("new LamTypeFunction %pn", x);
    x->name = name;
    x->args = args;
    return x;
}

struct LamTypeConstructorInfo * newLamTypeConstructorInfo(struct LamTypeConstructor * type, bool vec, int arity, int size, int index) {
    struct LamTypeConstructorInfo * x = NEW(LamTypeConstructorInfo, OBJTYPE_LAMTYPECONSTRUCTORINFO);
    DEBUG("new LamTypeConstructorInfo %pn", x);
    x->type = type;
    x->vec = vec;
    x->arity = arity;
    x->size = size;
    x->index = index;
    return x;
}

struct LamExp * newLamExp(enum LamExpType  type, union LamExpVal  val) {
    struct LamExp * x = NEW(LamExp, OBJTYPE_LAMEXP);
    DEBUG("new LamExp %pn", x);
    x->type = type;
    x->val = val;
    return x;
}

struct LamCondCases * newLamCondCases(enum LamCondCasesType  type, union LamCondCasesVal  val) {
    struct LamCondCases * x = NEW(LamCondCases, OBJTYPE_LAMCONDCASES);
    DEBUG("new LamCondCases %pn", x);
    x->type = type;
    x->val = val;
    return x;
}

struct LamTypeConstructorType * newLamTypeConstructorType(enum LamTypeConstructorTypeType  type, union LamTypeConstructorTypeVal  val) {
    struct LamTypeConstructorType * x = NEW(LamTypeConstructorType, OBJTYPE_LAMTYPECONSTRUCTORTYPE);
    DEBUG("new LamTypeConstructorType %pn", x);
    x->type = type;
    x->val = val;
    return x;
}



/************************************/

void markLamLam(struct LamLam * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamVarList(x->args);
    markLamExp(x->exp);
}

void markLamVarList(struct LamVarList * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->var);
    markLamVarList(x->next);
}

void markLamPrimApp(struct LamPrimApp * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->exp1);
    markLamExp(x->exp2);
}

void markLamUnaryApp(struct LamUnaryApp * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->exp);
}

void markLamSequence(struct LamSequence * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->exp);
    markLamSequence(x->next);
}

void markLamList(struct LamList * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->exp);
    markLamList(x->next);
}

void markLamApply(struct LamApply * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->function);
    markLamList(x->args);
}

void markLamConstant(struct LamConstant * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
}

void markLamConstruct(struct LamConstruct * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
    markLamList(x->args);
}

void markLamDeconstruct(struct LamDeconstruct * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
    markLamExp(x->exp);
}

void markLamMakeVec(struct LamMakeVec * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamList(x->args);
}

void markLamIff(struct LamIff * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->condition);
    markLamExp(x->consequent);
    markLamExp(x->alternative);
}

void markLamCond(struct LamCond * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->value);
    markLamCondCases(x->cases);
}

void markLamIntCondCases(struct LamIntCondCases * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markBigInt(x->constant);
    markLamExp(x->body);
    markLamIntCondCases(x->next);
}

void markLamCharCondCases(struct LamCharCondCases * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->body);
    markLamCharCondCases(x->next);
}

void markLamMatch(struct LamMatch * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->index);
    markLamMatchList(x->cases);
}

void markLamMatchList(struct LamMatchList * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamIntList(x->matches);
    markLamExp(x->body);
    markLamMatchList(x->next);
}

void markLamIntList(struct LamIntList * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
    markLamIntList(x->next);
}

void markLamLet(struct LamLet * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->var);
    markLamExp(x->value);
    markLamExp(x->body);
}

void markLamLetRec(struct LamLetRec * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamLetRecBindings(x->bindings);
    markLamExp(x->body);
}

void markLamLetRecBindings(struct LamLetRecBindings * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->var);
    markLamExp(x->val);
    markLamLetRecBindings(x->next);
}

void markLamContext(struct LamContext * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashTable(x->frame);
    markLamContext(x->parent);
}

void markLamAnd(struct LamAnd * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->left);
    markLamExp(x->right);
}

void markLamOr(struct LamOr * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->left);
    markLamExp(x->right);
}

void markLamAmb(struct LamAmb * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamExp(x->left);
    markLamExp(x->right);
}

void markLamTypeDefs(struct LamTypeDefs * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamTypeDefList(x->typeDefs);
    markLamExp(x->body);
}

void markLamTypeDefList(struct LamTypeDefList * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamTypeDef(x->typeDef);
    markLamTypeDefList(x->next);
}

void markLamTypeDef(struct LamTypeDef * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamType(x->type);
    markLamTypeConstructorList(x->constructors);
}

void markLamTypeConstructorList(struct LamTypeConstructorList * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamTypeConstructor(x->constructor);
    markLamTypeConstructorList(x->next);
}

void markLamType(struct LamType * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
    markLamTypeArgs(x->args);
}

void markLamTypeArgs(struct LamTypeArgs * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
    markLamTypeArgs(x->next);
}

void markLamTypeConstructor(struct LamTypeConstructor * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
    markLamType(x->type);
    markLamTypeConstructorArgs(x->args);
}

void markLamTypeConstructorArgs(struct LamTypeConstructorArgs * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamTypeConstructorType(x->arg);
    markLamTypeConstructorArgs(x->next);
}

void markLamTypeFunction(struct LamTypeFunction * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markHashSymbol(x->name);
    markLamTypeConstructorArgs(x->args);
}

void markLamTypeConstructorInfo(struct LamTypeConstructorInfo * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    markLamTypeConstructor(x->type);
}

void markLamExp(struct LamExp * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    switch(x->type) {
        case LAMEXP_TYPE_LAM:
            markLamLam(x->val.lam);
            break;
        case LAMEXP_TYPE_VAR:
            markHashSymbol(x->val.var);
            break;
        case LAMEXP_TYPE_STDINT:
            break;
        case LAMEXP_TYPE_BIGINTEGER:
            markBigInt(x->val.biginteger);
            break;
        case LAMEXP_TYPE_PRIM:
            markLamPrimApp(x->val.prim);
            break;
        case LAMEXP_TYPE_UNARY:
            markLamUnaryApp(x->val.unary);
            break;
        case LAMEXP_TYPE_LIST:
            markLamSequence(x->val.list);
            break;
        case LAMEXP_TYPE_MAKEVEC:
            markLamMakeVec(x->val.makeVec);
            break;
        case LAMEXP_TYPE_CONSTRUCT:
            markLamConstruct(x->val.construct);
            break;
        case LAMEXP_TYPE_DECONSTRUCT:
            markLamDeconstruct(x->val.deconstruct);
            break;
        case LAMEXP_TYPE_CONSTANT:
            markLamConstant(x->val.constant);
            break;
        case LAMEXP_TYPE_APPLY:
            markLamApply(x->val.apply);
            break;
        case LAMEXP_TYPE_IFF:
            markLamIff(x->val.iff);
            break;
        case LAMEXP_TYPE_CALLCC:
            markLamExp(x->val.callcc);
            break;
        case LAMEXP_TYPE_LETREC:
            markLamLetRec(x->val.letrec);
            break;
        case LAMEXP_TYPE_TYPEDEFS:
            markLamTypeDefs(x->val.typedefs);
            break;
        case LAMEXP_TYPE_LET:
            markLamLet(x->val.let);
            break;
        case LAMEXP_TYPE_MATCH:
            markLamMatch(x->val.match);
            break;
        case LAMEXP_TYPE_COND:
            markLamCond(x->val.cond);
            break;
        case LAMEXP_TYPE_AND:
            markLamAnd(x->val.and);
            break;
        case LAMEXP_TYPE_OR:
            markLamOr(x->val.or);
            break;
        case LAMEXP_TYPE_AMB:
            markLamAmb(x->val.amb);
            break;
        case LAMEXP_TYPE_CHARACTER:
            break;
        case LAMEXP_TYPE_BACK:
            break;
        case LAMEXP_TYPE_ERROR:
            break;
        case LAMEXP_TYPE_COND_DEFAULT:
            break;
        default:
            cant_happen("unrecognised type %d in markLamExp", x->type);
    }
}

void markLamCondCases(struct LamCondCases * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    switch(x->type) {
        case LAMCONDCASES_TYPE_INTEGERS:
            markLamIntCondCases(x->val.integers);
            break;
        case LAMCONDCASES_TYPE_CHARACTERS:
            markLamCharCondCases(x->val.characters);
            break;
        default:
            cant_happen("unrecognised type %d in markLamCondCases", x->type);
    }
}

void markLamTypeConstructorType(struct LamTypeConstructorType * x) {
    if (x == NULL) return;
    if (MARKED(x)) return;
    MARK(x);
    switch(x->type) {
        case LAMTYPECONSTRUCTORTYPE_TYPE_INTEGER:
            break;
        case LAMTYPECONSTRUCTORTYPE_TYPE_CHARACTER:
            break;
        case LAMTYPECONSTRUCTORTYPE_TYPE_VAR:
            markHashSymbol(x->val.var);
            break;
        case LAMTYPECONSTRUCTORTYPE_TYPE_FUNCTION:
            markLamTypeFunction(x->val.function);
            break;
        default:
            cant_happen("unrecognised type %d in markLamTypeConstructorType", x->type);
    }
}


void markLambdaObj(struct Header *h) {
    switch(h->type) {
        case OBJTYPE_LAMLAM:
            markLamLam((LamLam *)h);
            break;
        case OBJTYPE_LAMVARLIST:
            markLamVarList((LamVarList *)h);
            break;
        case OBJTYPE_LAMPRIMAPP:
            markLamPrimApp((LamPrimApp *)h);
            break;
        case OBJTYPE_LAMUNARYAPP:
            markLamUnaryApp((LamUnaryApp *)h);
            break;
        case OBJTYPE_LAMSEQUENCE:
            markLamSequence((LamSequence *)h);
            break;
        case OBJTYPE_LAMLIST:
            markLamList((LamList *)h);
            break;
        case OBJTYPE_LAMAPPLY:
            markLamApply((LamApply *)h);
            break;
        case OBJTYPE_LAMCONSTANT:
            markLamConstant((LamConstant *)h);
            break;
        case OBJTYPE_LAMCONSTRUCT:
            markLamConstruct((LamConstruct *)h);
            break;
        case OBJTYPE_LAMDECONSTRUCT:
            markLamDeconstruct((LamDeconstruct *)h);
            break;
        case OBJTYPE_LAMMAKEVEC:
            markLamMakeVec((LamMakeVec *)h);
            break;
        case OBJTYPE_LAMIFF:
            markLamIff((LamIff *)h);
            break;
        case OBJTYPE_LAMCOND:
            markLamCond((LamCond *)h);
            break;
        case OBJTYPE_LAMINTCONDCASES:
            markLamIntCondCases((LamIntCondCases *)h);
            break;
        case OBJTYPE_LAMCHARCONDCASES:
            markLamCharCondCases((LamCharCondCases *)h);
            break;
        case OBJTYPE_LAMMATCH:
            markLamMatch((LamMatch *)h);
            break;
        case OBJTYPE_LAMMATCHLIST:
            markLamMatchList((LamMatchList *)h);
            break;
        case OBJTYPE_LAMINTLIST:
            markLamIntList((LamIntList *)h);
            break;
        case OBJTYPE_LAMLET:
            markLamLet((LamLet *)h);
            break;
        case OBJTYPE_LAMLETREC:
            markLamLetRec((LamLetRec *)h);
            break;
        case OBJTYPE_LAMLETRECBINDINGS:
            markLamLetRecBindings((LamLetRecBindings *)h);
            break;
        case OBJTYPE_LAMCONTEXT:
            markLamContext((LamContext *)h);
            break;
        case OBJTYPE_LAMAND:
            markLamAnd((LamAnd *)h);
            break;
        case OBJTYPE_LAMOR:
            markLamOr((LamOr *)h);
            break;
        case OBJTYPE_LAMAMB:
            markLamAmb((LamAmb *)h);
            break;
        case OBJTYPE_LAMTYPEDEFS:
            markLamTypeDefs((LamTypeDefs *)h);
            break;
        case OBJTYPE_LAMTYPEDEFLIST:
            markLamTypeDefList((LamTypeDefList *)h);
            break;
        case OBJTYPE_LAMTYPEDEF:
            markLamTypeDef((LamTypeDef *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORLIST:
            markLamTypeConstructorList((LamTypeConstructorList *)h);
            break;
        case OBJTYPE_LAMTYPE:
            markLamType((LamType *)h);
            break;
        case OBJTYPE_LAMTYPEARGS:
            markLamTypeArgs((LamTypeArgs *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTOR:
            markLamTypeConstructor((LamTypeConstructor *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORARGS:
            markLamTypeConstructorArgs((LamTypeConstructorArgs *)h);
            break;
        case OBJTYPE_LAMTYPEFUNCTION:
            markLamTypeFunction((LamTypeFunction *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORINFO:
            markLamTypeConstructorInfo((LamTypeConstructorInfo *)h);
            break;
        case OBJTYPE_LAMEXP:
            markLamExp((LamExp *)h);
            break;
        case OBJTYPE_LAMCONDCASES:
            markLamCondCases((LamCondCases *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORTYPE:
            markLamTypeConstructorType((LamTypeConstructorType *)h);
            break;
        default:
            cant_happen("unrecognised type %d in markLambdaObj\n", h->type);
    }
}

/************************************/

void freeLamLam(struct LamLam * x) {
    FREE(x, LamLam);
}

void freeLamVarList(struct LamVarList * x) {
    FREE(x, LamVarList);
}

void freeLamPrimApp(struct LamPrimApp * x) {
    FREE(x, LamPrimApp);
}

void freeLamUnaryApp(struct LamUnaryApp * x) {
    FREE(x, LamUnaryApp);
}

void freeLamSequence(struct LamSequence * x) {
    FREE(x, LamSequence);
}

void freeLamList(struct LamList * x) {
    FREE(x, LamList);
}

void freeLamApply(struct LamApply * x) {
    FREE(x, LamApply);
}

void freeLamConstant(struct LamConstant * x) {
    FREE(x, LamConstant);
}

void freeLamConstruct(struct LamConstruct * x) {
    FREE(x, LamConstruct);
}

void freeLamDeconstruct(struct LamDeconstruct * x) {
    FREE(x, LamDeconstruct);
}

void freeLamMakeVec(struct LamMakeVec * x) {
    FREE(x, LamMakeVec);
}

void freeLamIff(struct LamIff * x) {
    FREE(x, LamIff);
}

void freeLamCond(struct LamCond * x) {
    FREE(x, LamCond);
}

void freeLamIntCondCases(struct LamIntCondCases * x) {
    FREE(x, LamIntCondCases);
}

void freeLamCharCondCases(struct LamCharCondCases * x) {
    FREE(x, LamCharCondCases);
}

void freeLamMatch(struct LamMatch * x) {
    FREE(x, LamMatch);
}

void freeLamMatchList(struct LamMatchList * x) {
    FREE(x, LamMatchList);
}

void freeLamIntList(struct LamIntList * x) {
    FREE(x, LamIntList);
}

void freeLamLet(struct LamLet * x) {
    FREE(x, LamLet);
}

void freeLamLetRec(struct LamLetRec * x) {
    FREE(x, LamLetRec);
}

void freeLamLetRecBindings(struct LamLetRecBindings * x) {
    FREE(x, LamLetRecBindings);
}

void freeLamContext(struct LamContext * x) {
    FREE(x, LamContext);
}

void freeLamAnd(struct LamAnd * x) {
    FREE(x, LamAnd);
}

void freeLamOr(struct LamOr * x) {
    FREE(x, LamOr);
}

void freeLamAmb(struct LamAmb * x) {
    FREE(x, LamAmb);
}

void freeLamTypeDefs(struct LamTypeDefs * x) {
    FREE(x, LamTypeDefs);
}

void freeLamTypeDefList(struct LamTypeDefList * x) {
    FREE(x, LamTypeDefList);
}

void freeLamTypeDef(struct LamTypeDef * x) {
    FREE(x, LamTypeDef);
}

void freeLamTypeConstructorList(struct LamTypeConstructorList * x) {
    FREE(x, LamTypeConstructorList);
}

void freeLamType(struct LamType * x) {
    FREE(x, LamType);
}

void freeLamTypeArgs(struct LamTypeArgs * x) {
    FREE(x, LamTypeArgs);
}

void freeLamTypeConstructor(struct LamTypeConstructor * x) {
    FREE(x, LamTypeConstructor);
}

void freeLamTypeConstructorArgs(struct LamTypeConstructorArgs * x) {
    FREE(x, LamTypeConstructorArgs);
}

void freeLamTypeFunction(struct LamTypeFunction * x) {
    FREE(x, LamTypeFunction);
}

void freeLamTypeConstructorInfo(struct LamTypeConstructorInfo * x) {
    FREE(x, LamTypeConstructorInfo);
}

void freeLamExp(struct LamExp * x) {
    FREE(x, LamExp);
}

void freeLamCondCases(struct LamCondCases * x) {
    FREE(x, LamCondCases);
}

void freeLamTypeConstructorType(struct LamTypeConstructorType * x) {
    FREE(x, LamTypeConstructorType);
}


void freeLambdaObj(struct Header *h) {
    switch(h->type) {
        case OBJTYPE_LAMLAM:
            freeLamLam((LamLam *)h);
            break;
        case OBJTYPE_LAMVARLIST:
            freeLamVarList((LamVarList *)h);
            break;
        case OBJTYPE_LAMPRIMAPP:
            freeLamPrimApp((LamPrimApp *)h);
            break;
        case OBJTYPE_LAMUNARYAPP:
            freeLamUnaryApp((LamUnaryApp *)h);
            break;
        case OBJTYPE_LAMSEQUENCE:
            freeLamSequence((LamSequence *)h);
            break;
        case OBJTYPE_LAMLIST:
            freeLamList((LamList *)h);
            break;
        case OBJTYPE_LAMAPPLY:
            freeLamApply((LamApply *)h);
            break;
        case OBJTYPE_LAMCONSTANT:
            freeLamConstant((LamConstant *)h);
            break;
        case OBJTYPE_LAMCONSTRUCT:
            freeLamConstruct((LamConstruct *)h);
            break;
        case OBJTYPE_LAMDECONSTRUCT:
            freeLamDeconstruct((LamDeconstruct *)h);
            break;
        case OBJTYPE_LAMMAKEVEC:
            freeLamMakeVec((LamMakeVec *)h);
            break;
        case OBJTYPE_LAMIFF:
            freeLamIff((LamIff *)h);
            break;
        case OBJTYPE_LAMCOND:
            freeLamCond((LamCond *)h);
            break;
        case OBJTYPE_LAMINTCONDCASES:
            freeLamIntCondCases((LamIntCondCases *)h);
            break;
        case OBJTYPE_LAMCHARCONDCASES:
            freeLamCharCondCases((LamCharCondCases *)h);
            break;
        case OBJTYPE_LAMMATCH:
            freeLamMatch((LamMatch *)h);
            break;
        case OBJTYPE_LAMMATCHLIST:
            freeLamMatchList((LamMatchList *)h);
            break;
        case OBJTYPE_LAMINTLIST:
            freeLamIntList((LamIntList *)h);
            break;
        case OBJTYPE_LAMLET:
            freeLamLet((LamLet *)h);
            break;
        case OBJTYPE_LAMLETREC:
            freeLamLetRec((LamLetRec *)h);
            break;
        case OBJTYPE_LAMLETRECBINDINGS:
            freeLamLetRecBindings((LamLetRecBindings *)h);
            break;
        case OBJTYPE_LAMCONTEXT:
            freeLamContext((LamContext *)h);
            break;
        case OBJTYPE_LAMAND:
            freeLamAnd((LamAnd *)h);
            break;
        case OBJTYPE_LAMOR:
            freeLamOr((LamOr *)h);
            break;
        case OBJTYPE_LAMAMB:
            freeLamAmb((LamAmb *)h);
            break;
        case OBJTYPE_LAMTYPEDEFS:
            freeLamTypeDefs((LamTypeDefs *)h);
            break;
        case OBJTYPE_LAMTYPEDEFLIST:
            freeLamTypeDefList((LamTypeDefList *)h);
            break;
        case OBJTYPE_LAMTYPEDEF:
            freeLamTypeDef((LamTypeDef *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORLIST:
            freeLamTypeConstructorList((LamTypeConstructorList *)h);
            break;
        case OBJTYPE_LAMTYPE:
            freeLamType((LamType *)h);
            break;
        case OBJTYPE_LAMTYPEARGS:
            freeLamTypeArgs((LamTypeArgs *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTOR:
            freeLamTypeConstructor((LamTypeConstructor *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORARGS:
            freeLamTypeConstructorArgs((LamTypeConstructorArgs *)h);
            break;
        case OBJTYPE_LAMTYPEFUNCTION:
            freeLamTypeFunction((LamTypeFunction *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORINFO:
            freeLamTypeConstructorInfo((LamTypeConstructorInfo *)h);
            break;
        case OBJTYPE_LAMEXP:
            freeLamExp((LamExp *)h);
            break;
        case OBJTYPE_LAMCONDCASES:
            freeLamCondCases((LamCondCases *)h);
            break;
        case OBJTYPE_LAMTYPECONSTRUCTORTYPE:
            freeLamTypeConstructorType((LamTypeConstructorType *)h);
            break;
        default:
            cant_happen("unrecognised type %d in freeLambdaObj\n", h->type);
    }
}

char *typenameLambdaObj(int type) {
    switch(type) {
        case OBJTYPE_LAMLAM:
            return "LamLam";
        case OBJTYPE_LAMVARLIST:
            return "LamVarList";
        case OBJTYPE_LAMPRIMAPP:
            return "LamPrimApp";
        case OBJTYPE_LAMUNARYAPP:
            return "LamUnaryApp";
        case OBJTYPE_LAMSEQUENCE:
            return "LamSequence";
        case OBJTYPE_LAMLIST:
            return "LamList";
        case OBJTYPE_LAMAPPLY:
            return "LamApply";
        case OBJTYPE_LAMCONSTANT:
            return "LamConstant";
        case OBJTYPE_LAMCONSTRUCT:
            return "LamConstruct";
        case OBJTYPE_LAMDECONSTRUCT:
            return "LamDeconstruct";
        case OBJTYPE_LAMMAKEVEC:
            return "LamMakeVec";
        case OBJTYPE_LAMIFF:
            return "LamIff";
        case OBJTYPE_LAMCOND:
            return "LamCond";
        case OBJTYPE_LAMINTCONDCASES:
            return "LamIntCondCases";
        case OBJTYPE_LAMCHARCONDCASES:
            return "LamCharCondCases";
        case OBJTYPE_LAMMATCH:
            return "LamMatch";
        case OBJTYPE_LAMMATCHLIST:
            return "LamMatchList";
        case OBJTYPE_LAMINTLIST:
            return "LamIntList";
        case OBJTYPE_LAMLET:
            return "LamLet";
        case OBJTYPE_LAMLETREC:
            return "LamLetRec";
        case OBJTYPE_LAMLETRECBINDINGS:
            return "LamLetRecBindings";
        case OBJTYPE_LAMCONTEXT:
            return "LamContext";
        case OBJTYPE_LAMAND:
            return "LamAnd";
        case OBJTYPE_LAMOR:
            return "LamOr";
        case OBJTYPE_LAMAMB:
            return "LamAmb";
        case OBJTYPE_LAMTYPEDEFS:
            return "LamTypeDefs";
        case OBJTYPE_LAMTYPEDEFLIST:
            return "LamTypeDefList";
        case OBJTYPE_LAMTYPEDEF:
            return "LamTypeDef";
        case OBJTYPE_LAMTYPECONSTRUCTORLIST:
            return "LamTypeConstructorList";
        case OBJTYPE_LAMTYPE:
            return "LamType";
        case OBJTYPE_LAMTYPEARGS:
            return "LamTypeArgs";
        case OBJTYPE_LAMTYPECONSTRUCTOR:
            return "LamTypeConstructor";
        case OBJTYPE_LAMTYPECONSTRUCTORARGS:
            return "LamTypeConstructorArgs";
        case OBJTYPE_LAMTYPEFUNCTION:
            return "LamTypeFunction";
        case OBJTYPE_LAMTYPECONSTRUCTORINFO:
            return "LamTypeConstructorInfo";
        case OBJTYPE_LAMEXP:
            return "LamExp";
        case OBJTYPE_LAMCONDCASES:
            return "LamCondCases";
        case OBJTYPE_LAMTYPECONSTRUCTORTYPE:
            return "LamTypeConstructorType";
        default:
            cant_happen("unrecognised type %d in typenameLambdaObj\n", type);
    }
}

