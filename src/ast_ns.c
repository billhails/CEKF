/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2026  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Abstract Syntax Tree (AST) structures generated by the parser. As this is
 * close to the surface of the language, it is quite complicated. The complexity
 * is reduced downstream by conversion to simple lambda form. Generated from
 * src/ast.yaml by tools/generate.py
 */

#include "ast.h"
#include "ast_pp.h"
#include "memory.h"
#include "symbol.h"
#include "utils.h"
#include "utils_helper.h"

#include "ast_ns.h"

#ifdef DEBUG_AST_NS
#include "debugging_on.h"
#else
#include "debugging_off.h"
#endif

typedef struct VisitorContext {
    AstNameSpaceArray *nameSpaces;
    SymbolMap *replacements;
} VisitorContext;

// Forward declarations
static AstNest *nsAstNest(AstNest *, VisitorContext);
static AstNameSpaceImpl *nsAstNameSpaceImpl(AstNameSpaceImpl *, int,
                                            VisitorContext);
static AstDefinitions *nsAstDefinitions(AstDefinitions *, VisitorContext);
static AstDefine *nsAstDefine(AstDefine *, VisitorContext);
static AstMultiDefine *nsAstMultiDefine(AstMultiDefine *, VisitorContext);
static AstSymbolList *nsAstSymbolList(AstSymbolList *, VisitorContext);
static AstAlias *nsAstAlias(AstAlias *, VisitorContext);
static AstExprAlias *nsAstExprAlias(AstExprAlias *, VisitorContext);
static AstAnnotatedSymbol *nsAstAnnotatedSymbol(AstAnnotatedSymbol *,
                                                VisitorContext);
static AstDefLazy *nsAstDefLazy(AstDefLazy *, VisitorContext);
static AstTypeDef *nsAstTypeDef(AstTypeDef *, VisitorContext);
static AstTypeSig *nsAstTypeSig(AstTypeSig *, VisitorContext);
static AstTypeSymbols *nsAstTypeSymbols(AstTypeSymbols *, VisitorContext);
static AstTypeBody *nsAstTypeBody(AstTypeBody *, VisitorContext);
static AstTypeConstructor *nsAstTypeConstructor(AstTypeConstructor *,
                                                VisitorContext);
static AstTypeFunction *nsAstTypeFunction(AstTypeFunction *, VisitorContext);
static AstTypeList *nsAstTypeList(AstTypeList *, VisitorContext);
static AstTypeMap *nsAstTypeMap(AstTypeMap *, VisitorContext);
static AstType *nsAstType(AstType *, VisitorContext);
static AstCompositeFunction *nsAstCompositeFunction(AstCompositeFunction *,
                                                    VisitorContext);
static AstFunction *nsAstFunction(AstFunction *, VisitorContext);
static AstFargList *nsAstFargList(AstFargList *, VisitorContext);
static AstTaggedArgList *nsAstTaggedArgList(AstTaggedArgList *, VisitorContext);
static AstAltArgs *nsAstAltArgs(AstAltArgs *, VisitorContext);
static AstAltFunction *nsAstAltFunction(AstAltFunction *, VisitorContext);
static AstUnpack *nsAstUnpack(AstUnpack *, VisitorContext);
static AstUnpackStruct *nsAstUnpackStruct(AstUnpackStruct *, VisitorContext);
static AstNamedArg *nsAstNamedArg(AstNamedArg *, VisitorContext);
static AstFunCall *nsAstFunCall(AstFunCall *, VisitorContext);
static AstExpressions *nsAstExpressions(AstExpressions *, VisitorContext);
static HashSymbol *nsAstLookUpSymbol(AstLookUpSymbol *, VisitorContext);
static AstExpression *nsAstLookUp(AstLookUp *, VisitorContext);
static AstIff *nsAstIff(AstIff *, VisitorContext);
static AstPrint *nsAstPrint(AstPrint *, VisitorContext);
static AstTypeOf *nsAstTypeOf(AstTypeOf *, VisitorContext);
static AstStruct *nsAstStruct(AstStruct *, VisitorContext);
static AstTaggedExpressions *nsAstTaggedExpressions(AstTaggedExpressions *,
                                                    VisitorContext);
static AstTypeConstructorArgs *
nsAstTypeConstructorArgs(AstTypeConstructorArgs *, VisitorContext);
static AstLookUpOrSymbol *nsAstLookUpOrSymbol(AstLookUpOrSymbol *,
                                              VisitorContext);
static AstDefinition *nsAstDefinition(AstDefinition *, VisitorContext);
static AstTypeClause *nsAstTypeClause(AstTypeClause *, VisitorContext);
static AstFarg *nsAstFarg(AstFarg *, VisitorContext);
static AstExpression *nsAstExpression(AstExpression *, VisitorContext);
static AstNameSpaceArray *nsAstNameSpaceArray(AstNameSpaceArray *,
                                              VisitorContext);
static HashSymbol *nsSymbol(HashSymbol *, VisitorContext);

/////////////////////////////////////
// The main rewrite tool for lookups
/////////////////////////////////////

static HashSymbol *generateQualifiedSymbol(HashSymbol *unqualified,
                                           FileId *id) {
    SCharVec *buf = newSCharVec(128 + strlen(unqualified->name));
    int save = PROTECT(buf);
    sprintf(buf->entries, "#%lu#%lu#%s", id->stIno, id->stDev,
            unqualified->name);
    HashSymbol *qualified = newSymbol(buf->entries);
    UNPROTECT(save);
    return qualified;
}

///////////////////////
// Populate SymbolMaps
///////////////////////

static void populateReplacementsFromAlias(AstAlias *alias, FileId *id,
                                          VisitorContext context) {
    HashSymbol *replacement = generateQualifiedSymbol(alias->name, id);
    setSymbolMap(context.replacements, alias->name, replacement);
}

static void populateReplacementsFromDefine(AstDefine *define, FileId *id,
                                           VisitorContext context) {
    HashSymbol *replacement = generateQualifiedSymbol(define->symbol, id);
    setSymbolMap(context.replacements, define->symbol, replacement);
}

static void populateReplacementsFromLazy(AstDefLazy *lazy, FileId *id,
                                         VisitorContext context) {
    HashSymbol *replacement = generateQualifiedSymbol(lazy->name, id);
    setSymbolMap(context.replacements, lazy->name, replacement);
}

static void populateReplacementsFromSymbolList(AstSymbolList *list, FileId *id,
                                               VisitorContext context) {
    if (list == NULL)
        return;
    populateReplacementsFromSymbolList(list->next, id, context);
    HashSymbol *replacement = generateQualifiedSymbol(list->symbol, id);
    setSymbolMap(context.replacements, list->symbol, replacement);
}

static void populateReplacementsFromMulti(AstMultiDefine *multi, FileId *id,
                                          VisitorContext context) {
    populateReplacementsFromSymbolList(multi->symbols, id, context);
}

static void populateReplacementsFromTypeSig(AstTypeSig *typeSig, FileId *id,
                                            VisitorContext context) {
    HashSymbol *replacement = generateQualifiedSymbol(typeSig->symbol, id);
    setSymbolMap(context.replacements, typeSig->symbol, replacement);
}

static void
populateReplacementsFromTypeConstructor(AstTypeConstructor *typeConstructor,
                                        FileId *id, VisitorContext context) {
    HashSymbol *replacement =
        generateQualifiedSymbol(typeConstructor->symbol, id);
    setSymbolMap(context.replacements, typeConstructor->symbol, replacement);
}

static void populateReplacementsFromTypeBody(AstTypeBody *typeBody, FileId *id,
                                             VisitorContext context) {
    if (typeBody == NULL)
        return;
    populateReplacementsFromTypeBody(typeBody->next, id, context);
    populateReplacementsFromTypeConstructor(typeBody->typeConstructor, id,
                                            context);
}

static void populateReplacementsFromTypeDef(AstTypeDef *typeDef, FileId *id,
                                            VisitorContext context) {
    populateReplacementsFromTypeSig(typeDef->typeSig, id, context);
    populateReplacementsFromTypeBody(typeDef->typeBody, id, context);
}

static void populateReplacementsFromDefinitions(AstDefinitions *definitions,
                                                FileId *id,
                                                VisitorContext context) {
    if (definitions == NULL)
        return;
    populateReplacementsFromDefinitions(definitions->next, id, context);
    AstDefinition *def = definitions->definition;
    switch (def->type) {
    case AST_DEFINITION_TYPE_ALIAS:
        populateReplacementsFromAlias(getAstDefinition_Alias(def), id, context);
        break;
    case AST_DEFINITION_TYPE_BLANK:
    case AST_DEFINITION_TYPE_BUILTINSSLOT:
        break;
    case AST_DEFINITION_TYPE_DEFINE:
        populateReplacementsFromDefine(getAstDefinition_Define(def), id,
                                       context);
        break;
    case AST_DEFINITION_TYPE_LAZY:
        populateReplacementsFromLazy(getAstDefinition_Lazy(def), id, context);
        break;
    case AST_DEFINITION_TYPE_MULTI:
        populateReplacementsFromMulti(getAstDefinition_Multi(def), id, context);
        break;
    case AST_DEFINITION_TYPE_TYPEDEF:
        populateReplacementsFromTypeDef(getAstDefinition_TypeDef(def), id,
                                        context);
        break;
    default:
        cant_happen("unrecognized %s", astDefinitionTypeName(def->type));
    }
}

///////////////////////
// Merging Definitions
///////////////////////

static AstDefinitions *
mergeNameSpaceImplToPreamble(AstDefinitions *preamble,
                             AstNameSpaceImpl *nameSpaceImpl) {
    if (preamble == NULL) {
        return nameSpaceImpl->definitions;
    } else {
        AstDefinitions *rest =
            mergeNameSpaceImplToPreamble(preamble->next, nameSpaceImpl);
        int save = PROTECT(rest);
        AstDefinitions *this =
            newAstDefinitions(CPI(preamble), preamble->definition, rest);
        UNPROTECT(save);
        return this;
    }
}

static AstDefinitions *
mergeNameSpacesToPreamble(AstDefinitions *preamble,
                          AstNameSpaceArray *nameSpaces) {
    int save = PROTECT(preamble);
    for (Index i = 0; i < nameSpaces->size; i++) {
        AstNameSpaceImpl *nsImpl = nameSpaces->entries[i];
        preamble = mergeNameSpaceImplToPreamble(preamble, nsImpl);
        REPLACE_PROTECT(save, preamble);
    }
    UNPROTECT(save);
    return preamble;
}

////////////////////////////
// Visitor implementations
////////////////////////////

AstProg *nsAstProg(AstProg *node) {
    ENTER(nsAstProg);
    if (node == NULL) {
        LEAVE(nsAstProg);
        return NULL;
    }
    SymbolMap *replacements = newSymbolMap();
    int save = PROTECT(replacements);
    VisitorContext context = {.nameSpaces = node->nameSpaces,
                              .replacements = replacements};
    bool changed = false;
    // preamble
    AstDefinitions *new_preamble = nsAstDefinitions(node->preamble, context);
    PROTECT(new_preamble);
    changed = changed || (new_preamble != node->preamble);
    // namespaces
    AstNameSpaceArray *new_nameSpaces =
        nsAstNameSpaceArray(node->nameSpaces, context);
    PROTECT(new_nameSpaces);
    changed = changed || (new_nameSpaces != node->nameSpaces);
    // body
    AstExpressions *new_body = nsAstExpressions(node->body, context);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);
    AstProg *result = node;
    // merge
    if (changed) {
        new_preamble = mergeNameSpacesToPreamble(new_preamble, new_nameSpaces);
        PROTECT(new_preamble);
        new_nameSpaces = newAstNameSpaceArray();
        PROTECT(new_nameSpaces);
        result = newAstProg(CPI(node), new_preamble, new_nameSpaces, new_body);
    }
    UNPROTECT(save);
    LEAVE(nsAstProg);
    return result;
}

static AstNest *nsAstNest(AstNest *node, VisitorContext context) {
    ENTER(nsAstNest);
    if (node == NULL) {
        LEAVE(nsAstNest);
        return NULL;
    }

    bool changed = false;
    AstDefinitions *new_definitions =
        nsAstDefinitions(node->definitions, context);
    int save = PROTECT(new_definitions);
    changed = changed || (new_definitions != node->definitions);
    AstExpressions *new_expressions =
        nsAstExpressions(node->expressions, context);
    PROTECT(new_expressions);
    changed = changed || (new_expressions != node->expressions);

    AstNest *result = node;
    if (changed) {
        result = newAstNest(CPI(node), new_definitions, new_expressions);
    }

    UNPROTECT(save);
    LEAVE(nsAstNest);
    return result;
}

static AstNameSpaceImpl *nsAstNameSpaceImpl(AstNameSpaceImpl *node, int nsId,
                                            VisitorContext context) {
    ENTER(nsAstNameSpaceImpl);
    if (node == NULL) {
        LEAVE(nsAstNameSpaceImpl);
        return NULL;
    }
    bool changed = false;
    context.replacements = newSymbolMap();
    int save = PROTECT(context.replacements);
    context.nameSpaces->entries[nsId]->replacements = context.replacements;
    populateReplacementsFromDefinitions(node->definitions, node->id, context);
    AstDefinitions *new_definitions =
        nsAstDefinitions(node->definitions, context);
    PROTECT(new_definitions);
    changed = changed || (new_definitions != node->definitions);
    AstNameSpaceImpl *result = node;
    if (changed) {
        result = newAstNameSpaceImpl(CPI(node), node->id, new_definitions);
    }
    result->replacements = context.replacements;
    UNPROTECT(save);
    LEAVE(nsAstNameSpaceImpl);
    return result;
}

// definitions at the top-level of a namespace should have their
// symbols replaced.
static AstDefinitions *nsAstDefinitions(AstDefinitions *node,
                                        VisitorContext context) {
    ENTER(nsAstDefinitions);
    if (node == NULL) {
        LEAVE(nsAstDefinitions);
        return NULL;
    }
    bool changed = false;
    AstDefinition *new_definition = nsAstDefinition(node->definition, context);
    int save = PROTECT(new_definition);
    changed = changed || (new_definition != node->definition);
    AstDefinitions *new_next = nsAstDefinitions(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);
    AstDefinitions *result = node;
    if (changed) {
        result = newAstDefinitions(CPI(node), new_definition, new_next);
    }
    UNPROTECT(save);
    LEAVE(nsAstDefinitions);
    return result;
}

static AstDefine *nsAstDefine(AstDefine *node, VisitorContext context) {
    ENTER(nsAstDefine);
    if (node == NULL) {
        LEAVE(nsAstDefine);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_expression = nsAstExpression(node->expression, context);
    int save = PROTECT(new_expression);
    changed = changed || (new_expression != node->expression);

    HashSymbol *new_symbol = nsSymbol(node->symbol, context);
    changed = changed || (new_symbol != node->symbol);
    AstDefine *result = node;
    if (changed) {
        result = newAstDefine(CPI(node), new_symbol, new_expression);
    }

    UNPROTECT(save);
    LEAVE(nsAstDefine);
    return result;
}

static AstMultiDefine *nsAstMultiDefine(AstMultiDefine *node,
                                        VisitorContext context) {
    ENTER(nsAstMultiDefine);
    if (node == NULL) {
        LEAVE(nsAstMultiDefine);
        return NULL;
    }

    bool changed = false;
    AstSymbolList *new_symbols = nsAstSymbolList(node->symbols, context);
    int save = PROTECT(new_symbols);
    changed = changed || (new_symbols != node->symbols);
    AstExpression *new_expression = nsAstExpression(node->expression, context);
    PROTECT(new_expression);
    changed = changed || (new_expression != node->expression);

    AstMultiDefine *result = node;
    if (changed) {
        result = newAstMultiDefine(CPI(node), new_symbols, new_expression);
    }

    UNPROTECT(save);
    LEAVE(nsAstMultiDefine);
    return result;
}

static AstSymbolList *nsAstSymbolList(AstSymbolList *node,
                                      VisitorContext context) {
    ENTER(nsAstSymbolList);
    if (node == NULL) {
        LEAVE(nsAstSymbolList);
        return NULL;
    }
    bool changed = false;
    AstSymbolList *new_next = nsAstSymbolList(node->next, context);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);
    HashSymbol *new_symbol = nsSymbol(node->symbol, context);
    changed = changed || (new_symbol != node->symbol);
    AstSymbolList *result = node;
    if (changed) {
        result = newAstSymbolList(CPI(node), new_symbol, new_next);
    }
    UNPROTECT(save);
    LEAVE(nsAstSymbolList);
    return result;
}

static AstAlias *nsAstAlias(AstAlias *node, VisitorContext context) {
    ENTER(nsAstAlias);
    if (node == NULL) {
        LEAVE(nsAstAlias);
        return NULL;
    }

    bool changed = false;
    AstType *new_type = nsAstType(node->type, context);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    HashSymbol *new_name = nsSymbol(node->name, context);
    changed = changed || (new_name != node->name);

    AstAlias *result = node;
    if (changed) {
        result = newAstAlias(CPI(node), new_name, new_type);
    }

    UNPROTECT(save);
    LEAVE(nsAstAlias);
    return result;
}

static AstExprAlias *nsAstExprAlias(AstExprAlias *node,
                                    VisitorContext context) {
    ENTER(nsAstExprAlias);
    if (node == NULL) {
        LEAVE(nsAstExprAlias);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_value = nsAstExpression(node->value, context);
    int save = PROTECT(new_value);
    changed = changed || (new_value != node->value);
    HashSymbol *new_name = nsSymbol(node->name, context);
    changed = changed || (new_name != node->name);

    AstExprAlias *result = node;
    if (changed) {
        result = newAstExprAlias(CPI(node), new_name, new_value);
    }

    UNPROTECT(save);
    LEAVE(nsAstExprAlias);
    return result;
}

static AstAnnotatedSymbol *nsAstAnnotatedSymbol(AstAnnotatedSymbol *node,
                                                VisitorContext context) {
    ENTER(nsAstAnnotatedSymbol);
    if (node == NULL) {
        LEAVE(nsAstAnnotatedSymbol);
        return NULL;
    }
    bool changed = false;
    AstExpression *new_originalImpl =
        nsAstExpression(node->originalImpl, context);
    int save = PROTECT(new_originalImpl);
    changed = changed || (new_originalImpl != node->originalImpl);
    HashSymbol *new_symbol = nsSymbol(node->symbol, context);
    changed = changed || (new_symbol != node->symbol);
    AstAnnotatedSymbol *result = node;
    if (changed) {
        result = newAstAnnotatedSymbol(CPI(node), new_symbol, new_originalImpl);
        result->isLazy = node->isLazy;
    }
    UNPROTECT(save);
    LEAVE(nsAstAnnotatedSymbol);
    return result;
}

static AstDefLazy *nsAstDefLazy(AstDefLazy *node, VisitorContext context) {
    ENTER(nsAstDefLazy);
    if (node == NULL) {
        LEAVE(nsAstDefLazy);
        return NULL;
    }

    bool changed = false;
    AstAltFunction *new_definition =
        nsAstAltFunction(node->definition, context);
    int save = PROTECT(new_definition);
    changed = changed || (new_definition != node->definition);
    HashSymbol *new_name = nsSymbol(node->name, context);
    changed = changed || (new_name != node->name);

    AstDefLazy *result = node;
    if (changed) {
        result = newAstDefLazy(CPI(node), new_name, new_definition);
    }

    UNPROTECT(save);
    LEAVE(nsAstDefLazy);
    return result;
}

static AstTypeDef *nsAstTypeDef(AstTypeDef *node, VisitorContext context) {
    ENTER(nsAstTypeDef);
    if (node == NULL) {
        LEAVE(nsAstTypeDef);
        return NULL;
    }

    bool changed = false;
    AstTypeSig *new_typeSig = nsAstTypeSig(node->typeSig, context);
    int save = PROTECT(new_typeSig);
    changed = changed || (new_typeSig != node->typeSig);
    AstTypeBody *new_typeBody = nsAstTypeBody(node->typeBody, context);
    PROTECT(new_typeBody);
    changed = changed || (new_typeBody != node->typeBody);

    AstTypeDef *result = node;
    if (changed) {
        result = newAstTypeDef(CPI(node), new_typeSig, new_typeBody);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeDef);
    return result;
}

static AstTypeSig *nsAstTypeSig(AstTypeSig *node, VisitorContext context) {
    ENTER(nsAstTypeSig);
    if (node == NULL) {
        LEAVE(nsAstTypeSig);
        return NULL;
    }

    bool changed = false;
    AstTypeSymbols *new_typeSymbols =
        nsAstTypeSymbols(node->typeSymbols, context);
    int save = PROTECT(new_typeSymbols);
    changed = changed || (new_typeSymbols != node->typeSymbols);
    HashSymbol *new_symbol = nsSymbol(node->symbol, context);
    changed = changed || (new_symbol != node->symbol);

    AstTypeSig *result = node;
    if (changed) {
        result = newAstTypeSig(CPI(node), new_symbol, new_typeSymbols);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeSig);
    return result;
}

static AstTypeSymbols *nsAstTypeSymbols(AstTypeSymbols *node,
                                        VisitorContext context) {
    ENTER(nsAstTypeSymbols);
    if (node == NULL) {
        LEAVE(nsAstTypeSymbols);
        return NULL;
    }

    bool changed = false;
    AstTypeSymbols *new_next = nsAstTypeSymbols(node->next, context);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);
    HashSymbol *new_typeSymbol = nsSymbol(node->typeSymbol, context);
    changed = changed || (new_typeSymbol != node->typeSymbol);

    AstTypeSymbols *result = node;
    if (changed) {
        result = newAstTypeSymbols(CPI(node), new_typeSymbol, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeSymbols);
    return result;
}

static AstTypeBody *nsAstTypeBody(AstTypeBody *node, VisitorContext context) {
    ENTER(nsAstTypeBody);
    if (node == NULL) {
        LEAVE(nsAstTypeBody);
        return NULL;
    }

    bool changed = false;
    AstTypeConstructor *new_typeConstructor =
        nsAstTypeConstructor(node->typeConstructor, context);
    int save = PROTECT(new_typeConstructor);
    changed = changed || (new_typeConstructor != node->typeConstructor);
    AstTypeBody *new_next = nsAstTypeBody(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstTypeBody *result = node;
    if (changed) {
        result = newAstTypeBody(CPI(node), new_typeConstructor, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeBody);
    return result;
}

static AstTypeConstructor *nsAstTypeConstructor(AstTypeConstructor *node,
                                                VisitorContext context) {
    ENTER(nsAstTypeConstructor);
    if (node == NULL) {
        LEAVE(nsAstTypeConstructor);
        return NULL;
    }

    bool changed = false;
    AstTypeConstructorArgs *new_args =
        nsAstTypeConstructorArgs(node->args, context);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);
    HashSymbol *new_symbol = nsSymbol(node->symbol, context);
    changed = changed || (new_symbol != node->symbol);

    AstTypeConstructor *result = node;
    if (changed) {
        result = newAstTypeConstructor(CPI(node), new_symbol, new_args);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeConstructor);
    return result;
}

static AstTypeFunction *nsAstTypeFunction(AstTypeFunction *node,
                                          VisitorContext context) {
    ENTER(nsAstTypeFunction);
    if (node == NULL) {
        LEAVE(nsAstTypeFunction);
        return NULL;
    }

    bool changed = false;
    AstLookUpOrSymbol *new_symbol = nsAstLookUpOrSymbol(node->symbol, context);
    int save = PROTECT(new_symbol);
    changed = changed || (new_symbol != node->symbol);
    AstTypeList *new_typeList = nsAstTypeList(node->typeList, context);
    PROTECT(new_typeList);
    changed = changed || (new_typeList != node->typeList);

    AstTypeFunction *result = node;
    if (changed) {
        result = newAstTypeFunction(CPI(node), new_symbol, new_typeList);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeFunction);
    return result;
}

static AstTypeList *nsAstTypeList(AstTypeList *node, VisitorContext context) {
    ENTER(nsAstTypeList);
    if (node == NULL) {
        LEAVE(nsAstTypeList);
        return NULL;
    }

    bool changed = false;
    AstType *new_type = nsAstType(node->type, context);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    AstTypeList *new_next = nsAstTypeList(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstTypeList *result = node;
    if (changed) {
        result = newAstTypeList(CPI(node), new_type, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeList);
    return result;
}

static AstTypeMap *nsAstTypeMap(AstTypeMap *node, VisitorContext context) {
    ENTER(nsAstTypeMap);
    if (node == NULL) {
        LEAVE(nsAstTypeMap);
        return NULL;
    }

    bool changed = false;
    AstType *new_type = nsAstType(node->type, context);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    AstTypeMap *new_next = nsAstTypeMap(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstTypeMap *result = node;
    if (changed) {
        result = newAstTypeMap(CPI(node), node->key, new_type, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeMap);
    return result;
}

static AstType *nsAstType(AstType *node, VisitorContext context) {
    ENTER(nsAstType);
    if (node == NULL) {
        LEAVE(nsAstType);
        return NULL;
    }

    bool changed = false;
    AstTypeClause *new_typeClause = nsAstTypeClause(node->typeClause, context);
    int save = PROTECT(new_typeClause);
    changed = changed || (new_typeClause != node->typeClause);
    AstType *new_next = nsAstType(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstType *result = node;
    if (changed) {
        result = newAstType(CPI(node), new_typeClause, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstType);
    return result;
}

static AstCompositeFunction *nsAstCompositeFunction(AstCompositeFunction *node,
                                                    VisitorContext context) {
    ENTER(nsAstCompositeFunction);
    if (node == NULL) {
        LEAVE(nsAstCompositeFunction);
        return NULL;
    }

    bool changed = false;
    AstFunction *new_function = nsAstFunction(node->function, context);
    int save = PROTECT(new_function);
    changed = changed || (new_function != node->function);
    AstCompositeFunction *new_next =
        nsAstCompositeFunction(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstCompositeFunction *result = node;
    if (changed) {
        result = newAstCompositeFunction(CPI(node), new_function, new_next);
        result->unsafe = node->unsafe;
    }

    UNPROTECT(save);
    LEAVE(nsAstCompositeFunction);
    return result;
}

static AstFunction *nsAstFunction(AstFunction *node, VisitorContext context) {
    ENTER(nsAstFunction);
    if (node == NULL) {
        LEAVE(nsAstFunction);
        return NULL;
    }

    bool changed = false;
    AstFargList *new_argList = nsAstFargList(node->argList, context);
    int save = PROTECT(new_argList);
    changed = changed || (new_argList != node->argList);
    AstNest *new_nest = nsAstNest(node->nest, context);
    PROTECT(new_nest);
    changed = changed || (new_nest != node->nest);

    AstFunction *result = node;
    if (changed) {
        result = newAstFunction(CPI(node), new_argList, new_nest);
    }

    UNPROTECT(save);
    LEAVE(nsAstFunction);
    return result;
}

static AstFargList *nsAstFargList(AstFargList *node, VisitorContext context) {
    ENTER(nsAstFargList);
    if (node == NULL) {
        LEAVE(nsAstFargList);
        return NULL;
    }

    bool changed = false;
    AstFarg *new_arg = nsAstFarg(node->arg, context);
    int save = PROTECT(new_arg);
    changed = changed || (new_arg != node->arg);
    AstFargList *new_next = nsAstFargList(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstFargList *result = node;
    if (changed) {
        result = newAstFargList(CPI(node), new_arg, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstFargList);
    return result;
}

static AstTaggedArgList *nsAstTaggedArgList(AstTaggedArgList *node,
                                            VisitorContext context) {
    ENTER(nsAstTaggedArgList);
    if (node == NULL) {
        LEAVE(nsAstTaggedArgList);
        return NULL;
    }

    bool changed = false;
    AstFarg *new_arg = nsAstFarg(node->arg, context);
    int save = PROTECT(new_arg);
    changed = changed || (new_arg != node->arg);
    AstTaggedArgList *new_next = nsAstTaggedArgList(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstTaggedArgList *result = node;
    if (changed) {
        result = newAstTaggedArgList(CPI(node), node->tag, new_arg, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstTaggedArgList);
    return result;
}

static AstAltArgs *nsAstAltArgs(AstAltArgs *node, VisitorContext context) {
    ENTER(nsAstAltArgs);
    if (node == NULL) {
        LEAVE(nsAstAltArgs);
        return NULL;
    }

    bool changed = false;
    AstFargList *new_argList = nsAstFargList(node->argList, context);
    int save = PROTECT(new_argList);
    changed = changed || (new_argList != node->argList);
    AstAltArgs *new_next = nsAstAltArgs(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstAltArgs *result = node;
    if (changed) {
        result = newAstAltArgs(CPI(node), new_argList, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstAltArgs);
    return result;
}

static AstAltFunction *nsAstAltFunction(AstAltFunction *node,
                                        VisitorContext context) {
    ENTER(nsAstAltFunction);
    if (node == NULL) {
        LEAVE(nsAstAltFunction);
        return NULL;
    }

    bool changed = false;
    AstAltArgs *new_altArgs = nsAstAltArgs(node->altArgs, context);
    int save = PROTECT(new_altArgs);
    changed = changed || (new_altArgs != node->altArgs);
    AstNest *new_nest = nsAstNest(node->nest, context);
    PROTECT(new_nest);
    changed = changed || (new_nest != node->nest);

    AstAltFunction *result = node;
    if (changed) {
        result = newAstAltFunction(CPI(node), new_altArgs, new_nest);
    }

    UNPROTECT(save);
    LEAVE(nsAstAltFunction);
    return result;
}

static AstUnpack *nsAstUnpack(AstUnpack *node, VisitorContext context) {
    ENTER(nsAstUnpack);
    if (node == NULL) {
        LEAVE(nsAstUnpack);
        return NULL;
    }

    bool changed = false;
    AstLookUpOrSymbol *new_symbol = nsAstLookUpOrSymbol(node->symbol, context);
    int save = PROTECT(new_symbol);
    changed = changed || (new_symbol != node->symbol);
    AstFargList *new_argList = nsAstFargList(node->argList, context);
    PROTECT(new_argList);
    changed = changed || (new_argList != node->argList);

    AstUnpack *result = node;
    if (changed) {
        result = newAstUnpack(CPI(node), new_symbol, new_argList);
    }

    UNPROTECT(save);
    LEAVE(nsAstUnpack);
    return result;
}

static AstUnpackStruct *nsAstUnpackStruct(AstUnpackStruct *node,
                                          VisitorContext context) {
    ENTER(nsAstUnpackStruct);
    if (node == NULL) {
        LEAVE(nsAstUnpackStruct);
        return NULL;
    }

    bool changed = false;
    AstLookUpOrSymbol *new_symbol = nsAstLookUpOrSymbol(node->symbol, context);
    int save = PROTECT(new_symbol);
    changed = changed || (new_symbol != node->symbol);
    AstTaggedArgList *new_argList = nsAstTaggedArgList(node->argList, context);
    PROTECT(new_argList);
    changed = changed || (new_argList != node->argList);

    AstUnpackStruct *result = node;
    if (changed) {
        result = newAstUnpackStruct(CPI(node), new_symbol, new_argList);
    }

    UNPROTECT(save);
    LEAVE(nsAstUnpackStruct);
    return result;
}

static AstNamedArg *nsAstNamedArg(AstNamedArg *node, VisitorContext context) {
    ENTER(nsAstNamedArg);
    if (node == NULL) {
        LEAVE(nsAstNamedArg);
        return NULL;
    }

    bool changed = false;
    AstFarg *new_arg = nsAstFarg(node->arg, context);
    int save = PROTECT(new_arg);
    changed = changed || (new_arg != node->arg);
    HashSymbol *new_name = nsSymbol(node->name, context);
    changed = changed || (new_name != node->name);

    AstNamedArg *result = node;
    if (changed) {
        result = newAstNamedArg(CPI(node), new_name, new_arg);
    }

    UNPROTECT(save);
    LEAVE(nsAstNamedArg);
    return result;
}

static AstFunCall *nsAstFunCall(AstFunCall *node, VisitorContext context) {
    ENTER(nsAstFunCall);
    if (node == NULL) {
        LEAVE(nsAstFunCall);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_function = nsAstExpression(node->function, context);
    int save = PROTECT(new_function);
    changed = changed || (new_function != node->function);
    AstExpressions *new_arguments = nsAstExpressions(node->arguments, context);
    PROTECT(new_arguments);
    changed = changed || (new_arguments != node->arguments);

    AstFunCall *result = node;
    if (changed) {
        result = newAstFunCall(CPI(node), new_function, new_arguments);
        result->isBuiltin = node->isBuiltin;
    }

    UNPROTECT(save);
    LEAVE(nsAstFunCall);
    return result;
}

static AstExpressions *nsAstExpressions(AstExpressions *node,
                                        VisitorContext context) {
    ENTER(nsAstExpressions);
    if (node == NULL) {
        LEAVE(nsAstExpressions);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_expression = nsAstExpression(node->expression, context);
    int save = PROTECT(new_expression);
    changed = changed || (new_expression != node->expression);
    AstExpressions *new_next = nsAstExpressions(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstExpressions *result = node;
    if (changed) {
        result = newAstExpressions(CPI(node), new_expression, new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstExpressions);
    return result;
}

static VisitorContext switchVisitorContext(VisitorContext context, int nsId) {
    VisitorContext new_context = context;
#ifdef SAFETY_CHECKS
    if (nsId < 0 || ((Index)nsId) >= context.nameSpaces->size) {
        cant_happen("invalid namespace id %d", nsId);
    }
    if (context.nameSpaces->entries[nsId] == NULL) {
        cant_happen("namespace id %d has not been visited yet [1]", nsId);
    }
    if (context.nameSpaces->entries[nsId]->replacements == NULL) {
        cant_happen("namespace id %d has not been visited yet [2]", nsId);
    }
#endif
    new_context.replacements = context.nameSpaces->entries[nsId]->replacements;
    return new_context;
}

static HashSymbol *nsAstLookUpSymbol(AstLookUpSymbol *node,
                                     VisitorContext context) {
    ENTER(nsAstLookUpSymbol);
    if (node == NULL) {
        LEAVE(nsAstLookUpSymbol);
        return NULL;
    }
    VisitorContext new_context = switchVisitorContext(context, node->nsId);
    return nsSymbol(node->symbol, new_context);
}

static AstExpression *nsAstLookUp(AstLookUp *node, VisitorContext context) {
    ENTER(nsAstLookUp);
    if (node == NULL) {
        LEAVE(nsAstLookUp);
        return NULL;
    }
    VisitorContext new_context = switchVisitorContext(context, node->nsId);
    return nsAstExpression(node->expression, new_context);
}

static AstIff *nsAstIff(AstIff *node, VisitorContext context) {
    ENTER(nsAstIff);
    if (node == NULL) {
        LEAVE(nsAstIff);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_test = nsAstExpression(node->test, context);
    int save = PROTECT(new_test);
    changed = changed || (new_test != node->test);
    AstNest *new_consequent = nsAstNest(node->consequent, context);
    PROTECT(new_consequent);
    changed = changed || (new_consequent != node->consequent);
    AstNest *new_alternative = nsAstNest(node->alternative, context);
    PROTECT(new_alternative);
    changed = changed || (new_alternative != node->alternative);

    AstIff *result = node;
    if (changed) {
        result =
            newAstIff(CPI(node), new_test, new_consequent, new_alternative);
    }

    UNPROTECT(save);
    LEAVE(nsAstIff);
    return result;
}

static AstPrint *nsAstPrint(AstPrint *node, VisitorContext context) {
    ENTER(nsAstPrint);
    if (node == NULL) {
        LEAVE(nsAstPrint);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_exp = nsAstExpression(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    AstPrint *result = node;
    if (changed) {
        result = newAstPrint(CPI(node), new_exp);
    }

    UNPROTECT(save);
    LEAVE(nsAstPrint);
    return result;
}

static AstTypeOf *nsAstTypeOf(AstTypeOf *node, VisitorContext context) {
    ENTER(nsAstTypeOf);
    if (node == NULL) {
        LEAVE(nsAstTypeOf);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_exp = nsAstExpression(node->exp, context);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    AstTypeOf *result = node;
    if (changed) {
        result = newAstTypeOf(CPI(node), new_exp);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeOf);
    return result;
}

static AstStruct *nsAstStruct(AstStruct *node, VisitorContext context) {
    ENTER(nsAstStruct);
    if (node == NULL) {
        LEAVE(nsAstStruct);
        return NULL;
    }

    bool changed = false;
    AstLookUpOrSymbol *new_symbol = nsAstLookUpOrSymbol(node->symbol, context);
    int save = PROTECT(new_symbol);
    changed = changed || (new_symbol != node->symbol);
    AstTaggedExpressions *new_expressions =
        nsAstTaggedExpressions(node->expressions, context);
    PROTECT(new_expressions);
    changed = changed || (new_expressions != node->expressions);

    AstStruct *result = node;
    if (changed) {
        result = newAstStruct(CPI(node), new_symbol, new_expressions);
    }

    UNPROTECT(save);
    LEAVE(nsAstStruct);
    return result;
}

static AstTaggedExpressions *nsAstTaggedExpressions(AstTaggedExpressions *node,
                                                    VisitorContext context) {
    ENTER(nsAstTaggedExpressions);
    if (node == NULL) {
        LEAVE(nsAstTaggedExpressions);
        return NULL;
    }

    bool changed = false;
    AstExpression *new_expression = nsAstExpression(node->expression, context);
    int save = PROTECT(new_expression);
    changed = changed || (new_expression != node->expression);
    AstTaggedExpressions *new_next =
        nsAstTaggedExpressions(node->next, context);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    AstTaggedExpressions *result = node;
    if (changed) {
        result = newAstTaggedExpressions(CPI(node), node->tag, new_expression,
                                         new_next);
    }

    UNPROTECT(save);
    LEAVE(nsAstTaggedExpressions);
    return result;
}

static AstTypeConstructorArgs *
nsAstTypeConstructorArgs(AstTypeConstructorArgs *node, VisitorContext context) {
    ENTER(nsAstTypeConstructorArgs);
    if (node == NULL) {
        LEAVE(nsAstTypeConstructorArgs);
        return NULL;
    }

    int save = PROTECT(NULL);
    AstTypeConstructorArgs *result = node;

    switch (node->type) {
    case AST_TYPECONSTRUCTORARGS_TYPE_LIST: {
        AstTypeList *variant = getAstTypeConstructorArgs_List(node);
        AstTypeList *new_variant = nsAstTypeList(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstTypeConstructorArgs_List(CPI(node), new_variant);
        }
        break;
    }
    case AST_TYPECONSTRUCTORARGS_TYPE_MAP: {
        AstTypeMap *variant = getAstTypeConstructorArgs_Map(node);
        AstTypeMap *new_variant = nsAstTypeMap(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstTypeConstructorArgs_Map(CPI(node), new_variant);
        }
        break;
    }
    default:
        cant_happen("unrecognized AstTypeConstructorArgs type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeConstructorArgs);
    return result;
}

static AstLookUpOrSymbol *nsAstLookUpOrSymbol(AstLookUpOrSymbol *node,
                                              VisitorContext context) {
    ENTER(nsAstLookUpOrSymbol);
    if (node == NULL) {
        LEAVE(nsAstLookUpOrSymbol);
        return NULL;
    }

    int save = PROTECT(NULL);
    AstLookUpOrSymbol *result = node;

    switch (node->type) {
    case AST_LOOKUPORSYMBOL_TYPE_SYMBOL: {
        HashSymbol *variant = getAstLookUpOrSymbol_Symbol(node);
        HashSymbol *new_variant = nsSymbol(variant, context);
        if (new_variant != variant) {
            result = newAstLookUpOrSymbol_Symbol(CPI(node), new_variant);
        }
        break;
    }
    case AST_LOOKUPORSYMBOL_TYPE_LOOKUP: {
        AstLookUpSymbol *variant = getAstLookUpOrSymbol_LookUp(node);
        HashSymbol *new_variant = nsAstLookUpSymbol(variant, context);
        result = newAstLookUpOrSymbol_Symbol(CPI(node), new_variant);
        break;
    }
    default:
        cant_happen("unrecognized AstLookUpOrSymbol type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(nsAstLookUpOrSymbol);
    return result;
}

static AstDefinition *nsAstDefinition(AstDefinition *node,
                                      VisitorContext context) {
    ENTER(nsAstDefinition);
    if (node == NULL) {
        LEAVE(nsAstDefinition);
        return NULL;
    }

    int save = PROTECT(NULL);
    AstDefinition *result = node;

    switch (node->type) {
    case AST_DEFINITION_TYPE_DEFINE: {
        AstDefine *variant = getAstDefinition_Define(node);
        AstDefine *new_variant = nsAstDefine(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstDefinition_Define(CPI(node), new_variant);
        }
        break;
    }
    case AST_DEFINITION_TYPE_MULTI: {
        AstMultiDefine *variant = getAstDefinition_Multi(node);
        AstMultiDefine *new_variant = nsAstMultiDefine(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstDefinition_Multi(CPI(node), new_variant);
        }
        break;
    }
    case AST_DEFINITION_TYPE_TYPEDEF: {
        AstTypeDef *variant = getAstDefinition_TypeDef(node);
        AstTypeDef *new_variant = nsAstTypeDef(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstDefinition_TypeDef(CPI(node), new_variant);
        }
        break;
    }
    case AST_DEFINITION_TYPE_LAZY: {
        AstDefLazy *variant = getAstDefinition_Lazy(node);
        AstDefLazy *new_variant = nsAstDefLazy(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstDefinition_Lazy(CPI(node), new_variant);
        }
        break;
    }
    case AST_DEFINITION_TYPE_ALIAS: {
        AstAlias *variant = getAstDefinition_Alias(node);
        AstAlias *new_variant = nsAstAlias(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstDefinition_Alias(CPI(node), new_variant);
        }
        break;
    }
    case AST_DEFINITION_TYPE_BLANK: {
        break;
    }
    case AST_DEFINITION_TYPE_BUILTINSSLOT: {
        break;
    }
    default:
        cant_happen("unrecognized AstDefinition type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(nsAstDefinition);
    return result;
}

static AstTypeClause *nsAstTypeClause(AstTypeClause *node,
                                      VisitorContext context) {
    ENTER(nsAstTypeClause);
    if (node == NULL) {
        LEAVE(nsAstTypeClause);
        return NULL;
    }

    int save = PROTECT(NULL);
    AstTypeClause *result = node;

    switch (node->type) {
    case AST_TYPECLAUSE_TYPE_INTEGER: {
        break;
    }
    case AST_TYPECLAUSE_TYPE_CHARACTER: {
        break;
    }
    case AST_TYPECLAUSE_TYPE_VAR: {
        break;
    }
    case AST_TYPECLAUSE_TYPE_TYPEFUNCTION: {
        AstTypeFunction *variant = getAstTypeClause_TypeFunction(node);
        AstTypeFunction *new_variant = nsAstTypeFunction(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstTypeClause_TypeFunction(CPI(node), new_variant);
        }
        break;
    }
    case AST_TYPECLAUSE_TYPE_TYPETUPLE: {
        AstTypeList *variant = getAstTypeClause_TypeTuple(node);
        AstTypeList *new_variant = nsAstTypeList(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstTypeClause_TypeTuple(CPI(node), new_variant);
        }
        break;
    }
    default:
        cant_happen("unrecognized AstTypeClause type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(nsAstTypeClause);
    return result;
}

static AstFarg *nsAstFarg(AstFarg *node, VisitorContext context) {
    ENTER(nsAstFarg);
    if (node == NULL) {
        LEAVE(nsAstFarg);
        return NULL;
    }

    int save = PROTECT(NULL);
    AstFarg *result = node;

    switch (node->type) {
    case AST_FARG_TYPE_WILDCARD: {
        break;
    }
    case AST_FARG_TYPE_SYMBOL: {
        HashSymbol *variant = getAstFarg_Symbol(node);
        HashSymbol *new_variant = nsSymbol(variant, context);
        if (new_variant != variant) {
            result = newAstFarg_Symbol(CPI(node), new_variant);
        }
        break;
    }
    case AST_FARG_TYPE_LOOKUP: {
        AstLookUpSymbol *variant = getAstFarg_LookUp(node);
        HashSymbol *new_variant = nsAstLookUpSymbol(variant, context);
        result = newAstFarg_Symbol(CPI(node), new_variant);
        break;
    }
    case AST_FARG_TYPE_NAMED: {
        AstNamedArg *variant = getAstFarg_Named(node);
        AstNamedArg *new_variant = nsAstNamedArg(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstFarg_Named(CPI(node), new_variant);
        }
        break;
    }
    case AST_FARG_TYPE_UNPACK: {
        AstUnpack *variant = getAstFarg_Unpack(node);
        AstUnpack *new_variant = nsAstUnpack(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstFarg_Unpack(CPI(node), new_variant);
        }
        break;
    }
    case AST_FARG_TYPE_UNPACKSTRUCT: {
        AstUnpackStruct *variant = getAstFarg_UnpackStruct(node);
        AstUnpackStruct *new_variant = nsAstUnpackStruct(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstFarg_UnpackStruct(CPI(node), new_variant);
        }
        break;
    }
    case AST_FARG_TYPE_NUMBER: {
        break;
    }
    case AST_FARG_TYPE_CHARACTER: {
        break;
    }
    case AST_FARG_TYPE_TUPLE: {
        AstFargList *variant = getAstFarg_Tuple(node);
        AstFargList *new_variant = nsAstFargList(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstFarg_Tuple(CPI(node), new_variant);
        }
        break;
    }
    default:
        cant_happen("unrecognized AstFarg type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(nsAstFarg);
    return result;
}

static AstExpression *nsAstExpression(AstExpression *node,
                                      VisitorContext context) {
    ENTER(nsAstExpression);
    if (node == NULL) {
        LEAVE(nsAstExpression);
        return NULL;
    }

    int save = PROTECT(NULL);
    AstExpression *result = node;

    switch (node->type) {
    case AST_EXPRESSION_TYPE_BACK: {
        break;
    }
    case AST_EXPRESSION_TYPE_WILDCARD: {
        break;
    }
    case AST_EXPRESSION_TYPE_ALIAS: {
        AstExprAlias *variant = getAstExpression_Alias(node);
        AstExprAlias *new_variant = nsAstExprAlias(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Alias(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_ANNOTATEDSYMBOL: {
        AstAnnotatedSymbol *variant = getAstExpression_AnnotatedSymbol(node);
        AstAnnotatedSymbol *new_variant =
            nsAstAnnotatedSymbol(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_AnnotatedSymbol(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_FUNCALL: {
        AstFunCall *variant = getAstExpression_FunCall(node);
        AstFunCall *new_variant = nsAstFunCall(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_FunCall(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_LOOKUP: {
        AstLookUp *variant = getAstExpression_LookUp(node);
        result = nsAstLookUp(variant, context);
        break;
    }
    case AST_EXPRESSION_TYPE_SYMBOL: {
        HashSymbol *new_symbol =
            nsSymbol(getAstExpression_Symbol(node), context);
        result = newAstExpression_Symbol(CPI(node), new_symbol);
        break;
    }
    case AST_EXPRESSION_TYPE_NUMBER: {
        break;
    }
    case AST_EXPRESSION_TYPE_CHARACTER: {
        break;
    }
    case AST_EXPRESSION_TYPE_FUN: {
        AstCompositeFunction *variant = getAstExpression_Fun(node);
        AstCompositeFunction *new_variant =
            nsAstCompositeFunction(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Fun(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_NEST: {
        AstNest *variant = getAstExpression_Nest(node);
        AstNest *new_variant = nsAstNest(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Nest(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_IFF: {
        AstIff *variant = getAstExpression_Iff(node);
        AstIff *new_variant = nsAstIff(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Iff(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_PRINT: {
        AstPrint *variant = getAstExpression_Print(node);
        AstPrint *new_variant = nsAstPrint(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Print(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_TYPEOF: {
        AstTypeOf *variant = getAstExpression_TypeOf(node);
        AstTypeOf *new_variant = nsAstTypeOf(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_TypeOf(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_TUPLE: {
        AstExpressions *variant = getAstExpression_Tuple(node);
        AstExpressions *new_variant = nsAstExpressions(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Tuple(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_ENV: {
        break;
    }
    case AST_EXPRESSION_TYPE_STRUCTURE: {
        AstStruct *variant = getAstExpression_Structure(node);
        AstStruct *new_variant = nsAstStruct(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Structure(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_ASSERTION: {
        AstExpression *variant = getAstExpression_Assertion(node);
        AstExpression *new_variant = nsAstExpression(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Assertion(CPI(node), new_variant);
        }
        break;
    }
    case AST_EXPRESSION_TYPE_ERROR: {
        AstExpression *variant = getAstExpression_Error(node);
        AstExpression *new_variant = nsAstExpression(variant, context);
        if (new_variant != variant) {
            PROTECT(new_variant);
            result = newAstExpression_Error(CPI(node), new_variant);
        }
        break;
    }
    default:
        cant_happen("unrecognized AstExpression type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(nsAstExpression);
    return result;
}

static AstNameSpaceArray *nsAstNameSpaceArray(AstNameSpaceArray *node,
                                              VisitorContext context) {
    ENTER(nsAstNameSpaceArray);
    if (node == NULL) {
        LEAVE(nsAstNameSpaceArray);
        return NULL;
    }
    bool changed = false;
    AstNameSpaceArray *result = newAstNameSpaceArray();
    int save = PROTECT(result);
    for (Index i = 0; i < node->size; i++) {
        pushAstNameSpaceArray(result, NULL);
    }
    // for (Index i = node->size; i > 0; i--) {
    for (Index i = 0; i < node->size; i++) {
        struct AstNameSpaceImpl *element = peeknAstNameSpaceArray(node, i);
        struct AstNameSpaceImpl *new_element =
            nsAstNameSpaceImpl(element, i, context);
        PROTECT(new_element);
        changed = changed || (new_element != element);
        pokeAstNameSpaceArray(result, i, new_element);
    }
    if (changed) {
        UNPROTECT(save);
        LEAVE(nsAstNameSpaceArray);
        return result;
    }
    UNPROTECT(save);
    LEAVE(nsAstNameSpaceArray);
    return node;
}

static HashSymbol *nsSymbol(HashSymbol *symbol, VisitorContext context) {
    HashSymbol *new = NULL;
    if (getSymbolMap(context.replacements, symbol, &new)) {
        return new;
    }
    return symbol;
}