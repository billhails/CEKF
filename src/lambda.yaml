#
# CEKF - VM supporting amb
# Copyright (C) 2022-2024  Bill Hails
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

config:
    name: lambda
    parserInfo: true
    limited_includes:
    - bigint.h
    - tc.h
    - tc_debug.h

description: Plain lambda structures generated by lambda conversion.

structs:
    LamLam:
        args: LamVarList
        exp: LamExp

    LamVarList:
        var: HashSymbol
        next: LamVarList

    LamPrimApp:
        type: LamPrimOp
        exp1: LamExp
        exp2: LamExp

    LamUnaryApp:
        type: LamUnaryOp
        exp: LamExp

    LamSequence:
        exp: LamExp
        next: LamSequence

    LamList:
        exp: LamExp
        next: LamList

    LamApply:
        function: LamExp
        args: LamList

    LamLookup:
        nsid: int
        nsSymbol: HashSymbol
        exp: LamExp

    LamLookupSymbol:
        nsid: int
        nsSymbol: HashSymbol
        symbol: HashSymbol

    LamConstant:
        name: HashSymbol # the name of the constructor
        tag: int         # the tag of the constructor

    LamConstruct:
        name: HashSymbol # the name of the constructor
        tag: int         # the tag of the constructor
        args: LamList    # the remaining arguments to make-vec

    LamDeconstruct:
        name: HashSymbol # name of the constructor being deconstructed
        nsid: int        # namespace of the constructor being deconstructed
        vec: int         # offset of the field in the vector
        exp: LamExp      # expression being deconstructed

    LamTupleIndex:
        vec: int         # offset of the field in the untagged tuple vector
        size: int        # size of the tuple
        exp: LamExp      # expression being accessed

    LamMakeVec:
        nargs: int
        args: LamList

    LamIff:
        condition: LamExp
        consequent: LamExp
        alternative: LamExp

    LamCond:
        value: LamExp
        cases: LamCondCases

    LamIntCondCases:
        constant: MaybeBigInt
        body: LamExp
        next: LamIntCondCases

    LamCharCondCases:
        constant: char
        body: LamExp
        next: LamCharCondCases

    LamMatch:
        index: LamExp
        cases: LamMatchList

    LamMatchList:
        matches: LamIntList
        body: LamExp
        next: LamMatchList

    LamIntList:
        item: int
        name: HashSymbol
        nsid: int
        next: LamIntList

    LamLet:
        var: HashSymbol
        value: LamExp
        body: LamExp

    LamLetRec:
        nbindings: int
        bindings: LamLetRecBindings
        body: LamExp

    LamLetRecBindings:
        var: HashSymbol
        val: LamExp
        next: LamLetRecBindings

    LamContext:
        frame: LamInfoTable
        aliases: LamAliasTable
        parent: LamContext

    LamAnd:
        left: LamExp
        right: LamExp

    LamOr:
        left: LamExp
        right: LamExp

    LamAmb:
        left: LamExp
        right: LamExp

    LamPrint:
        exp: LamExp
        printer: LamExp=NULL

    # the following LamTypeDef* structs prepend each letrec.
    # Any typedefs in the AST are hoisted into this section.
    LamTypeDefs:
        typeDefs: LamTypeDefList
        body: LamExp

    LamTypeDefList:
        typeDef: LamTypeDef
        next: LamTypeDefList

    LamTypeDef:
        type: LamType # re-use
        constructors: LamTypeConstructorList

    LamTypeConstructorList:
        constructor: LamTypeConstructor
        next: LamTypeConstructorList

    # the following LamType* structs hold type information
    # used by lambda conversion and the TPMC
    LamType:
        name: HashSymbol
        args: LamTypeArgs

    LamTypeTags:
        tag: HashSymbol
        next: LamTypeTags

    LamTypeArgs:
        name: HashSymbol
        next: LamTypeArgs

    LamTypeConstructor:
        name: HashSymbol
        type: LamType
        args: LamTypeConstructorArgs
    
    LamTypeConstructorArgs:
        arg: LamTypeConstructorType
        next: LamTypeConstructorArgs
    
    LamTypeFunction:
        name: LamLookupOrSymbol
        args: LamTypeConstructorArgs

    LamTypeConstructorInfo:
        name: HashSymbol
        nsid: int
        type: LamTypeConstructor
        tags: LamTypeTags
        needsVec: bool # does this need to be a vector?
        arity: int # number of arguments to this constructor
        size: int # number of alternatives
        index: int # index into list of alternatives

enums:
    LamPrimOp:
        - ADD
        - SUB
        - MUL
        - DIV
        - MOD
        - POW
        - EQ
        - NE
        - GT
        - LT
        - GE
        - LE
        - XOR
        - CMP
        - VEC

    LamUnaryOp:
        - NEG
        - NOT
        - PUTC
        - PUTN
        - PUTV

unions:
    LamExp:
        namespaces: LamNamespaceArray
        lam: LamLam
        var: HashSymbol
        stdint: int
        biginteger: MaybeBigInt
        prim: LamPrimApp
        unary: LamUnaryApp
        list: LamSequence
        makeVec: LamMakeVec
        construct: LamConstruct
        deconstruct: LamDeconstruct
        tuple_index: LamTupleIndex
        tuple: LamList
        make_tuple: LamList
        tag: LamExp
        constant: LamConstant
        apply: LamApply
        iff: LamIff
        callcc: LamExp
        letrec: LamLetRec
        typedefs: LamTypeDefs
        let: LamLet
        match: LamMatch
        cond: LamCond
        and: LamAnd
        or: LamOr
        amb: LamAmb
        print: LamPrint
        character: char
        back: void_ptr
        error: void_ptr
        cond_default: void_ptr
        env: void_ptr
        lookup: LamLookup
        constructor: LamTypeConstructorInfo

    LamLookupOrSymbol:
        symbol: HashSymbol
        lookup: LamLookupSymbol

    LamCondCases:
        integers: LamIntCondCases
        characters: LamCharCondCases

    LamTypeConstructorType:
        integer: void_ptr
        character: void_ptr
        var: HashSymbol
        function: LamTypeFunction
        tuple: LamTypeConstructorArgs

    LamInfo:
        typeConstructorInfo: LamTypeConstructorInfo
        namespaceInfo: LamContext
        nsid: int

hashes:
    LamInfoTable:
        entries: LamInfo

    LamAliasTable:
        entries: LamTypeConstructorType

    LamExpTable:
        entries: LamExp
    
arrays:
    LamNamespaceArray:
        dimension: 1
        entries: LamExp

primitives: !include primitives.yaml

external:
    TcType:
        cname: "struct TcType *"
        printFn: printTcType
        markFn: markTcType
        valued: true
