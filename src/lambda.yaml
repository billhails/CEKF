#
# CEKF - VM supporting amb
# Copyright (C) 2022-2023  Bill Hails
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

config:
    name: lambda
    limited_includes:
    - bigint.h

description: Plain lambda structures generated by lambda conversion.

structs:
    LamLam:
        nargs: int
        args: LamVarList
        exp: LamExp

    LamVarList:
        var: HashSymbol
        next: LamVarList

    LamPrimApp:
        type: LamPrimOp
        exp1: LamExp
        exp2: LamExp

    LamUnaryApp:
        type: LamUnaryOp
        exp: LamExp

    LamSequence:
        exp: LamExp
        next: LamSequence

    LamList:
        exp: LamExp
        next: LamList

    LamApply:
        function: LamExp
        nargs: int
        args: LamList

    LamConstant:
        name: HashSymbol # the name of the constructor
        tag: int         # the tag of the constructor

    LamConstruct:
        name: HashSymbol # the name of the constructor
        tag: int         # the tag of the constructor
        args: LamList    # the remaining arguments to make-vec

    LamDeconstruct:
        name: HashSymbol # name of the constructor being deconstructed
        vec: int         # offset of the field in the vector
        exp: LamExp      # expression being deconstructed

    LamMakeVec:
        nargs: int
        args: LamList

    LamIff:
        condition: LamExp
        consequent: LamExp
        alternative: LamExp

    LamCond:
        value: LamExp
        cases: LamCondCases

    LamIntCondCases:
        constant: BigInt
        body: LamExp
        next: LamIntCondCases

    LamCharCondCases:
        constant: character
        body: LamExp
        next: LamCharCondCases

    LamMatch:
        index: LamExp
        cases: LamMatchList

    LamMatchList:
        matches: LamIntList
        body: LamExp
        next: LamMatchList

    LamIntList:
        item: int
        name: HashSymbol
        next: LamIntList

    LamLet:
        var: HashSymbol
        value: LamExp
        body: LamExp

    LamLetRec:
        nbindings: int
        bindings: LamLetRecBindings
        body: LamExp

    LamLetRecBindings:
        var: HashSymbol
        val: LamExp
        next: LamLetRecBindings

    LamContext:
        frame: HashTable
        parent: LamContext

    LamAnd:
        left: LamExp
        right: LamExp

    LamOr:
        left: LamExp
        right: LamExp

    LamAmb:
        left: LamExp
        right: LamExp

    # the following LamTypeDef* structs prepend each letrec.
    # Any typedefs in the AST are hoisted into this section.
    LamTypeDefs:
        typeDefs: LamTypeDefList
        body: LamExp

    LamTypeDefList:
        typeDef: LamTypeDef
        next: LamTypeDefList

    LamTypeDef:
        type: LamType # re-use
        constructors: LamTypeConstructorList

    LamTypeConstructorList:
        constructor: LamTypeConstructor # re-use
        next: LamTypeConstructorList

    # the following LamType* structs hold type information
    # used by lambda conversion and the TPMC
    LamType:
        name: HashSymbol
        args: LamTypeArgs

    LamTypeArgs:
        name: HashSymbol
        next: LamTypeArgs

    LamTypeConstructor:
        name: HashSymbol
        type: LamType
        args: LamTypeConstructorArgs
    
    LamTypeConstructorArgs:
        arg: LamTypeConstructorType
        next: LamTypeConstructorArgs

    LamTypeFunction:
        name: HashSymbol
        args: LamTypeConstructorArgs

    LamTypeConstructorInfo:
        type: LamTypeConstructor
        vec: bool # does this need to be a vector?
        arity: int # number of arguments to this constructor
        size: int # number of alternatives
        index: int # index into list of alternatives


enums:
    LamPrimOp:
        - ADD
        - SUB
        - MUL
        - DIV
        - MOD
        - POW
        - EQ
        - NE
        - GT
        - LT
        - GE
        - LE
        - VEC
        - XOR

    LamUnaryOp:
        - NEG
        - NOT
        - PRINT

unions:
    LamExp:
        lam: LamLam
        var: HashSymbol
        stdint: int
        biginteger: BigInt
        prim: LamPrimApp
        unary: LamUnaryApp
        list: LamSequence
        makeVec: LamMakeVec
        construct: LamConstruct
        deconstruct: LamDeconstruct
        constant: LamConstant
        apply: LamApply
        iff: LamIff
        callcc: LamExp
        letrec: LamLetRec
        typedefs: LamTypeDefs
        let: LamLet
        match: LamMatch
        cond: LamCond
        and: LamAnd
        or: LamOr
        amb: LamAmb
        character: character
        back: void_ptr
        error: void_ptr
        cond_default: void_ptr

    LamCondCases:
        integers: LamIntCondCases
        characters: LamCharCondCases

    LamTypeConstructorType:
        integer: void_ptr
        character: void_ptr
        var: HashSymbol
        function: LamTypeFunction

primitives:
    HashSymbol:
        cname: "HashSymbol *"
        printFn: "printLambdaSymbol"
        markFn: "markHashSymbol"
        valued: true
    HashTable:
        cname: "HashTable *"
        printFn: "printHashTable"
        markFn: "markHashTable"
        valued: true
    BigInt:
        cname: "BigInt *"
        printFn: "printBigInt"
        markFn: "markBigInt"
        valued: true
    void_ptr:
        cname: "void *"
        printf: "%p"
        valued: false
    int:
        cname: "int"
        printf: "%d"
        valued: true
    bool:
        cname: "bool"
        printf: "%d"
        valued: true
    character:
        cname: "char"
        printf: "%c"
        valued: true
