//
// CEKF - VM supporting amb
// Copyright (C) 2022-2023  Bill Hails
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

// these are typedefs and functions that the compiler requires to be
// pre-defined, for example the Infix `@` is mapped to `cons`, `@@` to `append`,
// prefix `<` to `car` etc.
// `puts` is required for the print system, and the type `cmp` for the `<=>` operator.
namespace

__builtins__


operator "_then_" right 2 amb;
operator "_==_" left 5 EQUALTO;
operator "_!=_" left 5 NOTEQUALTO;
operator "_â‰ _" left 5 NOTEQUALTO;
operator "_>_" left 5 GREATERTHAN;
operator "_<_" left 5 LESSTHAN;
operator "_<=_" left 5 LESSTHANOREQUALTO;
operator "_>=_" left 5 GREATERTHANOREQUALTO;
operator "_<=>_" none 5 COMPARISON;
operator "_+_" left 10 ADDITION;
operator "_-_" left 10 SUBTRACTION;
operator "-_" left 11 NEGATION;
lazy fn NUMERICIDENTITY(x) { x + 0 }
operator "+_" left 11 NUMERICIDENTITY;
operator "_*_" left 11 MULTIPLICATION;
operator "_/_" left 11 DIVISION;
operator "_%_" left 11 MODULUS;
operator "_**_" left 12 EXPONENTIAL;
operator "here_" 13 callcc;

typedef cmp { lt | eq | gt }
typedef bool { false | true }
typedef list(#t) { nil | cons(#t, list(#t)) }
alias string = list(char);
typedef maybe(#t) { nothing | some(#t) }
typedef try(#f, #s) { failure(#f) | success(#s) }
typedef basic_type { basic_null | basic_number(number) | basic_string(string) | basic_char(char) }
typedef io_mode { io_read | io_write | io_append }
typedef ftype_type {
    ftype_socket |
    ftype_symlink |
    ftype_regular |
    ftype_block |
    ftype_dir |
    ftype_char |
    ftype_fifo
}

typedef unicode_general_category_type {
    GC_Ll | GC_Lm | GC_Lo | GC_Lt | GC_Lu |
    GC_Mc | GC_Me | GC_Mn |
    GC_Nd | GC_Nl | GC_No |
    GC_Pc | GC_Pd | GC_Pe | GC_Pf | GC_Pi | GC_Po | GC_Ps |
    GC_Sc | GC_Sk | GC_Sm | GC_So |
    GC_Zl | GC_Zp | GC_Zs |
    GC_Cc | GC_Cf | GC_Co | GC_Cs | GC_Cn 
}

// it would be nice if we could do something like this:
// syntax if (test) {consequent} else {alternative} =
//     { fn {(true) { consequent } (false) { alternative }}(test) }

fn NOT {
    (true) { false }
    (false) { true }
}
operator "not_" 4 NOT;

// lazy functions thunk their arguments, which gets us short-circuit
// evaluation for boolean operators.
lazy fn AND(a, b) { if (a) { b } else { false } }
operator "_and_" left 3 AND;

lazy fn OR(a, b) { if (a) { true } else { b } }
operator "_or_" left 3 OR;

fn XOR {
    (true, true) { false }
    (true, false) { true }
    (false, true) { true }
    (false, false) { false }
}
operator "_xor_" left 3 XOR;

lazy fn NAND(a, b) { not (a and b) }
operator "_nand_" left 3 NAND;

lazy fn NOR(a, b) { not (a or b) }
operator "_nor_" left 3 NOR;

lazy fn XNOR(a, b) { not (a xor b) }
operator "_xnor_" left 3 XNOR;

operator "_@_" right 10 cons;

fn __assert__(line, file, condition) {
    if (condition) {
        true
    } else {
        puts("assertion failed in ");
        puts(file);
        puts(" line ");
        putn(line);
        putc('\n');
        assertion();
    }
}

// tail-recursive version
fn factorial (n) {
    let
        fn h {
            (0, a) { a }
            (n, a) { h(n - 1, n * a) }
        }
    in
        h(n, 1)
}

operator "_!" 13 factorial;

fn gcd {
    (0, b) { b }
    (a, 0) { a }
    (a, b) {
        if (a > b) {
            gcd(a - b, b)
        } else {
            gcd(a, b - a)
        }
    }
}

fn __error__(line, file, message) {
    puts("error: ");
    puts(message);
    puts(" at ");
    puts(file);
    puts(" line ");
    putn(line);
    putc('\n');
    exit(1);
}

operator "_of_" right 13 fn (f, g, x) { f(g(x)) };

operator "&_" 14 THUNK;
lazy fn THUNK(x) { fn () {x} }

operator "*_" 14 FORCE;
fn FORCE(thunk) { thunk() }

fn append {
    ([], b) { b }
    (h @ t, b) { h @ append(t, b) }
}

operator "_@@_" right 9 append;

unsafe fn car {
    (h @ _) { h }
}
operator "<_" 6 car;

unsafe fn cdr {
    (_ @ t) { t }
}
operator ">_" 6 cdr;

fn identity(x) { x };

print list(helper, l) {
    let
        fn h1 {
            ([]) { true }
            (h @ t) {
                helper(h);
                h2(t)
            }
        }
        fn h2 {
            ([]) { true }
            (h @ t) {
                puts(", ");
                helper(h);
                h2(t)
            }
        }
    in
        puts("[");
        h1(l);
        puts("]");
        l
}

print function(f) {
    puts("<function>");
    f
}

print opaque(f) {
    puts("<opaque>");
    f
}

print int(n) {
    putn(n);
    n
}

print character(c) {
    putc('\'');
    putc(c);
    putc('\'');
    c
}

fn __print__(v) {
    putv(v);
    v
}

print string(s) {
    putc('"');
    puts(s);
    putc('"');
    s
}

print tuple_0(t) {
   puts("#()");
   t
}

print tuple_1(pa, t=#(a)) {
   puts("#(");
   pa(a);
   puts(")");
   t
}

print tuple_2(pa, pb, t=#(a, b)) {
   puts("#(");
   pa(a);
   puts(", ");
   pb(b);
   puts(")");
   t
}

print tuple_3(pa, pb, pc, t=#(a, b, c)) {
   puts("#(");
   pa(a);
   puts(", ");
   pb(b);
   puts(", ");
   pc(c);
   puts(")");
   t
}

print tuple_4(pa, pb, pc, pd, t=#(a, b, c, d)) {
   puts("#(");
   pa(a);
   puts(", ");
   pb(b);
   puts(", ");
   pc(c);
   puts(", ");
   pd(d);
   puts(")");
   t
}
