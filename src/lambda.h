#ifndef cekf_lambda_h
#define cekf_lambda_h
/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 *
 * generated from src/lambda.yaml by makeAST.py
 */

#include "hash.h"
#include "memory.h"
#include "common.h"
#include "bigint.h"

typedef enum LamPrimOp {
    LAMPRIMOP_TYPE_ADD,
    LAMPRIMOP_TYPE_SUB,
    LAMPRIMOP_TYPE_MUL,
    LAMPRIMOP_TYPE_DIV,
    LAMPRIMOP_TYPE_MOD,
    LAMPRIMOP_TYPE_POW,
    LAMPRIMOP_TYPE_EQ,
    LAMPRIMOP_TYPE_NE,
    LAMPRIMOP_TYPE_GT,
    LAMPRIMOP_TYPE_LT,
    LAMPRIMOP_TYPE_GE,
    LAMPRIMOP_TYPE_LE,
    LAMPRIMOP_TYPE_VEC,
    LAMPRIMOP_TYPE_XOR,
} LamPrimOp;

typedef enum LamUnaryOp {
    LAMUNARYOP_TYPE_NEG,
    LAMUNARYOP_TYPE_NOT,
    LAMUNARYOP_TYPE_PRINT,
} LamUnaryOp;

typedef enum LamExpType {
    LAMEXP_TYPE_LAM,
    LAMEXP_TYPE_VAR,
    LAMEXP_TYPE_STDINT,
    LAMEXP_TYPE_BIGINTEGER,
    LAMEXP_TYPE_PRIM,
    LAMEXP_TYPE_UNARY,
    LAMEXP_TYPE_LIST,
    LAMEXP_TYPE_MAKEVEC,
    LAMEXP_TYPE_CONSTRUCT,
    LAMEXP_TYPE_DECONSTRUCT,
    LAMEXP_TYPE_CONSTANT,
    LAMEXP_TYPE_APPLY,
    LAMEXP_TYPE_IFF,
    LAMEXP_TYPE_CALLCC,
    LAMEXP_TYPE_LETREC,
    LAMEXP_TYPE_TYPEDEFS,
    LAMEXP_TYPE_LET,
    LAMEXP_TYPE_MATCH,
    LAMEXP_TYPE_COND,
    LAMEXP_TYPE_AND,
    LAMEXP_TYPE_OR,
    LAMEXP_TYPE_AMB,
    LAMEXP_TYPE_CHARACTER,
    LAMEXP_TYPE_BACK,
    LAMEXP_TYPE_ERROR,
    LAMEXP_TYPE_COND_DEFAULT,
} LamExpType;

typedef enum LamCondCasesType {
    LAMCONDCASES_TYPE_INTEGERS,
    LAMCONDCASES_TYPE_CHARACTERS,
} LamCondCasesType;

typedef enum LamTypeConstructorTypeType {
    LAMTYPECONSTRUCTORTYPE_TYPE_INTEGER,
    LAMTYPECONSTRUCTORTYPE_TYPE_CHARACTER,
    LAMTYPECONSTRUCTORTYPE_TYPE_VAR,
    LAMTYPECONSTRUCTORTYPE_TYPE_FUNCTION,
} LamTypeConstructorTypeType;



typedef union LamExpVal {
    struct LamLam * lam;
    HashSymbol * var;
    int stdint;
    BigInt * biginteger;
    struct LamPrimApp * prim;
    struct LamUnaryApp * unary;
    struct LamSequence * list;
    struct LamMakeVec * makeVec;
    struct LamConstruct * construct;
    struct LamDeconstruct * deconstruct;
    struct LamConstant * constant;
    struct LamApply * apply;
    struct LamIff * iff;
    struct LamExp * callcc;
    struct LamLetRec * letrec;
    struct LamTypeDefs * typedefs;
    struct LamLet * let;
    struct LamMatch * match;
    struct LamCond * cond;
    struct LamAnd * and;
    struct LamOr * or;
    struct LamAmb * amb;
    char character;
    void * back;
    void * error;
    void * cond_default;
} LamExpVal;

typedef union LamCondCasesVal {
    struct LamIntCondCases * integers;
    struct LamCharCondCases * characters;
} LamCondCasesVal;

typedef union LamTypeConstructorTypeVal {
    void * integer;
    void * character;
    HashSymbol * var;
    struct LamTypeFunction * function;
} LamTypeConstructorTypeVal;



typedef struct LamLam {
    Header header;
    int nargs;
    struct LamVarList * args;
    struct LamExp * exp;
} LamLam;

typedef struct LamVarList {
    Header header;
    HashSymbol * var;
    struct LamVarList * next;
} LamVarList;

typedef struct LamPrimApp {
    Header header;
    enum LamPrimOp  type;
    struct LamExp * exp1;
    struct LamExp * exp2;
} LamPrimApp;

typedef struct LamUnaryApp {
    Header header;
    enum LamUnaryOp  type;
    struct LamExp * exp;
} LamUnaryApp;

typedef struct LamSequence {
    Header header;
    struct LamExp * exp;
    struct LamSequence * next;
} LamSequence;

typedef struct LamList {
    Header header;
    struct LamExp * exp;
    struct LamList * next;
} LamList;

typedef struct LamApply {
    Header header;
    struct LamExp * function;
    int nargs;
    struct LamList * args;
} LamApply;

typedef struct LamConstant {
    Header header;
    HashSymbol * name;
    int tag;
} LamConstant;

typedef struct LamConstruct {
    Header header;
    HashSymbol * name;
    int tag;
    struct LamList * args;
} LamConstruct;

typedef struct LamDeconstruct {
    Header header;
    HashSymbol * name;
    int vec;
    struct LamExp * exp;
} LamDeconstruct;

typedef struct LamMakeVec {
    Header header;
    int nargs;
    struct LamList * args;
} LamMakeVec;

typedef struct LamIff {
    Header header;
    struct LamExp * condition;
    struct LamExp * consequent;
    struct LamExp * alternative;
} LamIff;

typedef struct LamCond {
    Header header;
    struct LamExp * value;
    struct LamCondCases * cases;
} LamCond;

typedef struct LamIntCondCases {
    Header header;
    BigInt * constant;
    struct LamExp * body;
    struct LamIntCondCases * next;
} LamIntCondCases;

typedef struct LamCharCondCases {
    Header header;
    char constant;
    struct LamExp * body;
    struct LamCharCondCases * next;
} LamCharCondCases;

typedef struct LamMatch {
    Header header;
    struct LamExp * index;
    struct LamMatchList * cases;
} LamMatch;

typedef struct LamMatchList {
    Header header;
    struct LamIntList * matches;
    struct LamExp * body;
    struct LamMatchList * next;
} LamMatchList;

typedef struct LamIntList {
    Header header;
    int item;
    struct LamIntList * next;
} LamIntList;

typedef struct LamLet {
    Header header;
    HashSymbol * var;
    struct LamExp * value;
    struct LamExp * body;
} LamLet;

typedef struct LamLetRec {
    Header header;
    int nbindings;
    struct LamLetRecBindings * bindings;
    struct LamExp * body;
} LamLetRec;

typedef struct LamLetRecBindings {
    Header header;
    HashSymbol * var;
    struct LamExp * val;
    struct LamLetRecBindings * next;
} LamLetRecBindings;

typedef struct LamContext {
    Header header;
    HashTable * frame;
    struct LamContext * parent;
} LamContext;

typedef struct LamAnd {
    Header header;
    struct LamExp * left;
    struct LamExp * right;
} LamAnd;

typedef struct LamOr {
    Header header;
    struct LamExp * left;
    struct LamExp * right;
} LamOr;

typedef struct LamAmb {
    Header header;
    struct LamExp * left;
    struct LamExp * right;
} LamAmb;

typedef struct LamTypeDefs {
    Header header;
    struct LamTypeDefList * typeDefs;
    struct LamExp * body;
} LamTypeDefs;

typedef struct LamTypeDefList {
    Header header;
    struct LamTypeDef * typeDef;
    struct LamTypeDefList * next;
} LamTypeDefList;

typedef struct LamTypeDef {
    Header header;
    struct LamType * type;
    struct LamTypeConstructorList * constructors;
} LamTypeDef;

typedef struct LamTypeConstructorList {
    Header header;
    struct LamTypeConstructor * constructor;
    struct LamTypeConstructorList * next;
} LamTypeConstructorList;

typedef struct LamType {
    Header header;
    HashSymbol * name;
    struct LamTypeArgs * args;
} LamType;

typedef struct LamTypeArgs {
    Header header;
    HashSymbol * name;
    struct LamTypeArgs * next;
} LamTypeArgs;

typedef struct LamTypeConstructor {
    Header header;
    HashSymbol * name;
    struct LamType * type;
    struct LamTypeConstructorArgs * args;
} LamTypeConstructor;

typedef struct LamTypeConstructorArgs {
    Header header;
    struct LamTypeConstructorType * arg;
    struct LamTypeConstructorArgs * next;
} LamTypeConstructorArgs;

typedef struct LamTypeFunction {
    Header header;
    HashSymbol * name;
    struct LamTypeConstructorArgs * args;
} LamTypeFunction;

typedef struct LamTypeConstructorInfo {
    Header header;
    struct LamTypeConstructor * type;
    bool vec;
    int arity;
    int size;
    int index;
} LamTypeConstructorInfo;

typedef struct LamExp {
    Header header;
    enum LamExpType  type;
    union LamExpVal  val;
} LamExp;

typedef struct LamCondCases {
    Header header;
    enum LamCondCasesType  type;
    union LamCondCasesVal  val;
} LamCondCases;

typedef struct LamTypeConstructorType {
    Header header;
    enum LamTypeConstructorTypeType  type;
    union LamTypeConstructorTypeVal  val;
} LamTypeConstructorType;



struct LamLam * newLamLam(int nargs, struct LamVarList * args, struct LamExp * exp);
struct LamVarList * newLamVarList(HashSymbol * var, struct LamVarList * next);
struct LamPrimApp * newLamPrimApp(enum LamPrimOp  type, struct LamExp * exp1, struct LamExp * exp2);
struct LamUnaryApp * newLamUnaryApp(enum LamUnaryOp  type, struct LamExp * exp);
struct LamSequence * newLamSequence(struct LamExp * exp, struct LamSequence * next);
struct LamList * newLamList(struct LamExp * exp, struct LamList * next);
struct LamApply * newLamApply(struct LamExp * function, int nargs, struct LamList * args);
struct LamConstant * newLamConstant(HashSymbol * name, int tag);
struct LamConstruct * newLamConstruct(HashSymbol * name, int tag, struct LamList * args);
struct LamDeconstruct * newLamDeconstruct(HashSymbol * name, int vec, struct LamExp * exp);
struct LamMakeVec * newLamMakeVec(int nargs, struct LamList * args);
struct LamIff * newLamIff(struct LamExp * condition, struct LamExp * consequent, struct LamExp * alternative);
struct LamCond * newLamCond(struct LamExp * value, struct LamCondCases * cases);
struct LamIntCondCases * newLamIntCondCases(BigInt * constant, struct LamExp * body, struct LamIntCondCases * next);
struct LamCharCondCases * newLamCharCondCases(char constant, struct LamExp * body, struct LamCharCondCases * next);
struct LamMatch * newLamMatch(struct LamExp * index, struct LamMatchList * cases);
struct LamMatchList * newLamMatchList(struct LamIntList * matches, struct LamExp * body, struct LamMatchList * next);
struct LamIntList * newLamIntList(int item, struct LamIntList * next);
struct LamLet * newLamLet(HashSymbol * var, struct LamExp * value, struct LamExp * body);
struct LamLetRec * newLamLetRec(int nbindings, struct LamLetRecBindings * bindings, struct LamExp * body);
struct LamLetRecBindings * newLamLetRecBindings(HashSymbol * var, struct LamExp * val, struct LamLetRecBindings * next);
struct LamContext * newLamContext(HashTable * frame, struct LamContext * parent);
struct LamAnd * newLamAnd(struct LamExp * left, struct LamExp * right);
struct LamOr * newLamOr(struct LamExp * left, struct LamExp * right);
struct LamAmb * newLamAmb(struct LamExp * left, struct LamExp * right);
struct LamTypeDefs * newLamTypeDefs(struct LamTypeDefList * typeDefs, struct LamExp * body);
struct LamTypeDefList * newLamTypeDefList(struct LamTypeDef * typeDef, struct LamTypeDefList * next);
struct LamTypeDef * newLamTypeDef(struct LamType * type, struct LamTypeConstructorList * constructors);
struct LamTypeConstructorList * newLamTypeConstructorList(struct LamTypeConstructor * constructor, struct LamTypeConstructorList * next);
struct LamType * newLamType(HashSymbol * name, struct LamTypeArgs * args);
struct LamTypeArgs * newLamTypeArgs(HashSymbol * name, struct LamTypeArgs * next);
struct LamTypeConstructor * newLamTypeConstructor(HashSymbol * name, struct LamType * type, struct LamTypeConstructorArgs * args);
struct LamTypeConstructorArgs * newLamTypeConstructorArgs(struct LamTypeConstructorType * arg, struct LamTypeConstructorArgs * next);
struct LamTypeFunction * newLamTypeFunction(HashSymbol * name, struct LamTypeConstructorArgs * args);
struct LamTypeConstructorInfo * newLamTypeConstructorInfo(struct LamTypeConstructor * type, bool vec, int arity, int size, int index);
struct LamExp * newLamExp(enum LamExpType  type, union LamExpVal  val);
struct LamCondCases * newLamCondCases(enum LamCondCasesType  type, union LamCondCasesVal  val);
struct LamTypeConstructorType * newLamTypeConstructorType(enum LamTypeConstructorTypeType  type, union LamTypeConstructorTypeVal  val);

void markLamLam(struct LamLam * x);
void markLamVarList(struct LamVarList * x);
void markLamPrimApp(struct LamPrimApp * x);
void markLamUnaryApp(struct LamUnaryApp * x);
void markLamSequence(struct LamSequence * x);
void markLamList(struct LamList * x);
void markLamApply(struct LamApply * x);
void markLamConstant(struct LamConstant * x);
void markLamConstruct(struct LamConstruct * x);
void markLamDeconstruct(struct LamDeconstruct * x);
void markLamMakeVec(struct LamMakeVec * x);
void markLamIff(struct LamIff * x);
void markLamCond(struct LamCond * x);
void markLamIntCondCases(struct LamIntCondCases * x);
void markLamCharCondCases(struct LamCharCondCases * x);
void markLamMatch(struct LamMatch * x);
void markLamMatchList(struct LamMatchList * x);
void markLamIntList(struct LamIntList * x);
void markLamLet(struct LamLet * x);
void markLamLetRec(struct LamLetRec * x);
void markLamLetRecBindings(struct LamLetRecBindings * x);
void markLamContext(struct LamContext * x);
void markLamAnd(struct LamAnd * x);
void markLamOr(struct LamOr * x);
void markLamAmb(struct LamAmb * x);
void markLamTypeDefs(struct LamTypeDefs * x);
void markLamTypeDefList(struct LamTypeDefList * x);
void markLamTypeDef(struct LamTypeDef * x);
void markLamTypeConstructorList(struct LamTypeConstructorList * x);
void markLamType(struct LamType * x);
void markLamTypeArgs(struct LamTypeArgs * x);
void markLamTypeConstructor(struct LamTypeConstructor * x);
void markLamTypeConstructorArgs(struct LamTypeConstructorArgs * x);
void markLamTypeFunction(struct LamTypeFunction * x);
void markLamTypeConstructorInfo(struct LamTypeConstructorInfo * x);
void markLamExp(struct LamExp * x);
void markLamCondCases(struct LamCondCases * x);
void markLamTypeConstructorType(struct LamTypeConstructorType * x);

void freeLamLam(struct LamLam * x);
void freeLamVarList(struct LamVarList * x);
void freeLamPrimApp(struct LamPrimApp * x);
void freeLamUnaryApp(struct LamUnaryApp * x);
void freeLamSequence(struct LamSequence * x);
void freeLamList(struct LamList * x);
void freeLamApply(struct LamApply * x);
void freeLamConstant(struct LamConstant * x);
void freeLamConstruct(struct LamConstruct * x);
void freeLamDeconstruct(struct LamDeconstruct * x);
void freeLamMakeVec(struct LamMakeVec * x);
void freeLamIff(struct LamIff * x);
void freeLamCond(struct LamCond * x);
void freeLamIntCondCases(struct LamIntCondCases * x);
void freeLamCharCondCases(struct LamCharCondCases * x);
void freeLamMatch(struct LamMatch * x);
void freeLamMatchList(struct LamMatchList * x);
void freeLamIntList(struct LamIntList * x);
void freeLamLet(struct LamLet * x);
void freeLamLetRec(struct LamLetRec * x);
void freeLamLetRecBindings(struct LamLetRecBindings * x);
void freeLamContext(struct LamContext * x);
void freeLamAnd(struct LamAnd * x);
void freeLamOr(struct LamOr * x);
void freeLamAmb(struct LamAmb * x);
void freeLamTypeDefs(struct LamTypeDefs * x);
void freeLamTypeDefList(struct LamTypeDefList * x);
void freeLamTypeDef(struct LamTypeDef * x);
void freeLamTypeConstructorList(struct LamTypeConstructorList * x);
void freeLamType(struct LamType * x);
void freeLamTypeArgs(struct LamTypeArgs * x);
void freeLamTypeConstructor(struct LamTypeConstructor * x);
void freeLamTypeConstructorArgs(struct LamTypeConstructorArgs * x);
void freeLamTypeFunction(struct LamTypeFunction * x);
void freeLamTypeConstructorInfo(struct LamTypeConstructorInfo * x);
void freeLamExp(struct LamExp * x);
void freeLamCondCases(struct LamCondCases * x);
void freeLamTypeConstructorType(struct LamTypeConstructorType * x);


#define LAMEXP_VAL_LAM(x) ((union LamExpVal ){.lam = (x)})
#define LAMEXP_VAL_VAR(x) ((union LamExpVal ){.var = (x)})
#define LAMEXP_VAL_STDINT(x) ((union LamExpVal ){.stdint = (x)})
#define LAMEXP_VAL_BIGINTEGER(x) ((union LamExpVal ){.biginteger = (x)})
#define LAMEXP_VAL_PRIM(x) ((union LamExpVal ){.prim = (x)})
#define LAMEXP_VAL_UNARY(x) ((union LamExpVal ){.unary = (x)})
#define LAMEXP_VAL_LIST(x) ((union LamExpVal ){.list = (x)})
#define LAMEXP_VAL_MAKEVEC(x) ((union LamExpVal ){.makeVec = (x)})
#define LAMEXP_VAL_CONSTRUCT(x) ((union LamExpVal ){.construct = (x)})
#define LAMEXP_VAL_DECONSTRUCT(x) ((union LamExpVal ){.deconstruct = (x)})
#define LAMEXP_VAL_CONSTANT(x) ((union LamExpVal ){.constant = (x)})
#define LAMEXP_VAL_APPLY(x) ((union LamExpVal ){.apply = (x)})
#define LAMEXP_VAL_IFF(x) ((union LamExpVal ){.iff = (x)})
#define LAMEXP_VAL_CALLCC(x) ((union LamExpVal ){.callcc = (x)})
#define LAMEXP_VAL_LETREC(x) ((union LamExpVal ){.letrec = (x)})
#define LAMEXP_VAL_TYPEDEFS(x) ((union LamExpVal ){.typedefs = (x)})
#define LAMEXP_VAL_LET(x) ((union LamExpVal ){.let = (x)})
#define LAMEXP_VAL_MATCH(x) ((union LamExpVal ){.match = (x)})
#define LAMEXP_VAL_COND(x) ((union LamExpVal ){.cond = (x)})
#define LAMEXP_VAL_AND(x) ((union LamExpVal ){.and = (x)})
#define LAMEXP_VAL_OR(x) ((union LamExpVal ){.or = (x)})
#define LAMEXP_VAL_AMB(x) ((union LamExpVal ){.amb = (x)})
#define LAMEXP_VAL_CHARACTER(x) ((union LamExpVal ){.character = (x)})
#define LAMEXP_VAL_BACK() ((union LamExpVal ){.back = (NULL)})
#define LAMEXP_VAL_ERROR() ((union LamExpVal ){.error = (NULL)})
#define LAMEXP_VAL_COND_DEFAULT() ((union LamExpVal ){.cond_default = (NULL)})
#define LAMCONDCASES_VAL_INTEGERS(x) ((union LamCondCasesVal ){.integers = (x)})
#define LAMCONDCASES_VAL_CHARACTERS(x) ((union LamCondCasesVal ){.characters = (x)})
#define LAMTYPECONSTRUCTORTYPE_VAL_INTEGER() ((union LamTypeConstructorTypeVal ){.integer = (NULL)})
#define LAMTYPECONSTRUCTORTYPE_VAL_CHARACTER() ((union LamTypeConstructorTypeVal ){.character = (NULL)})
#define LAMTYPECONSTRUCTORTYPE_VAL_VAR(x) ((union LamTypeConstructorTypeVal ){.var = (x)})
#define LAMTYPECONSTRUCTORTYPE_VAL_FUNCTION(x) ((union LamTypeConstructorTypeVal ){.function = (x)})


#endif
