#ifndef cekf_lambda_h
#define cekf_lambda_h
/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 *
 * generated from src/lambda.yaml by makeAST.py
 */

#include "hash.h"
#include "memory.h"
#include "common.h"
#include "bigint.h"

typedef enum LamPrimOp {
    LAMPRIMOP_TYPE_LAM_PRIM_ADD,
    LAMPRIMOP_TYPE_LAM_PRIM_SUB,
    LAMPRIMOP_TYPE_LAM_PRIM_MUL,
    LAMPRIMOP_TYPE_LAM_PRIM_DIV,
    LAMPRIMOP_TYPE_LAM_PRIM_MOD,
    LAMPRIMOP_TYPE_LAM_PRIM_POW,
    LAMPRIMOP_TYPE_LAM_PRIM_EQ,
    LAMPRIMOP_TYPE_LAM_PRIM_NE,
    LAMPRIMOP_TYPE_LAM_PRIM_GT,
    LAMPRIMOP_TYPE_LAM_PRIM_LT,
    LAMPRIMOP_TYPE_LAM_PRIM_GE,
    LAMPRIMOP_TYPE_LAM_PRIM_LE,
    LAMPRIMOP_TYPE_LAM_PRIM_VEC,
    LAMPRIMOP_TYPE_LAM_PRIM_XOR,
} LamPrimOp;

typedef enum LamUnaryOp {
    LAMUNARYOP_TYPE_LAM_UNARY_NEG,
    LAMUNARYOP_TYPE_LAM_UNARY_NOT,
    LAMUNARYOP_TYPE_LAM_UNARY_PRINT,
} LamUnaryOp;

typedef enum LamExpType {
    LAMEXP_TYPE_LAM,
    LAMEXP_TYPE_VAR,
    LAMEXP_TYPE_STDINT,
    LAMEXP_TYPE_BIGINTEGER,
    LAMEXP_TYPE_PRIM,
    LAMEXP_TYPE_UNARY,
    LAMEXP_TYPE_LIST,
    LAMEXP_TYPE_MAKEVEC,
    LAMEXP_TYPE_APPLY,
    LAMEXP_TYPE_IFF,
    LAMEXP_TYPE_CALLCC,
    LAMEXP_TYPE_LETREC,
    LAMEXP_TYPE_LET,
    LAMEXP_TYPE_MATCH,
    LAMEXP_TYPE_COND,
    LAMEXP_TYPE_AND,
    LAMEXP_TYPE_OR,
    LAMEXP_TYPE_AMB,
    LAMEXP_TYPE_CHARACTER,
    LAMEXP_TYPE_BACK,
    LAMEXP_TYPE_ERROR,
    LAMEXP_TYPE_COND_DEFAULT,
} LamExpType;

typedef enum LamCondCasesType {
    LAMCONDCASES_TYPE_INTEGERS,
    LAMCONDCASES_TYPE_CHARACTERS,
} LamCondCasesType;



typedef union LamExpVal {
    struct LamLam * lam;
    HashSymbol * var;
    int stdint;
    BigInt * biginteger;
    struct LamPrimApp * prim;
    struct LamUnaryApp * unary;
    struct LamSequence * list;
    struct LamMakeVec * makeVec;
    struct LamApply * apply;
    struct LamIff * iff;
    struct LamExp * callcc;
    struct LamLetRec * letrec;
    struct LamLet * let;
    struct LamMatch * match;
    struct LamCond * cond;
    struct LamAnd * and;
    struct LamOr * or;
    struct LamAmb * amb;
    char character;
    void * back;
    void * error;
    void * cond_default;
} LamExpVal;

typedef union LamCondCasesVal {
    struct LamIntCondCases * integers;
    struct LamCharCondCases * characters;
} LamCondCasesVal;



typedef struct LamLam {
    Header header;
    int nargs;
    struct LamVarList * args;
    struct LamExp * exp;
} LamLam;

typedef struct LamVarList {
    Header header;
    HashSymbol * var;
    struct LamVarList * next;
} LamVarList;

typedef struct LamPrimApp {
    Header header;
    enum LamPrimOp  type;
    struct LamExp * exp1;
    struct LamExp * exp2;
} LamPrimApp;

typedef struct LamUnaryApp {
    Header header;
    enum LamUnaryOp  type;
    struct LamExp * exp;
} LamUnaryApp;

typedef struct LamSequence {
    Header header;
    struct LamExp * exp;
    struct LamSequence * next;
} LamSequence;

typedef struct LamList {
    Header header;
    struct LamExp * exp;
    struct LamList * next;
} LamList;

typedef struct LamApply {
    Header header;
    struct LamExp * function;
    int nargs;
    struct LamList * args;
} LamApply;

typedef struct LamMakeVec {
    Header header;
    int nargs;
    struct LamList * args;
} LamMakeVec;

typedef struct LamIff {
    Header header;
    struct LamExp * condition;
    struct LamExp * consequent;
    struct LamExp * alternative;
} LamIff;

typedef struct LamCond {
    Header header;
    struct LamExp * value;
    struct LamCondCases * cases;
} LamCond;

typedef struct LamIntCondCases {
    Header header;
    BigInt * constant;
    struct LamExp * body;
    struct LamIntCondCases * next;
} LamIntCondCases;

typedef struct LamCharCondCases {
    Header header;
    char constant;
    struct LamExp * body;
    struct LamCharCondCases * next;
} LamCharCondCases;

typedef struct LamMatch {
    Header header;
    struct LamExp * index;
    struct LamMatchList * cases;
} LamMatch;

typedef struct LamMatchList {
    Header header;
    struct LamIntList * matches;
    struct LamExp * body;
    struct LamMatchList * next;
} LamMatchList;

typedef struct LamIntList {
    Header header;
    int item;
    struct LamIntList * next;
} LamIntList;

typedef struct LamLet {
    Header header;
    HashSymbol * var;
    struct LamExp * value;
    struct LamExp * body;
} LamLet;

typedef struct LamLetRec {
    Header header;
    int nbindings;
    struct LamLetRecBindings * bindings;
    struct LamExp * body;
} LamLetRec;

typedef struct LamLetRecBindings {
    Header header;
    HashSymbol * var;
    struct LamExp * val;
    struct LamLetRecBindings * next;
} LamLetRecBindings;

typedef struct LamContext {
    Header header;
    HashTable * frame;
    struct LamContext * parent;
} LamContext;

typedef struct LamAnd {
    Header header;
    struct LamExp * left;
    struct LamExp * right;
} LamAnd;

typedef struct LamOr {
    Header header;
    struct LamExp * left;
    struct LamExp * right;
} LamOr;

typedef struct LamAmb {
    Header header;
    struct LamExp * left;
    struct LamExp * right;
} LamAmb;

typedef struct LamTypeConstructorInfo {
    Header header;
    bool vec;
    int arity;
    int size;
    int index;
} LamTypeConstructorInfo;

typedef struct LamExp {
    Header header;
    enum LamExpType  type;
    union LamExpVal  val;
} LamExp;

typedef struct LamCondCases {
    Header header;
    enum LamCondCasesType  type;
    union LamCondCasesVal  val;
} LamCondCases;



struct LamLam * newLamLam(int nargs, struct LamVarList * args, struct LamExp * exp);
struct LamVarList * newLamVarList(HashSymbol * var, struct LamVarList * next);
struct LamPrimApp * newLamPrimApp(enum LamPrimOp  type, struct LamExp * exp1, struct LamExp * exp2);
struct LamUnaryApp * newLamUnaryApp(enum LamUnaryOp  type, struct LamExp * exp);
struct LamSequence * newLamSequence(struct LamExp * exp, struct LamSequence * next);
struct LamList * newLamList(struct LamExp * exp, struct LamList * next);
struct LamApply * newLamApply(struct LamExp * function, int nargs, struct LamList * args);
struct LamMakeVec * newLamMakeVec(int nargs, struct LamList * args);
struct LamIff * newLamIff(struct LamExp * condition, struct LamExp * consequent, struct LamExp * alternative);
struct LamCond * newLamCond(struct LamExp * value, struct LamCondCases * cases);
struct LamIntCondCases * newLamIntCondCases(BigInt * constant, struct LamExp * body, struct LamIntCondCases * next);
struct LamCharCondCases * newLamCharCondCases(char constant, struct LamExp * body, struct LamCharCondCases * next);
struct LamMatch * newLamMatch(struct LamExp * index, struct LamMatchList * cases);
struct LamMatchList * newLamMatchList(struct LamIntList * matches, struct LamExp * body, struct LamMatchList * next);
struct LamIntList * newLamIntList(int item, struct LamIntList * next);
struct LamLet * newLamLet(HashSymbol * var, struct LamExp * value, struct LamExp * body);
struct LamLetRec * newLamLetRec(int nbindings, struct LamLetRecBindings * bindings, struct LamExp * body);
struct LamLetRecBindings * newLamLetRecBindings(HashSymbol * var, struct LamExp * val, struct LamLetRecBindings * next);
struct LamContext * newLamContext(HashTable * frame, struct LamContext * parent);
struct LamAnd * newLamAnd(struct LamExp * left, struct LamExp * right);
struct LamOr * newLamOr(struct LamExp * left, struct LamExp * right);
struct LamAmb * newLamAmb(struct LamExp * left, struct LamExp * right);
struct LamTypeConstructorInfo * newLamTypeConstructorInfo(bool vec, int arity, int size, int index);
struct LamExp * newLamExp(enum LamExpType  type, union LamExpVal  val);
struct LamCondCases * newLamCondCases(enum LamCondCasesType  type, union LamCondCasesVal  val);

void markLamLam(struct LamLam * x);
void markLamVarList(struct LamVarList * x);
void markLamPrimApp(struct LamPrimApp * x);
void markLamUnaryApp(struct LamUnaryApp * x);
void markLamSequence(struct LamSequence * x);
void markLamList(struct LamList * x);
void markLamApply(struct LamApply * x);
void markLamMakeVec(struct LamMakeVec * x);
void markLamIff(struct LamIff * x);
void markLamCond(struct LamCond * x);
void markLamIntCondCases(struct LamIntCondCases * x);
void markLamCharCondCases(struct LamCharCondCases * x);
void markLamMatch(struct LamMatch * x);
void markLamMatchList(struct LamMatchList * x);
void markLamIntList(struct LamIntList * x);
void markLamLet(struct LamLet * x);
void markLamLetRec(struct LamLetRec * x);
void markLamLetRecBindings(struct LamLetRecBindings * x);
void markLamContext(struct LamContext * x);
void markLamAnd(struct LamAnd * x);
void markLamOr(struct LamOr * x);
void markLamAmb(struct LamAmb * x);
void markLamTypeConstructorInfo(struct LamTypeConstructorInfo * x);
void markLamExp(struct LamExp * x);
void markLamCondCases(struct LamCondCases * x);

void freeLamLam(struct LamLam * x);
void freeLamVarList(struct LamVarList * x);
void freeLamPrimApp(struct LamPrimApp * x);
void freeLamUnaryApp(struct LamUnaryApp * x);
void freeLamSequence(struct LamSequence * x);
void freeLamList(struct LamList * x);
void freeLamApply(struct LamApply * x);
void freeLamMakeVec(struct LamMakeVec * x);
void freeLamIff(struct LamIff * x);
void freeLamCond(struct LamCond * x);
void freeLamIntCondCases(struct LamIntCondCases * x);
void freeLamCharCondCases(struct LamCharCondCases * x);
void freeLamMatch(struct LamMatch * x);
void freeLamMatchList(struct LamMatchList * x);
void freeLamIntList(struct LamIntList * x);
void freeLamLet(struct LamLet * x);
void freeLamLetRec(struct LamLetRec * x);
void freeLamLetRecBindings(struct LamLetRecBindings * x);
void freeLamContext(struct LamContext * x);
void freeLamAnd(struct LamAnd * x);
void freeLamOr(struct LamOr * x);
void freeLamAmb(struct LamAmb * x);
void freeLamTypeConstructorInfo(struct LamTypeConstructorInfo * x);
void freeLamExp(struct LamExp * x);
void freeLamCondCases(struct LamCondCases * x);


#define LAMEXP_VAL_LAM(x) ((union LamExpVal ){.lam = (x)})
#define LAMEXP_VAL_VAR(x) ((union LamExpVal ){.var = (x)})
#define LAMEXP_VAL_STDINT(x) ((union LamExpVal ){.stdint = (x)})
#define LAMEXP_VAL_BIGINTEGER(x) ((union LamExpVal ){.biginteger = (x)})
#define LAMEXP_VAL_PRIM(x) ((union LamExpVal ){.prim = (x)})
#define LAMEXP_VAL_UNARY(x) ((union LamExpVal ){.unary = (x)})
#define LAMEXP_VAL_LIST(x) ((union LamExpVal ){.list = (x)})
#define LAMEXP_VAL_MAKEVEC(x) ((union LamExpVal ){.makeVec = (x)})
#define LAMEXP_VAL_APPLY(x) ((union LamExpVal ){.apply = (x)})
#define LAMEXP_VAL_IFF(x) ((union LamExpVal ){.iff = (x)})
#define LAMEXP_VAL_CALLCC(x) ((union LamExpVal ){.callcc = (x)})
#define LAMEXP_VAL_LETREC(x) ((union LamExpVal ){.letrec = (x)})
#define LAMEXP_VAL_LET(x) ((union LamExpVal ){.let = (x)})
#define LAMEXP_VAL_MATCH(x) ((union LamExpVal ){.match = (x)})
#define LAMEXP_VAL_COND(x) ((union LamExpVal ){.cond = (x)})
#define LAMEXP_VAL_AND(x) ((union LamExpVal ){.and = (x)})
#define LAMEXP_VAL_OR(x) ((union LamExpVal ){.or = (x)})
#define LAMEXP_VAL_AMB(x) ((union LamExpVal ){.amb = (x)})
#define LAMEXP_VAL_CHARACTER(x) ((union LamExpVal ){.character = (x)})
#define LAMEXP_VAL_BACK() ((union LamExpVal ){.back = (NULL)})
#define LAMEXP_VAL_ERROR() ((union LamExpVal ){.error = (NULL)})
#define LAMEXP_VAL_COND_DEFAULT() ((union LamExpVal ){.cond_default = (NULL)})
#define LAMCONDCASES_VAL_INTEGERS(x) ((union LamCondCasesVal ){.integers = (x)})
#define LAMCONDCASES_VAL_CHARACTERS(x) ((union LamCondCasesVal ){.characters = (x)})


#endif
