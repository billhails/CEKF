/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2025  Bill Hails
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 * Generated from src/lambda.yaml by tools/generate.py
 */

#include "lambda.h"
#include "memory.h"
#include "symbol.h"

#include "lambda_cps.h"
#include "lambda_functions.h"
#include "cps_kont.h"
#include "cps_kont_impl.h"

#ifdef DEBUG_LAMBDA_CPSTC
#  include "debugging_on.h"
#else
#  include "debugging_off.h"
#endif

// Forward declarations
static LamMacroSet *cpsTcLamMacroSet(LamMacroSet *node, LamExp *c);
static LamInfoTable *cpsTcLamInfoTable(LamInfoTable *node, LamExp *c);
static LamAliasTable *cpsTcLamAliasTable(LamAliasTable *node, LamExp *c);
static LamAlphaTable *cpsTcLamAlphaTable(LamAlphaTable *node, LamExp *c);
static LamPrimApp *cpsTcLamPrimApp(LamPrimApp *node, LamExp *c);
static LamSequence *cpsTcLamSequence(LamSequence *node, LamExp *c);
static LamExp *cpsTcMakeTuple(LamArgs *node, LamExp *c);
static LamExp *cpsTcLamApply(LamApply *node, LamExp *c);
static LamExp *cpsTcLamLookup(LamLookup *node, LamExp *c);
static LamLookupSymbol *cpsTcLamLookupSymbol(LamLookupSymbol *node, LamExp *c);
static LamExp *cpsTcLamConstruct(LamConstruct *node, LamExp *c);
static LamExp *cpsTcLamDeconstruct(LamDeconstruct *node, LamExp *c);
static LamTupleIndex *cpsTcLamTupleIndex(LamTupleIndex *node, LamExp *c);
static LamExp *cpsTcMakeVec(LamMakeVec *node, LamExp *c);
static LamExp *cpsTcLamIff(LamIff *node, LamExp *c);
static LamExp *cpsTcLamCond(LamCond *node, LamExp *c);
static LamExp *cpsTcLamMatch(LamMatch *node, LamExp *c);
static LamExp *cpsTcLamLet(LamLet *node, LamExp *c);
static LamExp *cpsTcLamLetStar(LamLetStar *node, LamExp *c);
static LamExp *cpsTcLamLetRec(LamLetRec *node, LamExp *c);
static LamContext *cpsTcLamContext(LamContext *node, LamExp *c);
static LamExp *cpsTcLamAmb(LamAmb *node, LamExp *c);
static LamPrint *cpsTcLamPrint(LamPrint *node, LamExp *c);
static LamTypeof *cpsTcLamTypeof(LamTypeof *node, LamExp *c);
static LamTypeDefs *cpsTcLamTypeDefs(LamTypeDefs *node, LamExp *c);
static LamTypeDefList *cpsTcLamTypeDefList(LamTypeDefList *node, LamExp *c);
static LamTypeDef *cpsTcLamTypeDef(LamTypeDef *node, LamExp *c);
static LamTypeConstructorList *cpsTcLamTypeConstructorList(LamTypeConstructorList *node, LamExp *c);
static LamTypeSig *cpsTcLamTypeSig(LamTypeSig *node, LamExp *c);
static LamTypeTags *cpsTcLamTypeTags(LamTypeTags *node, LamExp *c);
static LamTypeSigArgs *cpsTcLamTypeSigArgs(LamTypeSigArgs *node, LamExp *c);
static LamTypeConstructor *cpsTcLamTypeConstructor(LamTypeConstructor *node, LamExp *c);
static LamTypeConstructorArgs *cpsTcLamTypeConstructorArgs(LamTypeConstructorArgs *node, LamExp *c);
static LamTypeFunction *cpsTcLamTypeFunction(LamTypeFunction *node, LamExp *c);
static LamTypeConstructorInfo *cpsTcLamTypeConstructorInfo(LamTypeConstructorInfo *node, LamExp *c);
static LamAlphaEnv *cpsTcLamAlphaEnv(LamAlphaEnv *node, LamExp *c);
static LamExp *cpsTcLamExp(LamExp *node, LamExp *c);
static LamLookupOrSymbol *cpsTcLamLookupOrSymbol(LamLookupOrSymbol *node, LamExp *c);
static LamTypeConstructorType *cpsTcLamTypeConstructorType(LamTypeConstructorType *node, LamExp *c);
static LamInfo *cpsTcLamInfo(LamInfo *node, LamExp *c);
static LamNamespaceArray *cpsTcLamNamespaceArray(LamNamespaceArray *node, LamExp *c);
static LamAlphaEnvArray *cpsTcLamAlphaEnvArray(LamAlphaEnvArray *node, LamExp *c);

/*
    fn M {
        (E.lambda(vars, body)) {
            let c = gensym("$k");
            in E.lambda(vars @@ [c], T_c(body, c))
        }
        (x) { x }
    }
*/
LamExp *cpsM(LamExp *node) {
    ENTER(cpsM);
    if (node == NULL) {
        LEAVE(cpsM);
        return NULL;
    }

    switch (node->type) {
        case LAMEXP_TYPE_LAM: {
            LamExp *c = makeVar(CPI(node), "k");
            int save = PROTECT(c);
            LamVarList *args = appendLamVar(CPI(node), getLamExp_Lam(node)->args, getLamExp_Var(c));
            PROTECT(args);
            LamExp *body = cpsTc(getLamExp_Lam(node)->exp, c);
            PROTECT(body);
            LamExp *result = makeLamExp_Lam(CPI(node), args, body);
            UNPROTECT(save);
            LEAVE(cpsM);
            return result;
        }
        default:
            LEAVE(cpsM);
            return node;
    }
}
// Visitor implementations
static LamMacroSet *cpsTcLamMacroSet(LamMacroSet *node, LamExp *c) {
    ENTER(cpsTcLamMacroSet);
    if (node == NULL) {
        LEAVE(cpsTcLamMacroSet);
        return NULL;
    }

    (void)c;  // Hash set has no values to visit
    // Iterate over keys (uncomment if you need to inspect/log them)
    // Index i = 0;
    // HashSymbol *key;
    // while ((key = iterateLamMacroSet(node, &i)) != NULL) {
    //     // Inspect/log key here
    // }
    LEAVE(cpsTcLamMacroSet);
    return node;
}

static LamInfoTable *cpsTcLamInfoTable(LamInfoTable *node, LamExp *c) {
    ENTER(cpsTcLamInfoTable);
    if (node == NULL) {
        LEAVE(cpsTcLamInfoTable);
        return NULL;
    }

    bool changed = false;
    LamInfoTable *result = newLamInfoTable();
    int save = PROTECT(result);

    // Iterate over all entries
    Index i = 0;
    struct LamInfo * value;
    HashSymbol *key;
    while ((key = iterateLamInfoTable(node, &i, &value)) != NULL) {
        struct LamInfo * new_value = cpsTcLamInfo(value, c);
        PROTECT(new_value);
        changed = changed || (new_value != value);
        setLamInfoTable(result, key, new_value);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTcLamInfoTable);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamInfoTable);
    return node;
}

static LamAliasTable *cpsTcLamAliasTable(LamAliasTable *node, LamExp *c) {
    ENTER(cpsTcLamAliasTable);
    if (node == NULL) {
        LEAVE(cpsTcLamAliasTable);
        return NULL;
    }

    bool changed = false;
    LamAliasTable *result = newLamAliasTable();
    int save = PROTECT(result);

    // Iterate over all entries
    Index i = 0;
    struct LamTypeConstructorType * value;
    HashSymbol *key;
    while ((key = iterateLamAliasTable(node, &i, &value)) != NULL) {
        struct LamTypeConstructorType * new_value = cpsTcLamTypeConstructorType(value, c);
        PROTECT(new_value);
        changed = changed || (new_value != value);
        setLamAliasTable(result, key, new_value);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTcLamAliasTable);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamAliasTable);
    return node;
}

static LamAlphaTable *cpsTcLamAlphaTable(LamAlphaTable *node, LamExp *c) {
    ENTER(cpsTcLamAlphaTable);
    if (node == NULL) {
        LEAVE(cpsTcLamAlphaTable);
        return NULL;
    }

    (void)c;  // Values are HashSymbol (not memory-managed)
#ifdef NOTDEF
    // Iterate over all entries for inspection/logging
    Index i = 0;
    struct HashSymbol * value;
    HashSymbol *key;
    while ((key = iterateLamAlphaTable(node, &i, &value)) != NULL) {
        // Inspect/log key and value here
    }
#endif
    LEAVE(cpsTcLamAlphaTable);
    return node;
}

static LamPrimApp *cpsTcLamPrimApp(LamPrimApp *node, LamExp *c) {
    ENTER(cpsTcLamPrimApp);
    if (node == NULL) {
        LEAVE(cpsTcLamPrimApp);
        return NULL;
    }

    bool changed = false;
    // Pass through type (type: LamPrimOp, not memory-managed)
    LamExp *new_exp1 = cpsTcLamExp(node->exp1, c);
    int save = PROTECT(new_exp1);
    changed = changed || (new_exp1 != node->exp1);
    LamExp *new_exp2 = cpsTcLamExp(node->exp2, c);
    PROTECT(new_exp2);
    changed = changed || (new_exp2 != node->exp2);

    if (changed) {
        // Create new node with modified fields
        LamPrimApp *result = newLamPrimApp(CPI(node), node->type, new_exp1, new_exp2);
        UNPROTECT(save);
        LEAVE(cpsTcLamPrimApp);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamPrimApp);
    return node;
}

static LamSequence *cpsTcLamSequence(LamSequence *node, LamExp *c) {
    ENTER(cpsTcLamSequence);
    if (node == NULL) {
        LEAVE(cpsTcLamSequence);
        return NULL;
    }

    bool changed = false;
    LamExp *new_exp = cpsTcLamExp(node->exp, c);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamSequence *new_next = cpsTcLamSequence(node->next, c);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamSequence *result = newLamSequence(CPI(node), new_exp, new_next);
        UNPROTECT(save);
        LEAVE(cpsTcLamSequence);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamSequence);
    return node;
}

/*
    (E.make_tuple(args)) {
        Ts_k(args, fn (sargs) {
            E.apply(c, [E.make_tuple(sargs)])
        })
    }
*/
static LamExp *cpsTcMakeTuple(LamArgs *node, LamExp *c) {
    ENTER(cpsTcMakeTuple);
    CpsKont *kont = makeKont_TcMakeTuple(c);
    int save = PROTECT(kont);
    LamExp *args = newLamExp_Args(CPI(node), node);
    PROTECT(args);
    LamExp *result = cpsTs_k(args, kont);
    UNPROTECT(save);
    LEAVE(cpsTcMakeTuple);
    return result;
}

LamExp *TcMakeTupleKont(LamExp *sargs, TcMakeTupleKontEnv *env) {
    ENTER(TcMakeTupleKont);
    LamExp *make_tuple = newLamExp_MakeTuple(CPI(sargs), getLamExp_Args(sargs));
    int save = PROTECT(make_tuple);
    LamArgs *args = newLamArgs(CPI(sargs), make_tuple, NULL);
    PROTECT(args);
    LamExp *result = makeLamExp_Apply(CPI(sargs), env->c, args);
    UNPROTECT(save);
    LEAVE(TcMakeTupleKont);
    return result;
}

/*
    (E.apply(f, es)) {
        T_k(f, fn(sf) {
            Ts_k(es, fn (ses) {E.apply(sf, ses @@ [c])})
        })
    }
*/
static LamExp *cpsTcLamApply(LamApply *node, LamExp *c) {
    ENTER(cpsTcLamApply);
    if (node == NULL) {
        LEAVE(cpsTcLamApply);
        return NULL;
    }
    CpsKont *kont1 = makeKont_TcApply1(node->args, c);
    PROTECT(kont1);
    LamExp *result = cpsTk(node->function, kont1);
    UNPROTECT(1);
    LEAVE(cpsTcLamApply);
    return result;
}

LamExp *TcApply1Kont(LamExp *sf, TcApply1KontEnv *env) {
    ENTER(T_c_apply_1Kont);
    CpsKont *kont2 = makeKont_TcApply2(sf, env->c);
    int save =PROTECT(kont2);
    LamExp *args = newLamExp_Args(CPI(env->es), env->es);
    PROTECT(args);
    LamExp *result = cpsTk(args, kont2);
    UNPROTECT(save);
    LEAVE(T_c_apply_1Kont);
    return result;
}

LamExp *TcApply2Kont(LamExp *ses, TcApply2KontEnv *env) {
    ENTER(TcApply2Kont);
    LamArgs *args = appendLamArg(getLamExp_Args(ses), env->c);
    int save = PROTECT(args);
    LamExp *result = makeLamExp_Apply(CPI(env->sf), env->sf, args);
    UNPROTECT(save);
    LEAVE(TcApply2Kont);
    return result;
}

/*
    (E.lookup(name, index, expr)) {
        E.lookup(name, index, T_c(expr, c))
    }
*/
static LamExp *cpsTcLamLookup(LamLookup *node, LamExp *c) {
    ENTER(cpsTcLamLookup);
    LamExp *expr = cpsTcLamExp(node->exp, c);
    int save = PROTECT(expr);
    LamExp *result = makeLamExp_Lookup(CPI(node), node->nsid, node->nsSymbol, expr);
    UNPROTECT(save);
    LEAVE(cpsTcLamLookup);
    return result;
}

static LamLookupSymbol *cpsTcLamLookupSymbol(LamLookupSymbol *node, LamExp *c) {
    ENTER(cpsTcLamLookupSymbol);
    if (node == NULL) {
        LEAVE(cpsTcLamLookupSymbol);
        return NULL;
    }

    // Pass through nsid (type: int, not memory-managed)
    // Pass through nsSymbol (type: HashSymbol, not memory-managed)
    // Pass through symbol (type: HashSymbol, not memory-managed)

    (void)c;  // Unused parameter - all fields are pass-through
    LEAVE(cpsTcLamLookupSymbol);
    return node;
}

/*
    (E.construct(name, tag, args)) {
        Ts_k(args, fn (sargs) {
            E.apply(c, [E.construct(name, tag, sargs)])
        })
    }
*/
static LamExp *cpsTcLamConstruct(LamConstruct *node, LamExp *c) {
    ENTER(cpsTcLamConstruct);
    LamExp *args = newLamExp_Args(CPI(node), node->args);
    int save = PROTECT(args);
    CpsKont *kont = makeKont_TcConstruct(node->name, node->tag, c);
    PROTECT(kont);
    LamExp *result = cpsTk(args, kont);
    UNPROTECT(save);
    LEAVE(cpsTcLamConstruct);
    return result;
}

LamExp *TcConstructKont(LamExp *sargs, TcConstructKontEnv *env) {
    ENTER(TcConstructKont);
    LamExp *construct = makeLamExp_Construct(CPI(sargs), env->name, env->tag, getLamExp_Args(sargs));
    int save = PROTECT(construct);
    LamArgs *args = newLamArgs(CPI(sargs), construct, NULL);
    PROTECT(args);
    LamExp *result = makeLamExp_Apply(CPI(sargs), env->c, args);
    UNPROTECT(save);
    LEAVE(TcConstructKont);
    return result;
}

/*
    (E.deconstruct(name, nsid, vec, expr)) {
        T_k(expr, fn (sexpr) {
            E.apply(c, [E.deconstruct(name, nsid, vec, sexpr)])
        })
    }
*/
static LamExp *cpsTcLamDeconstruct(LamDeconstruct *node, LamExp *c) {
    ENTER(cpsTcLamDeconstruct);
    CpsKont *kont = makeKont_TcDeconstruct(node->name, node->nsid, node->vec, c);
    int save = PROTECT(kont);
    LamExp *result = cpsTk(node->exp, kont);
    UNPROTECT(save);
    LEAVE(cpsTcLamDeconstruct);
    return result;
}

LamExp *TcDeconstructKont(LamExp *sexpr, TcDeconstructKontEnv *env) {
    ENTER(TcDeconstructKont);
    LamExp *deconstruct = makeLamExp_Deconstruct(CPI(sexpr), env->name, env->nsid, env->vec, sexpr);
    int save = PROTECT(deconstruct);
    LamArgs *args = newLamArgs(CPI(sexpr), deconstruct, NULL);
    PROTECT(args);
    LamExp *result = makeLamExp_Apply(CPI(sexpr), env->c, args);
    UNPROTECT(save);
    LEAVE(TcDeconstructKont);
    return result;
}

static LamTupleIndex *cpsTcLamTupleIndex(LamTupleIndex *node, LamExp *c) {
    ENTER(cpsTcLamTupleIndex);
    if (node == NULL) {
        LEAVE(cpsTcLamTupleIndex);
        return NULL;
    }

    bool changed = false;
    // Pass through vec (type: int, not memory-managed)
    // Pass through size (type: int, not memory-managed)
    LamExp *new_exp = cpsTcLamExp(node->exp, c);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);

    if (changed) {
        // Create new node with modified fields
        LamTupleIndex *result = newLamTupleIndex(CPI(node), node->vec, node->size, new_exp);
        UNPROTECT(save);
        LEAVE(cpsTcLamTupleIndex);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTupleIndex);
    return node;
}

/*
    (E.make_vec(size, args)) {
        Ts_k(args, fn (sargs) {
            E.apply(c, [E.make_vec(size, sargs)])
        })
    }
*/
static LamExp *cpsTcMakeVec(LamMakeVec *node, LamExp *c) {
    ENTER(cpsTcMakeVec);
    CpsKont *kont = makeKont_TcMakeVec(node->nargs, c);
    int save = PROTECT(kont);
    LamExp *args = newLamExp_Args(CPI(node), node->args);
    PROTECT(args);
    LamExp *result = cpsTs_k(args, kont);
    UNPROTECT(save);
    LEAVE(cpsTcMakeVec);
    return result;
}

LamExp *TcMakeVecKont(LamExp *sargs, TcMakeVecKontEnv *env) {
    ENTER(TcMakeVecKont);
    LamExp *make_vec = makeLamExp_MakeVec(CPI(sargs), env->size, getLamExp_Args(sargs));
    int save = PROTECT(make_vec);
    LamArgs *args = newLamArgs(CPI(sargs), make_vec, NULL);
    PROTECT(args);
    LamExp *result = makeLamExp_Apply(CPI(sargs), env->c, args);
    UNPROTECT(save);
    LEAVE(TcMakeVecKont);
    return result;
}

/*
    (E.if_expr(exprc, exprt, exprf)) {
        let
            sk = genstring("$k");
            vsk = E.var(sk);
        in
            E.apply(E.lambda([sk], T_k(exprc, fn (aexp) {
                E.if_expr(aexp, T_c(exprt,vsk), T_c(exprf,vsk))
            })), [c])
    }
*/
static LamExp *cpsTcLamIff(LamIff *node, LamExp *c) {
    ENTER(cpsTcLamIff);
    LamExp *sk = makeVar(CPI(node), "k");
    int save = PROTECT(sk);
    CpsKont *k = makeKont_TcIff(sk, node->consequent, node->alternative);
    PROTECT(k);
    LamExp *body = cpsTk(node->condition, k);
    PROTECT(body);
    LamVarList *args = newLamVarList(CPI(node), getLamExp_Var(sk), NULL);
    PROTECT(args);
    LamExp *lambda = makeLamExp_Lam(CPI(node), args, body);
    PROTECT(lambda);
    LamArgs *arglist = newLamArgs(CPI(node), c, NULL);
    PROTECT(arglist);
    LamExp *result = makeLamExp_Apply(CPI(node), lambda, arglist);
    UNPROTECT(save);
    LEAVE(cpsTcLamIff);
    return result;
}

LamExp *TcIffKont(LamExp *aexp, TcIffKontEnv *env) {
    ENTER(TcIffKont);
    LamExp *then_exp = cpsTc(env->exprt, env->sk);
    int save = PROTECT(then_exp);
    LamExp *else_exp = cpsTc(env->exprf, env->sk);
    PROTECT(else_exp);
    LamExp *result = makeLamExp_Iff(CPI(aexp), aexp, then_exp, else_exp);
    UNPROTECT(save);
    LEAVE(TcIffKont);
    return result;
}

static LamIntCondCases *mapIntCondCases(LamIntCondCases *cases, LamExp *c) {
    if (cases == NULL) return NULL;
    LamIntCondCases *next = mapIntCondCases(cases->next, c);
    int save = PROTECT(next);
    LamExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    LamIntCondCases *result = newLamIntCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return result;
}

static LamCharCondCases *mapCharCondCases(LamCharCondCases *cases, LamExp *c) {
    if (cases == NULL) return NULL;
    LamCharCondCases *next = mapCharCondCases(cases->next, c);
    int save = PROTECT(next);
    LamExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    LamCharCondCases *result = newLamCharCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return result;
}

/*
    (E.cond_expr(test, branches)) {
        let
            sk = gensym("$k");
        in
            E.apply(E.lambda([sk], T_k(test, fn (atest) {
                E.cond_expr(atest, list.map(fn {(#(val, result)) {
                    #(val, T_c(result, sk))
                }}, branches))
            })), [c])
    }
*/
static LamExp *cpsTcLamCond(LamCond *node, LamExp *c) {
    ENTER(cpsTcLamCond);
    LamExp *sk = makeVar(CPI(node), "k");
    int save = PROTECT(sk);
    CpsKont *k = makeKont_TcCond(sk, node->cases);
    PROTECT(k);
    LamVarList *args = newLamVarList(CPI(node), getLamExp_Var(sk), NULL);
    PROTECT(args);
    LamExp *body = cpsTk(node->value, k);
    PROTECT(body);
    LamExp *lambda = makeLamExp_Lam(CPI(node), args, body);
    PROTECT(lambda);
    LamArgs *arglist = newLamArgs(CPI(node), c, NULL);
    PROTECT(arglist);
    LamExp *result = makeLamExp_Apply(CPI(node), lambda, arglist);
    UNPROTECT(save);
    LEAVE(cpsTcLamCond);
    return result;
}

LamExp *TcCondKont(LamExp *atest, TcCondKontEnv *env) {
    ENTER(TcCondKont);
    LamExp *result = NULL;
    LamCondCases *cases = NULL;
    int save = PROTECT(NULL);
    switch (env->branches->type) {
        case LAMCONDCASES_TYPE_INTEGERS: {
            LamIntCondCases *int_cases = mapIntCondCases(getLamCondCases_Integers(env->branches), env->sk);
            PROTECT(int_cases);
            cases = newLamCondCases_Integers(CPI(env->branches), int_cases);
            PROTECT(cases);
        }
        break;
        case LAMCONDCASES_TYPE_CHARACTERS: {
            LamCharCondCases *char_cases = mapCharCondCases(getLamCondCases_Characters(env->branches), env->sk);
            PROTECT(char_cases);
            cases = newLamCondCases_Characters(CPI(env->branches), char_cases);
            PROTECT(cases);
        }
        break;
    }
    result = makeLamExp_Cond(CPI(env->branches), atest, cases);
    UNPROTECT(save);
    LEAVE(TcCondKont);
    return result;
}

/*
    (E.match_cases(test, cases)) {
        let
            sk = gensym("$k");
        in
            E.apply(E.lambda([sk], T_k(test, fn (atest) {
                E.match_cases(atest, list.map(fn {(#(indices, result)) {
                    #(indices, T_c(result, sk))
                }}, cases))
            })), [c])
    }
*/
static LamExp *cpsTcLamMatch(LamMatch *node, LamExp *c) {
    ENTER(cpsTcLamMatch);
    LamExp *sk = makeVar(CPI(node), "k");
    int save = PROTECT(sk);
    CpsKont *k = makeKont_TcMatch(sk, node->cases);
    PROTECT(k);
    LamVarList *args = newLamVarList(CPI(node), getLamExp_Var(sk), NULL);
    PROTECT(args);
    LamExp *body = cpsTk(node->index, k);
    PROTECT(body);
    LamExp *lambda = makeLamExp_Lam(CPI(node), args, body);
    PROTECT(lambda);
    LamArgs *arglist = newLamArgs(CPI(node), c, NULL);
    PROTECT(arglist);
    LamExp *result = makeLamExp_Apply(CPI(node), lambda, arglist);
    UNPROTECT(save);
    LEAVE(cpsTcLamMatch);
    return result;
}

LamExp *TcMatchKont(LamExp *atest, TcMatchKontEnv *env) {
    ENTER(TcMatchKont);
    LamMatchList *cases = mapTcOverMatchCases(env->cases, env->sk);
    int save = PROTECT(cases);
    PROTECT(cases);
    LamExp *result = makeLamExp_Match(CPI(env->cases), atest, cases);
    UNPROTECT(save);
    LEAVE(TcMatchKont);
    return result;
}

/*
    (E.let_expr(bindings, expr)) {
        let
            #(vars, exps) = list.unzip(bindings);
        in
            T_c(E.apply(E.lambda(vars, expr), exps), c)
    }
*/
static LamExp *cpsTcLamLet(LamLet *node, LamExp *c) {
    ENTER(cpsTcLamLet);
    int save = PROTECT(NULL);
    LamVarList *vars = NULL;
    LamArgs *exps = NULL;
    cpsUnzipLamBindings(node->bindings, &vars, &exps); // PROTECTED
    LamExp *lambda = makeLamExp_Lam(CPI(node), vars, node->body);
    PROTECT(lambda);
    LamExp *apply = makeLamExp_Apply(CPI(node), lambda, exps);
    PROTECT(apply);
    LamExp *result = cpsTc(apply, c);
    UNPROTECT(save);
    LEAVE(cpsTcLamLet);
    return result;
}

/*
    (E.letstar_expr(bindings, expr)) {
        let
            fn nest_lets {
                ([], body) { body }
                (#(var, exp) @ rest, body) {
                    E.let_expr([#(var, exp)], nest_lets(rest, body))
                }
            }
        in
            T_c(nest_lets(bindings, expr), c)
    }
*/
static LamExp *cpsTcLamLetStar(LamLetStar *node, LamExp *c) {
    ENTER(cpsTcLamLetStar);
    LamExp *lets = cpsNestLets(node->bindings, node->body);
    int save = PROTECT(lets);
    LamExp *result = cpsTc(lets, c);
    UNPROTECT(save);
    LEAVE(cpsTcLamLetStar);
    return result;
}

/*
    (E.letrec_expr(bindings, expr)) {
        let
            #(vars, aexps) = list.unzip(bindings);
        in
            E.letrec_expr(list.zip(vars, list.map(M, aexps)), T_c(expr, c))
    }
*/
static LamExp *cpsTcLamLetRec(LamLetRec *node, LamExp *c) {
    ENTER(cpsTcLamLetRec);
    LamBindings *bindings = mapMOverBindings(node->bindings);
    int save = PROTECT(bindings);
    LamExp *body = cpsTc(node->body, c);
    PROTECT(body);
    LamExp *result = makeLamExp_LetRec(CPI(node), bindings, body);
    UNPROTECT(save);
    LEAVE(cpsTcLamLetRec);
    return result;
}

static LamContext *cpsTcLamContext(LamContext *node, LamExp *c) {
    ENTER(cpsTcLamContext);
    if (node == NULL) {
        LEAVE(cpsTcLamContext);
        return NULL;
    }

    bool changed = false;
    LamInfoTable *new_frame = cpsTcLamInfoTable(node->frame, c);
    int save = PROTECT(new_frame);
    changed = changed || (new_frame != node->frame);
    LamAliasTable *new_aliases = cpsTcLamAliasTable(node->aliases, c);
    PROTECT(new_aliases);
    changed = changed || (new_aliases != node->aliases);
    LamMacroSet *new_macros = cpsTcLamMacroSet(node->macros, c);
    PROTECT(new_macros);
    changed = changed || (new_macros != node->macros);
    LamContext *new_parent = cpsTcLamContext(node->parent, c);
    PROTECT(new_parent);
    changed = changed || (new_parent != node->parent);

    if (changed) {
        // Create new node with modified fields
        LamContext *result = newLamContext(CPI(node), new_parent);
        result->frame = new_frame;
        result->aliases = new_aliases;
        result->macros = new_macros;
        UNPROTECT(save);
        LEAVE(cpsTcLamContext);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamContext);
    return node;
}

/*
    (E.amb_expr(expr1, expr2)) {
        let
            k = gensym("$k");
        in 
            E.apply(E.lambda([k], E.amb_expr(T_c(expr1, k), T_c(expr2, k))), [c])
    }
*/
static LamExp *cpsTcLamAmb(LamAmb *node, LamExp *c) {
    ENTER(cpsTcLamAmb);
    if (node == NULL) {
        LEAVE(cpsTcLamAmb);
        return NULL;
    }

    LamExp *k = makeVar(CPI(node), "k");
    int save = PROTECT(k);
    LamExp *e1 = cpsTc(node->left, k);
    PROTECT(e1);
    LamExp *e2 = cpsTc(node->right, k);
    PROTECT(e2);
    LamExp *lamAmb = makeLamExp_Amb(CPI(node), e1, e2);
    PROTECT(lamAmb);
    LamVarList *fargs = newLamVarList(CPI(node), getLamExp_Var(k), NULL);
    PROTECT(fargs);
    LamExp *lambda = makeLamExp_Lam(CPI(node), fargs, lamAmb);
    PROTECT(lambda);
    LamArgs *aargs = newLamArgs(CPI(node), c, NULL);
    PROTECT(aargs);
    LamExp *result = makeLamExp_Apply(CPI(node), lambda, aargs);
    LEAVE(cpsTcLamAmb);
    UNPROTECT(save);
    return result;  
}

static LamPrint *cpsTcLamPrint(LamPrint *node, LamExp *c) {
    ENTER(cpsTcLamPrint);
    if (node == NULL) {
        LEAVE(cpsTcLamPrint);
        return NULL;
    }

    bool changed = false;
    LamExp *new_exp = cpsTcLamExp(node->exp, c);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamExp *new_printer = cpsTcLamExp(node->printer, c);
    PROTECT(new_printer);
    changed = changed || (new_printer != node->printer);

    if (changed) {
        // Create new node with modified fields
        LamPrint *result = newLamPrint(CPI(node), new_exp);
        result->printer = new_printer;
        UNPROTECT(save);
        LEAVE(cpsTcLamPrint);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamPrint);
    return node;
}

static LamTypeof *cpsTcLamTypeof(LamTypeof *node, LamExp *c) {
    ENTER(cpsTcLamTypeof);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeof);
        return NULL;
    }

    bool changed = false;
    LamExp *new_exp = cpsTcLamExp(node->exp, c);
    int save = PROTECT(new_exp);
    changed = changed || (new_exp != node->exp);
    LamExp *new_typestring = cpsTcLamExp(node->typestring, c);
    PROTECT(new_typestring);
    changed = changed || (new_typestring != node->typestring);

    if (changed) {
        // Create new node with modified fields
        LamTypeof *result = newLamTypeof(CPI(node), new_exp);
        result->typestring = new_typestring;
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeof);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeof);
    return node;
}

static LamTypeDefs *cpsTcLamTypeDefs(LamTypeDefs *node, LamExp *c) {
    ENTER(cpsTcLamTypeDefs);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeDefs);
        return NULL;
    }

    bool changed = false;
    LamTypeDefList *new_typeDefs = cpsTcLamTypeDefList(node->typeDefs, c);
    int save = PROTECT(new_typeDefs);
    changed = changed || (new_typeDefs != node->typeDefs);
    LamExp *new_body = cpsTcLamExp(node->body, c);
    PROTECT(new_body);
    changed = changed || (new_body != node->body);

    if (changed) {
        // Create new node with modified fields
        LamTypeDefs *result = newLamTypeDefs(CPI(node), new_typeDefs, new_body);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeDefs);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeDefs);
    return node;
}

static LamTypeDefList *cpsTcLamTypeDefList(LamTypeDefList *node, LamExp *c) {
    ENTER(cpsTcLamTypeDefList);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeDefList);
        return NULL;
    }

    bool changed = false;
    LamTypeDef *new_typeDef = cpsTcLamTypeDef(node->typeDef, c);
    int save = PROTECT(new_typeDef);
    changed = changed || (new_typeDef != node->typeDef);
    LamTypeDefList *new_next = cpsTcLamTypeDefList(node->next, c);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeDefList *result = newLamTypeDefList(CPI(node), new_typeDef, new_next);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeDefList);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeDefList);
    return node;
}

static LamTypeDef *cpsTcLamTypeDef(LamTypeDef *node, LamExp *c) {
    ENTER(cpsTcLamTypeDef);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeDef);
        return NULL;
    }

    bool changed = false;
    LamTypeSig *new_type = cpsTcLamTypeSig(node->type, c);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeConstructorList *new_constructors = cpsTcLamTypeConstructorList(node->constructors, c);
    PROTECT(new_constructors);
    changed = changed || (new_constructors != node->constructors);

    if (changed) {
        // Create new node with modified fields
        LamTypeDef *result = newLamTypeDef(CPI(node), new_type, new_constructors);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeDef);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeDef);
    return node;
}

static LamTypeConstructorList *cpsTcLamTypeConstructorList(LamTypeConstructorList *node, LamExp *c) {
    ENTER(cpsTcLamTypeConstructorList);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeConstructorList);
        return NULL;
    }

    bool changed = false;
    LamTypeConstructor *new_constructor = cpsTcLamTypeConstructor(node->constructor, c);
    int save = PROTECT(new_constructor);
    changed = changed || (new_constructor != node->constructor);
    LamTypeConstructorList *new_next = cpsTcLamTypeConstructorList(node->next, c);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorList *result = newLamTypeConstructorList(CPI(node), new_constructor, new_next);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeConstructorList);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeConstructorList);
    return node;
}

static LamTypeSig *cpsTcLamTypeSig(LamTypeSig *node, LamExp *c) {
    ENTER(cpsTcLamTypeSig);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeSig);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSigArgs *new_args = cpsTcLamTypeSigArgs(node->args, c);
    int save = PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeSig *result = newLamTypeSig(CPI(node), node->name, new_args);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeSig);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeSig);
    return node;
}

static LamTypeTags *cpsTcLamTypeTags(LamTypeTags *node, LamExp *c) {
    ENTER(cpsTcLamTypeTags);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeTags);
        return NULL;
    }

    bool changed = false;
    // Pass through tag (type: HashSymbol, not memory-managed)
    LamTypeTags *new_next = cpsTcLamTypeTags(node->next, c);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeTags *result = newLamTypeTags(CPI(node), node->tag, new_next);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeTags);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeTags);
    return node;
}

static LamTypeSigArgs *cpsTcLamTypeSigArgs(LamTypeSigArgs *node, LamExp *c) {
    ENTER(cpsTcLamTypeSigArgs);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeSigArgs);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSigArgs *new_next = cpsTcLamTypeSigArgs(node->next, c);
    int save = PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeSigArgs *result = newLamTypeSigArgs(CPI(node), node->name, new_next);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeSigArgs);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeSigArgs);
    return node;
}

static LamTypeConstructor *cpsTcLamTypeConstructor(LamTypeConstructor *node, LamExp *c) {
    ENTER(cpsTcLamTypeConstructor);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeConstructor);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    LamTypeSig *new_type = cpsTcLamTypeSig(node->type, c);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeConstructorArgs *new_args = cpsTcLamTypeConstructorArgs(node->args, c);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructor *result = newLamTypeConstructor(CPI(node), node->name, new_type, new_args);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeConstructor);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeConstructor);
    return node;
}

static LamTypeConstructorArgs *cpsTcLamTypeConstructorArgs(LamTypeConstructorArgs *node, LamExp *c) {
    ENTER(cpsTcLamTypeConstructorArgs);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeConstructorArgs);
        return NULL;
    }

    bool changed = false;
    LamTypeConstructorType *new_arg = cpsTcLamTypeConstructorType(node->arg, c);
    int save = PROTECT(new_arg);
    changed = changed || (new_arg != node->arg);
    LamTypeConstructorArgs *new_next = cpsTcLamTypeConstructorArgs(node->next, c);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorArgs *result = newLamTypeConstructorArgs(CPI(node), new_arg, new_next);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeConstructorArgs);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeConstructorArgs);
    return node;
}

static LamTypeFunction *cpsTcLamTypeFunction(LamTypeFunction *node, LamExp *c) {
    ENTER(cpsTcLamTypeFunction);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeFunction);
        return NULL;
    }

    bool changed = false;
    LamLookupOrSymbol *new_name = cpsTcLamLookupOrSymbol(node->name, c);
    int save = PROTECT(new_name);
    changed = changed || (new_name != node->name);
    LamTypeConstructorArgs *new_args = cpsTcLamTypeConstructorArgs(node->args, c);
    PROTECT(new_args);
    changed = changed || (new_args != node->args);

    if (changed) {
        // Create new node with modified fields
        LamTypeFunction *result = newLamTypeFunction(CPI(node), new_name, new_args);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeFunction);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeFunction);
    return node;
}

static LamTypeConstructorInfo *cpsTcLamTypeConstructorInfo(LamTypeConstructorInfo *node, LamExp *c) {
    ENTER(cpsTcLamTypeConstructorInfo);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeConstructorInfo);
        return NULL;
    }

    bool changed = false;
    // Pass through name (type: HashSymbol, not memory-managed)
    // Pass through nsid (type: int, not memory-managed)
    LamTypeConstructor *new_type = cpsTcLamTypeConstructor(node->type, c);
    int save = PROTECT(new_type);
    changed = changed || (new_type != node->type);
    LamTypeTags *new_tags = cpsTcLamTypeTags(node->tags, c);
    PROTECT(new_tags);
    changed = changed || (new_tags != node->tags);
    // Pass through needsVec (type: bool, not memory-managed)
    // Pass through arity (type: int, not memory-managed)
    // Pass through size (type: int, not memory-managed)
    // Pass through index (type: int, not memory-managed)

    if (changed) {
        // Create new node with modified fields
        LamTypeConstructorInfo *result = newLamTypeConstructorInfo(CPI(node), node->name, node->nsid, new_type, new_tags, node->needsVec, node->arity, node->size, node->index);
        UNPROTECT(save);
        LEAVE(cpsTcLamTypeConstructorInfo);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeConstructorInfo);
    return node;
}

static LamAlphaEnv *cpsTcLamAlphaEnv(LamAlphaEnv *node, LamExp *c) {
    ENTER(cpsTcLamAlphaEnv);
    if (node == NULL) {
        LEAVE(cpsTcLamAlphaEnv);
        return NULL;
    }

    bool changed = false;
    LamAlphaTable *new_alphaTable = cpsTcLamAlphaTable(node->alphaTable, c);
    int save = PROTECT(new_alphaTable);
    changed = changed || (new_alphaTable != node->alphaTable);
    LamAlphaEnv *new_next = cpsTcLamAlphaEnv(node->next, c);
    PROTECT(new_next);
    changed = changed || (new_next != node->next);
    LamAlphaEnvArray *new_namespaces = cpsTcLamAlphaEnvArray(node->namespaces, c);
    PROTECT(new_namespaces);
    changed = changed || (new_namespaces != node->namespaces);

    if (changed) {
        // Create new node with modified fields
        LamAlphaEnv *result = newLamAlphaEnv(new_next);
        result->alphaTable = new_alphaTable;
        result->namespaces = new_namespaces;
        UNPROTECT(save);
        LEAVE(cpsTcLamAlphaEnv);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamAlphaEnv);
    return node;
}

/*
    (lambda (f cc)
        (f (lambda (x i) (cc x))
           cc))
*/
static LamExp *makeCallCC(ParserInfo PI) {
    LamExp *f = makeVar(PI, "f");
    int save = PROTECT(f);
    LamExp *cc = makeVar(PI, "cc");
    PROTECT(cc);
    LamExp *x = makeVar(PI, "x");
    PROTECT(x);
    LamExp *i = makeVar(PI, "i");
    PROTECT(i);
    LamArgs *args = newLamArgs(PI, x, NULL); // (x)
    PROTECT(args);
    LamExp *apply = makeLamExp_Apply(PI, cc, args); // (cc x)
    PROTECT(apply);
    LamVarList *vars = newLamVarList(PI, getLamExp_Var(i), NULL); // (i)
    PROTECT(vars);
    vars = newLamVarList(PI, getLamExp_Var(x), vars); // (x i)
    PROTECT(vars);
    LamExp *lambda = makeLamExp_Lam(PI, vars, apply); // (lambda (x i) (cc x))
    PROTECT(lambda);
    args = newLamArgs(PI, lambda, NULL); // ((lambda (x i) (cc x)))
    PROTECT(args);
    args = newLamArgs(PI, cc, args); // ((lambda (x i) (cc x)) cc)
    PROTECT(args);
    apply = makeLamExp_Apply(PI, f, args); // (f (lambda (x i) (cc x)) cc)
    PROTECT(apply);
    vars = newLamVarList(PI, getLamExp_Var(cc), NULL); // (cc)
    PROTECT(vars);
    vars = newLamVarList(PI, getLamExp_Var(f), vars); // (f cc)
    PROTECT(vars);
    lambda = makeLamExp_Lam(PI, vars, apply); // (lambda (f cc) (f (lambda (x i) (cc x)) cc))
    UNPROTECT(save);
    return lambda;
}

/*
    (E.callCC_expr(e)) {
        T_k(e, fn (sf) {
            E.apply(
                E.parse("(lambda (f cc) (f (lambda (x i) (cc x)) cc))"),
                [sf, c]
            )
        })
    }
*/
static LamExp *cpsTcCallCC(LamExp *e, LamExp *c) {
    ENTER(cpsTcCallCC);
    CpsKont *k = makeKont_TcCallCC(c);
    int save = PROTECT(k);
    LamExp *result = cpsTk(e, k);
    UNPROTECT(save);
    LEAVE(cpsTcCallCC);
    return result;
}

LamExp *TcCallCCKont(LamExp *sf, TcCallCCKontEnv *env) {
    ENTER(TcCallCCKont);
    LamExp *callCC = makeCallCC(CPI(sf));
    int save = PROTECT(callCC);
    LamArgs * args = newLamArgs(CPI(env->c), env->c, NULL);
    PROTECT(args);
    args = newLamArgs(CPI(env->c), sf, args);
    PROTECT(args);
    LamExp *result = makeLamExp_Apply(CPI(env->c), callCC, args);
    UNPROTECT(save);
    LEAVE(TcCallCCKont);
    return result;
}

static LamExp *cpsTcLamExp(LamExp *node, LamExp *c) {
    ENTER(cpsTcLamExp);
    if (node == NULL) {
        LEAVE(cpsTcLamExp);
        return NULL;
    }

    if (isAexpr(node)) {
        LamExp *exp = cpsM(node);
        int save = PROTECT(exp);
        LamArgs *arglist = newLamArgs(CPI(node), exp, NULL);
        PROTECT(arglist);
        LamExp *result = makeLamExp_Apply(CPI(node), c, arglist);
        LEAVE(cpsTcLamExp);
        UNPROTECT(save);
        return result;
    }

    int save = PROTECT(NULL);
    LamExp *result = node;

    switch (node->type) {
        case LAMEXP_TYPE_AMB: {
            result = cpsTcLamAmb(getLamExp_Amb(node), c);
            break;
        }
        case LAMEXP_TYPE_APPLY: {
            result = cpsTcLamApply(getLamExp_Apply(node), c);
            break;
        }
        case LAMEXP_TYPE_CALLCC: {
            result = cpsTcCallCC(getLamExp_CallCC(node), c);
            break;
        }
        case LAMEXP_TYPE_COND: {
            result = cpsTcLamCond(getLamExp_Cond(node), c);
            break;
        }
        case LAMEXP_TYPE_CONSTRUCT: {
            result = cpsTcLamConstruct(getLamExp_Construct(node), c);
            break;
        }
        case LAMEXP_TYPE_DECONSTRUCT: {
            result = cpsTcLamDeconstruct(getLamExp_Deconstruct(node), c);
            break;
        }
        case LAMEXP_TYPE_IFF: {
            result = cpsTcLamIff(getLamExp_Iff(node), c);
            break;
        }
        case LAMEXP_TYPE_LET: {
            result = cpsTcLamLet(getLamExp_Let(node), c);
            break;
        }
        case LAMEXP_TYPE_LETSTAR: {
            result = cpsTcLamLetStar(getLamExp_LetStar(node), c);
            break;
        }
        case LAMEXP_TYPE_LETREC: {
            result = cpsTcLamLetRec(getLamExp_LetRec(node), c);
            break;
        }
        case LAMEXP_TYPE_LOOKUP: {
            result = cpsTcLamLookup(getLamExp_Lookup(node), c);
            break;
        }
        case LAMEXP_TYPE_MAKETUPLE: {
            result = cpsTcMakeTuple(getLamExp_MakeTuple(node), c);
            break;
        }
        case LAMEXP_TYPE_MAKEVEC: {
            result = cpsTcMakeVec(getLamExp_MakeVec(node), c);
            break;
        }
        case LAMEXP_TYPE_MATCH: {
            result = cpsTcLamMatch(getLamExp_Match(node), c);
            break;
        }
        case LAMEXP_TYPE_NAMESPACES: {
            // LamNamespaceArray
            LamNamespaceArray *variant = getLamExp_Namespaces(node);
            LamNamespaceArray *new_variant = cpsTcLamNamespaceArray(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Namespaces(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_PRIM: {
            // LamPrimApp
            LamPrimApp *variant = getLamExp_Prim(node);
            LamPrimApp *new_variant = cpsTcLamPrimApp(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Prim(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_PRINT: {
            // LamPrint
            LamPrint *variant = getLamExp_Print(node);
            LamPrint *new_variant = cpsTcLamPrint(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Print(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_SEQUENCE: {
            // LamSequence
            LamSequence *variant = getLamExp_Sequence(node);
            LamSequence *new_variant = cpsTcLamSequence(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Sequence(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_STDINT: {
            // int
            break;
        }
        case LAMEXP_TYPE_TAG: {
            // LamExp
            LamExp *variant = getLamExp_Tag(node);
            LamExp *new_variant = cpsTcLamExp(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Tag(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TUPLEINDEX: {
            // LamTupleIndex
            LamTupleIndex *variant = getLamExp_TupleIndex(node);
            LamTupleIndex *new_variant = cpsTcLamTupleIndex(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_TupleIndex(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TYPEDEFS: {
            // LamTypeDefs
            LamTypeDefs *variant = getLamExp_Typedefs(node);
            LamTypeDefs *new_variant = cpsTcLamTypeDefs(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_Typedefs(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_TYPEOF: {
            // LamTypeof
            LamTypeof *variant = getLamExp_TypeOf(node);
            LamTypeof *new_variant = cpsTcLamTypeof(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamExp_TypeOf(CPI(node), new_variant);
            }
            break;
        }
        case LAMEXP_TYPE_VAR: {
            // HashSymbol
            break;
        }
        default:
            cant_happen("unrecognized LamExp type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamExp);
    return result;
}

static LamLookupOrSymbol *cpsTcLamLookupOrSymbol(LamLookupOrSymbol *node, LamExp *c) {
    ENTER(cpsTcLamLookupOrSymbol);
    if (node == NULL) {
        LEAVE(cpsTcLamLookupOrSymbol);
        return NULL;
    }

    int save = PROTECT(NULL);
    LamLookupOrSymbol *result = node;

    switch (node->type) {
        case LAMLOOKUPORSYMBOL_TYPE_SYMBOL: {
            // HashSymbol
            break;
        }
        case LAMLOOKUPORSYMBOL_TYPE_LOOKUP: {
            // LamLookupSymbol
            LamLookupSymbol *variant = getLamLookupOrSymbol_Lookup(node);
            LamLookupSymbol *new_variant = cpsTcLamLookupSymbol(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamLookupOrSymbol_Lookup(CPI(node), new_variant);
            }
            break;
        }
        default:
            cant_happen("unrecognized LamLookupOrSymbol type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamLookupOrSymbol);
    return result;
}

static LamTypeConstructorType *cpsTcLamTypeConstructorType(LamTypeConstructorType *node, LamExp *c) {
    ENTER(cpsTcLamTypeConstructorType);
    if (node == NULL) {
        LEAVE(cpsTcLamTypeConstructorType);
        return NULL;
    }

    int save = PROTECT(NULL);
    LamTypeConstructorType *result = node;

    switch (node->type) {
        case LAMTYPECONSTRUCTORTYPE_TYPE_INTEGER: {
            // void_ptr
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_CHARACTER: {
            // void_ptr
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_VAR: {
            // HashSymbol
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_FUNCTION: {
            // LamTypeFunction
            LamTypeFunction *variant = getLamTypeConstructorType_Function(node);
            LamTypeFunction *new_variant = cpsTcLamTypeFunction(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamTypeConstructorType_Function(CPI(node), new_variant);
            }
            break;
        }
        case LAMTYPECONSTRUCTORTYPE_TYPE_TUPLE: {
            // LamTypeConstructorArgs
            LamTypeConstructorArgs *variant = getLamTypeConstructorType_Tuple(node);
            LamTypeConstructorArgs *new_variant = cpsTcLamTypeConstructorArgs(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamTypeConstructorType_Tuple(CPI(node), new_variant);
            }
            break;
        }
        default:
            cant_happen("unrecognized LamTypeConstructorType type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamTypeConstructorType);
    return result;
}

static LamInfo *cpsTcLamInfo(LamInfo *node, LamExp *c) {
    ENTER(cpsTcLamInfo);
    if (node == NULL) {
        LEAVE(cpsTcLamInfo);
        return NULL;
    }

    int save = PROTECT(NULL);
    LamInfo *result = node;

    switch (node->type) {
        case LAMINFO_TYPE_TYPECONSTRUCTORINFO: {
            // LamTypeConstructorInfo
            LamTypeConstructorInfo *variant = getLamInfo_TypeConstructorInfo(node);
            LamTypeConstructorInfo *new_variant = cpsTcLamTypeConstructorInfo(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamInfo_TypeConstructorInfo(CPI(node), new_variant);
            }
            break;
        }
        case LAMINFO_TYPE_NAMESPACEINFO: {
            // LamContext
            LamContext *variant = getLamInfo_NamespaceInfo(node);
            LamContext *new_variant = cpsTcLamContext(variant, c);
            if (new_variant != variant) {
                PROTECT(new_variant);
                result = newLamInfo_NamespaceInfo(CPI(node), new_variant);
            }
            break;
        }
        case LAMINFO_TYPE_NSID: {
            // int
            break;
        }
        default:
            cant_happen("unrecognized LamInfo type %d", node->type);
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamInfo);
    return result;
}

static LamNamespaceArray *cpsTcLamNamespaceArray(LamNamespaceArray *node, LamExp *c) {
    ENTER(cpsTcLamNamespaceArray);
    if (node == NULL) {
        LEAVE(cpsTcLamNamespaceArray);
        return NULL;
    }

    bool changed = false;
    LamNamespaceArray *result = newLamNamespaceArray();
    int save = PROTECT(result);

    // Iterate over all elements
    for (Index i = 0; i < node->size; i++) {
        struct LamExp * element = peeknLamNamespaceArray(node, i);
        struct LamExp * new_element = cpsTcLamExp(element, c);
        PROTECT(new_element);
        changed = changed || (new_element != element);
        pushLamNamespaceArray(result, new_element);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTcLamNamespaceArray);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamNamespaceArray);
    return node;
}

static LamAlphaEnvArray *cpsTcLamAlphaEnvArray(LamAlphaEnvArray *node, LamExp *c) {
    ENTER(cpsTcLamAlphaEnvArray);
    if (node == NULL) {
        LEAVE(cpsTcLamAlphaEnvArray);
        return NULL;
    }

    bool changed = false;
    LamAlphaEnvArray *result = newLamAlphaEnvArray();
    int save = PROTECT(result);

    // Iterate over all elements
    for (Index i = 0; i < node->size; i++) {
        struct LamAlphaEnv * element = peeknLamAlphaEnvArray(node, i);
        struct LamAlphaEnv * new_element = cpsTcLamAlphaEnv(element, c);
        PROTECT(new_element);
        changed = changed || (new_element != element);
        pushLamAlphaEnvArray(result, new_element);
    }

    if (changed) {
        UNPROTECT(save);
        LEAVE(cpsTcLamAlphaEnvArray);
        return result;
    }

    UNPROTECT(save);
    LEAVE(cpsTcLamAlphaEnvArray);
    return node;
}


LamExp *cpsTc(LamExp *node, LamExp *c) {
    ENTER(cpsTc);
    LamExp *result = cpsTcLamExp(node, c);
    LEAVE(cpsTc);
    return result;
}