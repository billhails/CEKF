/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2025  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Plain lambda structures generated by lambda conversion.
 * Generated from src/lambda.yaml by tools/generate.py
 */

#include "common.h"
#include "memory.h"
#include "minlam.h"
#include "symbol.h"

#include "cps_kont.h"
#include "cps_kont_impl.h"
#include "lambda_cps.h"
#include "lambda_functions.h"

#ifdef DEBUG_LAMBDA_CPSTC
#include "debugging_on.h"
#else
#include "debugging_off.h"
#endif

// Forward declarations
static MinExp *cpsTcTag(MinExp *node, MinExp *c);
static MinExp *cpsTcMinPrimApp(MinPrimApp *node, MinExp *c);
static MinExp *cpsTcMinSequence(MinSequence *node, MinExp *c);
static MinExp *cpsTcMakeTuple(MinArgs *node, MinExp *c);
static MinExp *cpsTcMinApply(MinApply *node, MinExp *c);
static MinExp *cpsTcMinLookUp(MinLookUp *node, MinExp *c);
static MinExp *cpsTcMinTupleIndex(MinTupleIndex *node, MinExp *c);
static MinExp *cpsTcMakeVec(MinMakeVec *node, MinExp *c);
static MinExp *cpsTcMinIff(MinIff *node, MinExp *c);
static MinExp *cpsTcMinCond(MinCond *node, MinExp *c);
static MinExp *cpsTcMinMatch(MinMatch *node, MinExp *c);
static MinExp *cpsTcMinLetRec(MinLetRec *node, MinExp *c);
static MinExp *cpsTcMinAmb(MinAmb *node, MinExp *c);
static MinExp *cpsTcMinTypeDefs(MinTypeDefs *node, MinExp *c);
static MinExp *cpsTcMinExp(MinExp *node, MinExp *c);
static MinExp *cpsTcMinNameSpaceArray(MinNameSpaceArray *node, MinExp *c);

/*
    fn M {
        (E.lambda(vars, body)) {
            let c = gensym("$k");
            in E.lambda(vars @@ [c], T_c(body, c))
        }
        (x) { x }
    }
*/
MinExp *cpsM(MinExp *node) {
    ENTER(cpsM);
    if (node == NULL) {
        LEAVE(cpsM);
        return NULL;
    }

    switch (node->type) {
    case MINEXP_TYPE_LAM: {
        MinExp *c = makeVar(CPI(node), "k");
        int save = PROTECT(c);
        MinVarList *args = appendMinVar(CPI(node), getMinExp_Lam(node)->args,
                                        getMinExp_Var(c));
        PROTECT(args);
        MinExp *body = cpsTc(getMinExp_Lam(node)->exp, c);
        PROTECT(body);
        MinExp *result = makeMinExp_Lam(CPI(node), args, body);
        UNPROTECT(save);
        LEAVE(cpsM);
        return result;
    }
    default:
        LEAVE(cpsM);
        return node;
    }
}

// Visitor implementations

/*
    (E.tag(expr)) {
        T_k(expr, fn (sexpr) {
            E.apply(c, [E.tag(sexpr)])
        })
    }
*/
static MinExp *cpsTcTag(MinExp *node, MinExp *c) {
    ENTER(cpsTcTag);
    CpsKont *k = makeKont_TcTag(c);
    int save = PROTECT(k);
    MinExp *result = cpsTk(node, k);
    UNPROTECT(save);
    LEAVE(cpsTcTag);
    return result;
}

MinExp *TcTagKont(MinExp *sexpr, TcTagKontEnv *env) {
    ENTER(TcTagKont);
    MinExp *tagged = newMinExp_Tag(CPI(sexpr), sexpr);
    int save = PROTECT(tagged);
    MinArgs *args = newMinArgs(CPI(tagged), tagged, NULL);
    PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(tagged), env->c, args);
    UNPROTECT(save);
    LEAVE(TcTagKont);
    return result;
}

/*
    (E.primapp(p, e1, e2)) {
        T_k(e1, fn (s1) {
            T_k(e2, fn (s2) {
                E.apply(c, [E.primapp(p, s1, s2)])
            })
        })
    }
*/
static MinExp *cpsTcMinPrimApp(MinPrimApp *node, MinExp *c) {
    ENTER(cpsTcMinPrimApp);
    CpsKont *k = makeKont_TcPrimApp1(c, node->exp2, node->type);
    int save = PROTECT(k);
    MinExp *result = cpsTk(node->exp1, k);
    UNPROTECT(save);
    LEAVE(cpsTcMinPrimApp);
    return result;
}

MinExp *TcPrimApp1Kont(MinExp *s1, TcPrimApp1KontEnv *env) {
    ENTER(TcPrimApp1Kont);
    CpsKont *k = makeKont_TcPrimApp2(env->c, s1, env->p);
    int save = PROTECT(k);
    MinExp *result = cpsTk(env->e2, k);
    UNPROTECT(save);
    LEAVE(TcPrimApp1Kont);
    return result;
}

MinExp *TcPrimApp2Kont(MinExp *s2, TcPrimApp2KontEnv *env) {
    ENTER(TcPrimApp2Kont);
    MinExp *primapp = makeMinExp_Prim(CPI(env->s1), env->p, env->s1, s2);
    int save = PROTECT(primapp);
    MinArgs *args = newMinArgs(CPI(primapp), primapp, NULL);
    PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(primapp), env->c, args);
    UNPROTECT(save);
    LEAVE(TcPrimApp2Kont);
    return result;
}

/*
    (E.sequence([expr])) { T_c(expr, c) }
    (E.sequence(expr @ exprs)) {
        T_k(expr, fn (ignored) {
            T_c(E.sequence(exprs), c)
        })
    }
*/
static MinExp *cpsTcMinSequence(MinSequence *node, MinExp *c) {
    ENTER(cpsTcMinSequence);
#ifdef SAFETY_CHECKS
    if (node == NULL) {
        cant_happen("NULL node in cpsTcMinSequence");
    }
#endif
    MinExp *result = NULL;
    int save = PROTECT(NULL);
    if (node->next == NULL) {
        result = cpsTcMinExp(node->exp, c);
    } else {
        CpsKont *kont = makeKont_TcSequence(c, node->next);
        PROTECT(kont);
        result = cpsTk(node->exp, kont);
    }
    UNPROTECT(save);
    LEAVE(cpsTcMinSequence);
    return result;
}

MinExp *TcSequenceKont(MinExp *ignored, TcSequenceKontEnv *env) {
    ENTER(TcSequenceKont);
    MinExp *sequence = newMinExp_Sequence(CPI(ignored), env->exprs);
    int save = PROTECT(sequence);
    MinExp *result = cpsTcMinExp(sequence, env->c);
    UNPROTECT(save);
    LEAVE(TcSequenceKont);
    return result;
}

/*
    (E.make_tuple(args)) {
        Ts_k(args, fn (sargs) {
            E.apply(c, [E.make_tuple(sargs)])
        })
    }
*/
static MinExp *cpsTcMakeTuple(MinArgs *node, MinExp *c) {
    ENTER(cpsTcMakeTuple);
    CpsKont *kont = makeKont_TcMakeTuple(c);
    int save = PROTECT(kont);
    MinExp *args = newMinExp_Args(CPI(node), node);
    PROTECT(args);
    MinExp *result = cpsTs_k(args, kont);
    UNPROTECT(save);
    LEAVE(cpsTcMakeTuple);
    return result;
}

MinExp *TcMakeTupleKont(MinExp *sargs, TcMakeTupleKontEnv *env) {
    ENTER(TcMakeTupleKont);
    MinExp *make_tuple = newMinExp_MakeTuple(CPI(sargs), getMinExp_Args(sargs));
    int save = PROTECT(make_tuple);
    MinArgs *args = newMinArgs(CPI(sargs), make_tuple, NULL);
    PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(sargs), env->c, args);
    UNPROTECT(save);
    LEAVE(TcMakeTupleKont);
    return result;
}

/*
    (E.apply(f, es)) {
        T_k(f, fn(sf) {
            Ts_k(es, fn (ses) {E.apply(sf, ses @@ [c])})
        })
    }
*/
static MinExp *cpsTcMinApply(MinApply *node, MinExp *c) {
    ENTER(cpsTcMinApply);
    if (node == NULL) {
        LEAVE(cpsTcMinApply);
        return NULL;
    }
    CpsKont *kont1 = makeKont_TcApply1(node->args, c);
    int save = PROTECT(kont1);
    MinExp *result = cpsTk(node->function, kont1);
    UNPROTECT(save);
    LEAVE(cpsTcMinApply);
    return result;
}

MinExp *TcApply1Kont(MinExp *sf, TcApply1KontEnv *env) {
    ENTER(T_c_apply_1Kont);
    CpsKont *kont2 = makeKont_TcApply2(sf, env->c);
    int save = PROTECT(kont2);
    MinExp *args = newMinExp_Args(CPI(env->c), env->es);
    PROTECT(args);
    MinExp *result = cpsTs_k(args, kont2);
    UNPROTECT(save);
    LEAVE(T_c_apply_1Kont);
    return result;
}

MinExp *TcApply2Kont(MinExp *ses, TcApply2KontEnv *env) {
    ENTER(TcApply2Kont);
    MinArgs *args = appendMinArg(getMinExp_Args(ses), env->c);
    int save = PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(env->sf), env->sf, args);
    UNPROTECT(save);
    LEAVE(TcApply2Kont);
    return result;
}

/*
    (E.lookUp(name, index, expr)) {
        E.lookUp(name, index, T_c(expr, c))
    }
*/
static MinExp *cpsTcMinLookUp(MinLookUp *node, MinExp *c) {
    ENTER(cpsTcMinLookUp);
    MinExp *expr = cpsTcMinExp(node->exp, c);
    int save = PROTECT(expr);
    MinExp *result =
        makeMinExp_LookUp(CPI(node), node->nsId, node->nsSymbol, expr);
    UNPROTECT(save);
    LEAVE(cpsTcMinLookUp);
    return result;
}

/*
    (E.tuple_index(size, index, expr)) {
        T_k(expr, fn (sexpr) {
            E.apply(c, [E.tuple_index(size, index, sexpr)])
        })
    }
*/
static MinExp *cpsTcMinTupleIndex(MinTupleIndex *node, MinExp *c) {
    ENTER(cpsTcMinTupleIndex);
    CpsKont *kont = makeKont_TcTupleIndex(node->size, node->vec, c);
    int save = PROTECT(kont);
    MinExp *result = cpsTk(node->exp, kont);
    UNPROTECT(save);
    LEAVE(cpsTcMinTupleIndex);
    return result;
}

MinExp *TcTupleIndexKont(MinExp *sexpr, TcTupleIndexKontEnv *env) {
    ENTER(TcTupleIndexKont);
    MinExp *tuple_index =
        makeMinExp_TupleIndex(CPI(sexpr), env->size, env->index, sexpr);
    int save = PROTECT(tuple_index);
    MinArgs *args = newMinArgs(CPI(sexpr), tuple_index, NULL);
    PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(sexpr), env->c, args);
    UNPROTECT(save);
    LEAVE(TcTupleIndexKont);
    return result;
}

/*
    (E.make_vec(size, args)) {
        Ts_k(args, fn (sargs) {
            E.apply(c, [E.make_vec(size, sargs)])
        })
    }
*/
static MinExp *cpsTcMakeVec(MinMakeVec *node, MinExp *c) {
    ENTER(cpsTcMakeVec);
    CpsKont *kont = makeKont_TcMakeVec(node->nArgs, c);
    int save = PROTECT(kont);
    MinExp *args = newMinExp_Args(CPI(node), node->args);
    PROTECT(args);
    MinExp *result = cpsTs_k(args, kont);
    UNPROTECT(save);
    LEAVE(cpsTcMakeVec);
    return result;
}

MinExp *TcMakeVecKont(MinExp *sargs, TcMakeVecKontEnv *env) {
    ENTER(TcMakeVecKont);
    MinExp *make_vec =
        makeMinExp_MakeVec(CPI(sargs), env->size, getMinExp_Args(sargs));
    int save = PROTECT(make_vec);
    MinArgs *args = newMinArgs(CPI(sargs), make_vec, NULL);
    PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(sargs), env->c, args);
    UNPROTECT(save);
    LEAVE(TcMakeVecKont);
    return result;
}

/*
    (E.if_expr(exprc, exprt, exprf)) {
        let
            sk = genstring("$k");
            vsk = E.var(sk);
        in
            E.apply(E.lambda([sk], T_k(exprc, fn (aexp) {
                E.if_expr(aexp, T_c(exprt,vsk), T_c(exprf,vsk))
            })), [c])
    }
*/
static MinExp *cpsTcMinIff(MinIff *node, MinExp *c) {
    ENTER(cpsTcMinIff);
    MinExp *sk = makeVar(CPI(node), "k");
    int save = PROTECT(sk);
    CpsKont *k = makeKont_TcIff(sk, node->consequent, node->alternative);
    PROTECT(k);
    MinExp *body = cpsTk(node->condition, k);
    PROTECT(body);
    MinVarList *args = newMinVarList(CPI(node), getMinExp_Var(sk), NULL);
    PROTECT(args);
    MinExp *lambda = makeMinExp_Lam(CPI(node), args, body);
    PROTECT(lambda);
    MinArgs *arglist = newMinArgs(CPI(node), c, NULL);
    PROTECT(arglist);
    MinExp *result = makeMinExp_Apply(CPI(node), lambda, arglist);
    UNPROTECT(save);
    LEAVE(cpsTcMinIff);
    return result;
}

MinExp *TcIffKont(MinExp *aexp, TcIffKontEnv *env) {
    ENTER(TcIffKont);
    MinExp *then_exp = cpsTc(env->exprt, env->sk);
    int save = PROTECT(then_exp);
    MinExp *else_exp = cpsTc(env->exprf, env->sk);
    PROTECT(else_exp);
    MinExp *result = makeMinExp_Iff(CPI(aexp), aexp, then_exp, else_exp);
    UNPROTECT(save);
    LEAVE(TcIffKont);
    return result;
}

static MinIntCondCases *mapIntCondCases(MinIntCondCases *cases, MinExp *c) {
    if (cases == NULL)
        return NULL;
    MinIntCondCases *next = mapIntCondCases(cases->next, c);
    int save = PROTECT(next);
    MinExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    MinIntCondCases *result =
        newMinIntCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return result;
}

static MinCharCondCases *mapCharCondCases(MinCharCondCases *cases, MinExp *c) {
    if (cases == NULL)
        return NULL;
    MinCharCondCases *next = mapCharCondCases(cases->next, c);
    int save = PROTECT(next);
    MinExp *body = cpsTc(cases->body, c);
    PROTECT(body);
    MinCharCondCases *result =
        newMinCharCondCases(CPI(cases), cases->constant, body, next);
    UNPROTECT(save);
    return result;
}

/*
    (E.cond_expr(test, branches)) {
        let
            sk = gensym("$k");
        in
            E.apply(E.lambda([sk], T_k(test, fn (atest) {
                E.cond_expr(atest, list.map(fn {(#(val, result)) {
                    #(val, T_c(result, sk))
                }}, branches))
            })), [c])
    }
*/
static MinExp *cpsTcMinCond(MinCond *node, MinExp *c) {
    ENTER(cpsTcMinCond);
    MinExp *sk = makeVar(CPI(node), "k");
    int save = PROTECT(sk);
    CpsKont *k = makeKont_TcCond(sk, node->cases);
    PROTECT(k);
    MinVarList *args = newMinVarList(CPI(node), getMinExp_Var(sk), NULL);
    PROTECT(args);
    MinExp *body = cpsTk(node->value, k);
    PROTECT(body);
    MinExp *lambda = makeMinExp_Lam(CPI(node), args, body);
    PROTECT(lambda);
    MinArgs *arglist = newMinArgs(CPI(node), c, NULL);
    PROTECT(arglist);
    MinExp *result = makeMinExp_Apply(CPI(node), lambda, arglist);
    UNPROTECT(save);
    LEAVE(cpsTcMinCond);
    return result;
}

MinExp *TcCondKont(MinExp *atest, TcCondKontEnv *env) {
    ENTER(TcCondKont);
    MinExp *result = NULL;
    MinCondCases *cases = NULL;
    int save = PROTECT(NULL);
    switch (env->branches->type) {
    case MINCONDCASES_TYPE_INTEGERS: {
        MinIntCondCases *int_cases =
            mapIntCondCases(getMinCondCases_Integers(env->branches), env->sk);
        PROTECT(int_cases);
        cases = newMinCondCases_Integers(CPI(env->branches), int_cases);
        PROTECT(cases);
    } break;
    case MINCONDCASES_TYPE_CHARACTERS: {
        MinCharCondCases *char_cases = mapCharCondCases(
            getMinCondCases_Characters(env->branches), env->sk);
        PROTECT(char_cases);
        cases = newMinCondCases_Characters(CPI(env->branches), char_cases);
        PROTECT(cases);
    } break;
    }
    result = makeMinExp_Cond(CPI(env->branches), atest, cases);
    UNPROTECT(save);
    LEAVE(TcCondKont);
    return result;
}

/*
    (E.match_cases(test, cases)) {
        let
            sk = gensym("$k");
        in
            E.apply(E.lambda([sk], T_k(test, fn (atest) {
                E.match_cases(atest, list.map(fn {(#(indices, result)) {
                    #(indices, T_c(result, sk))
                }}, cases))
            })), [c])
    }
*/
static MinExp *cpsTcMinMatch(MinMatch *node, MinExp *c) {
    ENTER(cpsTcMinMatch);
    MinExp *sk = makeVar(CPI(node), "k");
    int save = PROTECT(sk);
    CpsKont *k = makeKont_TcMatch(sk, node->cases);
    PROTECT(k);
    MinVarList *args = newMinVarList(CPI(node), getMinExp_Var(sk), NULL);
    PROTECT(args);
    MinExp *body = cpsTk(node->index, k);
    PROTECT(body);
    MinExp *lambda = makeMinExp_Lam(CPI(node), args, body);
    PROTECT(lambda);
    MinArgs *arglist = newMinArgs(CPI(node), c, NULL);
    PROTECT(arglist);
    MinExp *result = makeMinExp_Apply(CPI(node), lambda, arglist);
    UNPROTECT(save);
    LEAVE(cpsTcMinMatch);
    return result;
}

MinExp *TcMatchKont(MinExp *atest, TcMatchKontEnv *env) {
    ENTER(TcMatchKont);
    MinMatchList *cases = mapTcOverMatchCases(env->cases, env->sk);
    int save = PROTECT(cases);
    PROTECT(cases);
    MinExp *result = makeMinExp_Match(CPI(env->cases), atest, cases);
    UNPROTECT(save);
    LEAVE(TcMatchKont);
    return result;
}

/*
    (E.letrec_expr(bindings, expr)) {
        let
            #(vars, aexps) = list.unzip(bindings);
        in
            E.letrec_expr(list.zip(vars, list.map(M, aexps)), T_c(expr, c))
    }
*/
static MinExp *cpsTcMinLetRec(MinLetRec *node, MinExp *c) {
    ENTER(cpsTcMinLetRec);
    MinBindings *bindings = mapMOverBindings(node->bindings);
    int save = PROTECT(bindings);
    MinExp *body = cpsTc(node->body, c);
    PROTECT(body);
    MinExp *result = makeMinExp_LetRec(CPI(node), bindings, body);
    UNPROTECT(save);
    LEAVE(cpsTcMinLetRec);
    return result;
}

/*
    (E.amb_expr(expr1, expr2)) {
        let
            k = gensym("$k");
        in
            E.apply(E.lambda([k], E.amb_expr(T_c(expr1, k), T_c(expr2, k))),
   [c])
    }
*/
static MinExp *cpsTcMinAmb(MinAmb *node, MinExp *c) {
    ENTER(cpsTcMinAmb);
    if (node == NULL) {
        LEAVE(cpsTcMinAmb);
        return NULL;
    }

    MinExp *k = makeVar(CPI(node), "k");
    int save = PROTECT(k);
    MinExp *e1 = cpsTc(node->left, k);
    PROTECT(e1);
    MinExp *e2 = cpsTc(node->right, k);
    PROTECT(e2);
    MinExp *lamAmb = makeMinExp_Amb(CPI(node), e1, e2);
    PROTECT(lamAmb);
    MinVarList *fargs = newMinVarList(CPI(node), getMinExp_Var(k), NULL);
    PROTECT(fargs);
    MinExp *lambda = makeMinExp_Lam(CPI(node), fargs, lamAmb);
    PROTECT(lambda);
    MinArgs *aargs = newMinArgs(CPI(node), c, NULL);
    PROTECT(aargs);
    MinExp *result = makeMinExp_Apply(CPI(node), lambda, aargs);
    LEAVE(cpsTcMinAmb);
    UNPROTECT(save);
    return result;
}

/*
    (E.typeDefs(defs, expr)) {
        E.typeDefs(defs, T_c(expr, c))
    }
*/
static MinExp *cpsTcMinTypeDefs(MinTypeDefs *node, MinExp *c) {
    ENTER(cpsTcMinTypeDefs);
    MinExp *body = cpsTcMinExp(node->body, c);
    int save = PROTECT(body);
    MinExp *result = makeMinExp_TypeDefs(CPI(node), node->typeDefs, body);
    UNPROTECT(save);
    LEAVE(cpsTcMinTypeDefs);
    return result;
}

/*
    (lambda (f cc)
        (f (lambda (x i) (cc x))
           cc))
*/
static MinExp *makeCallCC(ParserInfo PI) {
    MinExp *f = makeVar(PI, "f");
    int save = PROTECT(f);
    MinExp *cc = makeVar(PI, "cc");
    PROTECT(cc);
    MinExp *x = makeVar(PI, "x");
    PROTECT(x);
    MinExp *i = makeVar(PI, "i");
    PROTECT(i);
    MinArgs *args = newMinArgs(PI, x, NULL); // (x)
    PROTECT(args);
    MinExp *apply = makeMinExp_Apply(PI, cc, args); // (cc x)
    PROTECT(apply);
    MinVarList *vars = newMinVarList(PI, getMinExp_Var(i), NULL); // (i)
    PROTECT(vars);
    vars = newMinVarList(PI, getMinExp_Var(x), vars); // (x i)
    PROTECT(vars);
    MinExp *lambda = makeMinExp_Lam(PI, vars, apply); // (lambda (x i) (cc x))
    PROTECT(lambda);
    args = newMinArgs(PI, lambda, NULL); // ((lambda (x i) (cc x)))
    PROTECT(args);
    args = newMinArgs(PI, cc, args); // ((lambda (x i) (cc x)) cc)
    PROTECT(args);
    apply = makeMinExp_Apply(PI, f, args); // (f (lambda (x i) (cc x)) cc)
    PROTECT(apply);
    vars = newMinVarList(PI, getMinExp_Var(cc), NULL); // (cc)
    PROTECT(vars);
    vars = newMinVarList(PI, getMinExp_Var(f), vars); // (f cc)
    PROTECT(vars);
    lambda = makeMinExp_Lam(
        PI, vars, apply); // (lambda (f cc) (f (lambda (x i) (cc x)) cc))
    UNPROTECT(save);
    return lambda;
}

/*
    (E.callCC_expr(e)) {
        T_k(e, fn (sf) {
            E.apply(
                E.parse("(lambda (f cc) (f (lambda (x i) (cc x)) cc))"),
                [sf, c]
            )
        })
    }
*/
static MinExp *cpsTcCallCC(MinExp *e, MinExp *c) {
    ENTER(cpsTcCallCC);
    CpsKont *k = makeKont_TcCallCC(c);
    int save = PROTECT(k);
    MinExp *result = cpsTk(e, k);
    UNPROTECT(save);
    LEAVE(cpsTcCallCC);
    return result;
}

MinExp *TcCallCCKont(MinExp *sf, TcCallCCKontEnv *env) {
    ENTER(TcCallCCKont);
    MinExp *callCC = makeCallCC(CPI(sf));
    int save = PROTECT(callCC);
    MinArgs *args = newMinArgs(CPI(env->c), env->c, NULL);
    PROTECT(args);
    args = newMinArgs(CPI(env->c), sf, args);
    PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(env->c), callCC, args);
    UNPROTECT(save);
    LEAVE(TcCallCCKont);
    return result;
}

static MinExp *cpsTcMinExp(MinExp *node, MinExp *c) {
    if (node == NULL)
        return NULL;

    if (isAexpr(node)) {
        MinExp *exp = cpsM(node);
        int save = PROTECT(exp);
        MinArgs *arglist = newMinArgs(CPI(node), exp, NULL);
        PROTECT(arglist);
        MinExp *result = makeMinExp_Apply(CPI(node), c, arglist);
        UNPROTECT(save);
        return result;
    }

    switch (node->type) {
    case MINEXP_TYPE_AMB:
        return cpsTcMinAmb(getMinExp_Amb(node), c);
    case MINEXP_TYPE_APPLY:
        return cpsTcMinApply(getMinExp_Apply(node), c);
    case MINEXP_TYPE_CALLCC:
        return cpsTcCallCC(getMinExp_CallCC(node), c);
    case MINEXP_TYPE_COND:
        return cpsTcMinCond(getMinExp_Cond(node), c);
    case MINEXP_TYPE_IFF:
        return cpsTcMinIff(getMinExp_Iff(node), c);
    case MINEXP_TYPE_LETREC:
        return cpsTcMinLetRec(getMinExp_LetRec(node), c);
    case MINEXP_TYPE_LOOKUP:
        return cpsTcMinLookUp(getMinExp_LookUp(node), c);
    case MINEXP_TYPE_MAKETUPLE:
        return cpsTcMakeTuple(getMinExp_MakeTuple(node), c);
    case MINEXP_TYPE_MAKEVEC:
        return cpsTcMakeVec(getMinExp_MakeVec(node), c);
    case MINEXP_TYPE_MATCH:
        return cpsTcMinMatch(getMinExp_Match(node), c);
    case MINEXP_TYPE_NAMESPACES:
        return cpsTcMinNameSpaceArray(getMinExp_NameSpaces(node), c);
    case MINEXP_TYPE_PRIM:
        return cpsTcMinPrimApp(getMinExp_Prim(node), c);
    case MINEXP_TYPE_SEQUENCE:
        return cpsTcMinSequence(getMinExp_Sequence(node), c);
    case MINEXP_TYPE_TAG:
        return cpsTcTag(getMinExp_Tag(node), c);
    case MINEXP_TYPE_TUPLEINDEX:
        return cpsTcMinTupleIndex(getMinExp_TupleIndex(node), c);
    case MINEXP_TYPE_TYPEDEFS:
        return cpsTcMinTypeDefs(getMinExp_TypeDefs(node), c);
    default:
        cant_happen("unrecognized MinExp type %s", minExpTypeName(node->type));
    }
}

/*
    (E.nameSpaces(exprs)) {
        Ts_k(exprs, fn (sexprs) {
            E.apply(c, [E.nameSpaces(sexprs)])
        })
    }
*/
static MinExp *cpsTcMinNameSpaceArray(MinNameSpaceArray *node, MinExp *c) {
    ENTER(cpsTcMinNameSpaceArray);
    MinExp *seq = nsaToArgs(node);
    int save = PROTECT(seq);
    CpsKont *k1 = makeKont_TcNameSpaces(c);
    PROTECT(k1);
    MinExp *result = cpsTs_k(seq, k1);
    UNPROTECT(save);
    LEAVE(cpsTcMinNameSpaceArray);
    return result;
}

MinExp *TcNameSpacesKont(MinExp *sexprs, TcNameSpacesKontEnv *env) {
    ENTER(TcNameSpacesKont);
    MinNameSpaceArray *nsa = argsToNsa(sexprs);
    int save = PROTECT(nsa);
    MinExp *nsaExp = newMinExp_NameSpaces(CPI(sexprs), nsa);
    PROTECT(nsaExp);
    MinArgs *args = newMinArgs(CPI(nsaExp), nsaExp, NULL);
    PROTECT(args);
    MinExp *result = makeMinExp_Apply(CPI(env->c), env->c, args);
    UNPROTECT(save);
    LEAVE(TcNameSpacesKont);
    return result;
}

MinExp *cpsTc(MinExp *node, MinExp *c) {
    ENTER(cpsTc);
    MinExp *result = cpsTcMinExp(node, c);
    LEAVE(cpsTc);
    return result;
}