#ifndef cekf_ast_h
#define cekf_ast_h
/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// generated by makeAST.py



#include "hash.h"
#include "memory.h"

typedef enum AstBinOpType {
    AST_BINOPTYPE_TYPE_THEN,
    AST_BINOPTYPE_TYPE_AND,
    AST_BINOPTYPE_TYPE_OR,
    AST_BINOPTYPE_TYPE_XOR,
    AST_BINOPTYPE_TYPE_EQ,
    AST_BINOPTYPE_TYPE_NE,
    AST_BINOPTYPE_TYPE_GT,
    AST_BINOPTYPE_TYPE_LT,
    AST_BINOPTYPE_TYPE_GE,
    AST_BINOPTYPE_TYPE_LE,
    AST_BINOPTYPE_TYPE_CONS,
    AST_BINOPTYPE_TYPE_APPEND,
    AST_BINOPTYPE_TYPE_ADD,
    AST_BINOPTYPE_TYPE_SUB,
    AST_BINOPTYPE_TYPE_MUL,
    AST_BINOPTYPE_TYPE_DIV,
    AST_BINOPTYPE_TYPE_MOD,
    AST_BINOPTYPE_TYPE_POW,
    AST_BINOPTYPE_TYPE_DOT,
} AstBinOpType;

typedef enum AstSymbolType {
    AST_SYMBOLTYPE_TYPE_SYMBOL,
    AST_SYMBOLTYPE_TYPE_TYPESYMBOL,
} AstSymbolType;

typedef enum AstDefinitionType {
    AST_DEFINITION_TYPE_DEFINE,
    AST_DEFINITION_TYPE_PROTOTYPE,
    AST_DEFINITION_TYPE_LOAD,
    AST_DEFINITION_TYPE_TYPEDEF,
} AstDefinitionType;

typedef enum AstSinglePrototypeType {
    AST_SINGLEPROTOTYPE_TYPE_SYMBOLTYPE,
    AST_SINGLEPROTOTYPE_TYPE_PROTOTYPE,
} AstSinglePrototypeType;

typedef enum AstTypeClauseType {
    AST_TYPECLAUSE_TYPE_INTEGER,
    AST_TYPECLAUSE_TYPE_CHARACTER,
    AST_TYPECLAUSE_TYPE_BOOLEAN,
    AST_TYPECLAUSE_TYPE_STRING,
    AST_TYPECLAUSE_TYPE_LIST,
    AST_TYPECLAUSE_TYPE_TYPE,
    AST_TYPECLAUSE_TYPE_TYPESYMBOL,
    AST_TYPECLAUSE_TYPE_VAR,
    AST_TYPECLAUSE_TYPE_TYPECONSTRUCTOR,
} AstTypeClauseType;

typedef enum AstFunType {
    AST_FUN_TYPE_FUNCTION,
    AST_FUN_TYPE_COMPOSITEFUNCTION,
} AstFunType;

typedef enum AstArgType {
    AST_ARG_TYPE_WILDCARD,
    AST_ARG_TYPE_SYMBOL,
    AST_ARG_TYPE_CONS,
    AST_ARG_TYPE_NAMED,
    AST_ARG_TYPE_LIST,
    AST_ARG_TYPE_ENV,
    AST_ARG_TYPE_UNPACK,
    AST_ARG_TYPE_NUMBER,
    AST_ARG_TYPE_STRING,
    AST_ARG_TYPE_CHARACTER,
    AST_ARG_TYPE_YES,
    AST_ARG_TYPE_NO,
} AstArgType;

typedef enum AstExpressionType {
    AST_EXPRESSION_TYPE_BACK,
    AST_EXPRESSION_TYPE_BINOP,
    AST_EXPRESSION_TYPE_NOT,
    AST_EXPRESSION_TYPE_NEGATE,
    AST_EXPRESSION_TYPE_HERE,
    AST_EXPRESSION_TYPE_FUNCALL,
    AST_EXPRESSION_TYPE_SYMBOL,
    AST_EXPRESSION_TYPE_NUMBER,
    AST_EXPRESSION_TYPE_STRING,
    AST_EXPRESSION_TYPE_CHARACTER,
    AST_EXPRESSION_TYPE_YES,
    AST_EXPRESSION_TYPE_NO,
    AST_EXPRESSION_TYPE_LIST,
    AST_EXPRESSION_TYPE_FUN,
    AST_EXPRESSION_TYPE_ENV,
    AST_EXPRESSION_TYPE_CONDITIONAL,
    AST_EXPRESSION_TYPE_SWITCHSTATEMENT,
} AstExpressionType;



typedef union AstDefinitionVal {
    struct AstDefine * define;
    struct AstPrototype * prototype;
    struct AstLoad * load;
    struct AstTypeDef * typeDef;
} AstDefinitionVal;

typedef union AstSinglePrototypeVal {
    struct AstPrototypeSymbolType * symbolType;
    struct AstPrototype * prototype;
} AstSinglePrototypeVal;

typedef union AstTypeClauseVal {
    void * integer;
    void * character;
    void * boolean;
    void * string;
    struct AstType * list;
    struct AstType * type;
    struct AstSymbol * typeSymbol;
    struct AstSymbol * var;
    struct AstTypeConstructor * typeconstructor;
} AstTypeClauseVal;

typedef union AstFunVal {
    struct AstFunction * function;
    struct AstCompositeFunction * compositeFunction;
} AstFunVal;

typedef union AstArgVal {
    void * wildcard;
    struct AstSymbol * symbol;
    struct AstArgPair * cons;
    struct AstNamedArg * named;
    struct AstArgList * list;
    struct AstEnvType * env;
    struct AstUnpack * unpack;
    int number;
    struct AstString * string;
    char character;
    void * yes;
    void * no;
} AstArgVal;

typedef union AstExpressionVal {
    void * back;
    struct AstBinOp * binOp;
    struct AstExpression * not;
    struct AstExpression * negate;
    struct AstExpression * here;
    struct AstFunCall * funCall;
    struct AstSymbol * symbol;
    int number;
    struct AstString * string;
    char character;
    void * yes;
    void * no;
    struct AstExpressions * list;
    struct AstFun * fun;
    struct AstEnv * env;
    struct AstConditional * conditional;
    struct AstSwitch * switchStatement;
} AstExpressionVal;



typedef struct AstNest {
    Header header;
    struct AstDefinitions * definitions;
    struct AstExpressions * expressions;
} AstNest;

typedef struct AstDefinitions {
    Header header;
    struct AstDefinitions * next;
    struct AstDefinition * definition;
} AstDefinitions;

typedef struct AstDefine {
    Header header;
    struct AstSymbol * symbol;
    struct AstExpression * expression;
} AstDefine;

typedef struct AstPrototype {
    Header header;
    struct AstSymbol * symbol;
    struct AstPrototypeBody * body;
} AstPrototype;

typedef struct AstPrototypeBody {
    Header header;
    struct AstPrototypeBody * next;
    struct AstSinglePrototype * single;
} AstPrototypeBody;

typedef struct AstPrototypeSymbolType {
    Header header;
    struct AstSymbol * symbol;
    struct AstType * type;
} AstPrototypeSymbolType;

typedef struct AstLoad {
    Header header;
    struct AstPackage * package;
    struct AstSymbol * symbol;
} AstLoad;

typedef struct AstTypeDef {
    Header header;
    struct AstFlatType * flatType;
    struct AstTypeBody * typeBody;
} AstTypeDef;

typedef struct AstFlatType {
    Header header;
    struct AstSymbol * symbol;
    struct AstTypeSymbols * typeSymbols;
} AstFlatType;

typedef struct AstTypeSymbols {
    Header header;
    struct AstTypeSymbols * next;
    struct AstSymbol * typeSymbol;
} AstTypeSymbols;

typedef struct AstTypeBody {
    Header header;
    struct AstTypeBody * next;
    struct AstTypeConstructor * typeConstructor;
} AstTypeBody;

typedef struct AstTypeConstructor {
    Header header;
    struct AstSymbol * symbol;
    struct AstTypeList * typeList;
} AstTypeConstructor;

typedef struct AstTypeList {
    Header header;
    struct AstTypeList * next;
    struct AstType * type;
} AstTypeList;

typedef struct AstType {
    Header header;
    struct AstType * next;
    struct AstTypeClause * typeClause;
} AstType;

typedef struct AstConditional {
    Header header;
    struct AstExpression * expression;
    struct AstNest * consequent;
    struct AstNest * alternative;
} AstConditional;

typedef struct AstSwitch {
    Header header;
    struct AstExpressions * expressions;
    struct AstCompositeFunction * compositeFunction;
} AstSwitch;

typedef struct AstCompositeFunction {
    Header header;
    struct AstCompositeFunction * next;
    struct AstFunction * function;
} AstCompositeFunction;

typedef struct AstFunction {
    Header header;
    struct AstArgList * argList;
    struct AstNest * nest;
} AstFunction;

typedef struct AstArgList {
    Header header;
    struct AstArgList * next;
    struct AstArg * arg;
} AstArgList;

typedef struct AstUnpack {
    Header header;
    struct AstSymbol * symbol;
    struct AstArgList * argList;
} AstUnpack;

typedef struct AstArgPair {
    Header header;
    struct AstArg * car;
    struct AstArg * cdr;
} AstArgPair;

typedef struct AstNamedArg {
    Header header;
    struct AstSymbol * name;
    struct AstArg * arg;
} AstNamedArg;

typedef struct AstEnvType {
    Header header;
    struct AstSymbol * name;
    struct AstSymbol * prototype;
} AstEnvType;

typedef struct AstBinOp {
    Header header;
    enum AstBinOpType  type;
    struct AstExpression * lhs;
    struct AstExpression * rhs;
} AstBinOp;

typedef struct AstFunCall {
    Header header;
    struct AstExpression * function;
    struct AstExpressions * arguments;
} AstFunCall;

typedef struct AstPackage {
    Header header;
    struct AstPackage * next;
    struct AstSymbol * symbol;
} AstPackage;

typedef struct AstExpressions {
    Header header;
    struct AstExpressions * next;
    struct AstExpression * expression;
} AstExpressions;

typedef struct AstEnv {
    Header header;
    struct AstPackage * package;
    struct AstDefinitions * definitions;
} AstEnv;

typedef struct AstSymbol {
    Header header;
    enum AstSymbolType  type;
    hash_t hash;
    char * name;
} AstSymbol;

typedef struct AstString {
    Header header;
    char * string;
} AstString;

typedef struct AstDefinition {
    Header header;
    enum AstDefinitionType  type;
    union AstDefinitionVal  val;
} AstDefinition;

typedef struct AstSinglePrototype {
    Header header;
    enum AstSinglePrototypeType  type;
    union AstSinglePrototypeVal  val;
} AstSinglePrototype;

typedef struct AstTypeClause {
    Header header;
    enum AstTypeClauseType  type;
    union AstTypeClauseVal  val;
} AstTypeClause;

typedef struct AstFun {
    Header header;
    enum AstFunType  type;
    union AstFunVal  val;
} AstFun;

typedef struct AstArg {
    Header header;
    enum AstArgType  type;
    union AstArgVal  val;
} AstArg;

typedef struct AstExpression {
    Header header;
    enum AstExpressionType  type;
    union AstExpressionVal  val;
} AstExpression;

struct AstNest * newAstNest(struct AstDefinitions * definitions, struct AstExpressions * expressions);
struct AstDefinitions * newAstDefinitions(struct AstDefinitions * next, struct AstDefinition * definition);
struct AstDefine * newAstDefine(struct AstSymbol * symbol, struct AstExpression * expression);
struct AstPrototype * newAstPrototype(struct AstSymbol * symbol, struct AstPrototypeBody * body);
struct AstPrototypeBody * newAstPrototypeBody(struct AstPrototypeBody * next, struct AstSinglePrototype * single);
struct AstPrototypeSymbolType * newAstPrototypeSymbolType(struct AstSymbol * symbol, struct AstType * type);
struct AstLoad * newAstLoad(struct AstPackage * package, struct AstSymbol * symbol);
struct AstTypeDef * newAstTypeDef(struct AstFlatType * flatType, struct AstTypeBody * typeBody);
struct AstFlatType * newAstFlatType(struct AstSymbol * symbol, struct AstTypeSymbols * typeSymbols);
struct AstTypeSymbols * newAstTypeSymbols(struct AstTypeSymbols * next, struct AstSymbol * typeSymbol);
struct AstTypeBody * newAstTypeBody(struct AstTypeBody * next, struct AstTypeConstructor * typeConstructor);
struct AstTypeConstructor * newAstTypeConstructor(struct AstSymbol * symbol, struct AstTypeList * typeList);
struct AstTypeList * newAstTypeList(struct AstTypeList * next, struct AstType * type);
struct AstType * newAstType(struct AstType * next, struct AstTypeClause * typeClause);
struct AstConditional * newAstConditional(struct AstExpression * expression, struct AstNest * consequent, struct AstNest * alternative);
struct AstSwitch * newAstSwitch(struct AstExpressions * expressions, struct AstCompositeFunction * compositeFunction);
struct AstCompositeFunction * newAstCompositeFunction(struct AstCompositeFunction * next, struct AstFunction * function);
struct AstFunction * newAstFunction(struct AstArgList * argList, struct AstNest * nest);
struct AstArgList * newAstArgList(struct AstArgList * next, struct AstArg * arg);
struct AstUnpack * newAstUnpack(struct AstSymbol * symbol, struct AstArgList * argList);
struct AstArgPair * newAstArgPair(struct AstArg * car, struct AstArg * cdr);
struct AstNamedArg * newAstNamedArg(struct AstSymbol * name, struct AstArg * arg);
struct AstEnvType * newAstEnvType(struct AstSymbol * name, struct AstSymbol * prototype);
struct AstBinOp * newAstBinOp(enum AstBinOpType  type, struct AstExpression * lhs, struct AstExpression * rhs);
struct AstFunCall * newAstFunCall(struct AstExpression * function, struct AstExpressions * arguments);
struct AstPackage * newAstPackage(struct AstPackage * next, struct AstSymbol * symbol);
struct AstExpressions * newAstExpressions(struct AstExpressions * next, struct AstExpression * expression);
struct AstEnv * newAstEnv(struct AstPackage * package, struct AstDefinitions * definitions);
struct AstSymbol * newAstSymbol(enum AstSymbolType  type, hash_t hash, char * name);
struct AstString * newAstString(char * string);
struct AstDefinition * newAstDefinition(enum AstDefinitionType  type, union AstDefinitionVal  val);
struct AstSinglePrototype * newAstSinglePrototype(enum AstSinglePrototypeType  type, union AstSinglePrototypeVal  val);
struct AstTypeClause * newAstTypeClause(enum AstTypeClauseType  type, union AstTypeClauseVal  val);
struct AstFun * newAstFun(enum AstFunType  type, union AstFunVal  val);
struct AstArg * newAstArg(enum AstArgType  type, union AstArgVal  val);
struct AstExpression * newAstExpression(enum AstExpressionType  type, union AstExpressionVal  val);

void markAstNest(struct AstNest * x);
void markAstDefinitions(struct AstDefinitions * x);
void markAstDefine(struct AstDefine * x);
void markAstPrototype(struct AstPrototype * x);
void markAstPrototypeBody(struct AstPrototypeBody * x);
void markAstPrototypeSymbolType(struct AstPrototypeSymbolType * x);
void markAstLoad(struct AstLoad * x);
void markAstTypeDef(struct AstTypeDef * x);
void markAstFlatType(struct AstFlatType * x);
void markAstTypeSymbols(struct AstTypeSymbols * x);
void markAstTypeBody(struct AstTypeBody * x);
void markAstTypeConstructor(struct AstTypeConstructor * x);
void markAstTypeList(struct AstTypeList * x);
void markAstType(struct AstType * x);
void markAstConditional(struct AstConditional * x);
void markAstSwitch(struct AstSwitch * x);
void markAstCompositeFunction(struct AstCompositeFunction * x);
void markAstFunction(struct AstFunction * x);
void markAstArgList(struct AstArgList * x);
void markAstUnpack(struct AstUnpack * x);
void markAstArgPair(struct AstArgPair * x);
void markAstNamedArg(struct AstNamedArg * x);
void markAstEnvType(struct AstEnvType * x);
void markAstBinOp(struct AstBinOp * x);
void markAstFunCall(struct AstFunCall * x);
void markAstPackage(struct AstPackage * x);
void markAstExpressions(struct AstExpressions * x);
void markAstEnv(struct AstEnv * x);
void markAstSymbol(struct AstSymbol * x);
void markAstString(struct AstString * x);
void markAstDefinition(struct AstDefinition * x);
void markAstSinglePrototype(struct AstSinglePrototype * x);
void markAstTypeClause(struct AstTypeClause * x);
void markAstFun(struct AstFun * x);
void markAstArg(struct AstArg * x);
void markAstExpression(struct AstExpression * x);

#define AST_DEFINITION_VAL_DEFINE(x) ((union AstDefinitionVal ){.define = (x)})
#define AST_DEFINITION_VAL_PROTOTYPE(x) ((union AstDefinitionVal ){.prototype = (x)})
#define AST_DEFINITION_VAL_LOAD(x) ((union AstDefinitionVal ){.load = (x)})
#define AST_DEFINITION_VAL_TYPEDEF(x) ((union AstDefinitionVal ){.typeDef = (x)})
#define AST_SINGLEPROTOTYPE_VAL_SYMBOLTYPE(x) ((union AstSinglePrototypeVal ){.symbolType = (x)})
#define AST_SINGLEPROTOTYPE_VAL_PROTOTYPE(x) ((union AstSinglePrototypeVal ){.prototype = (x)})
#define AST_TYPECLAUSE_VAL_INTEGER() ((union AstTypeClauseVal ){.integer = (NULL)})
#define AST_TYPECLAUSE_VAL_CHARACTER() ((union AstTypeClauseVal ){.character = (NULL)})
#define AST_TYPECLAUSE_VAL_BOOLEAN() ((union AstTypeClauseVal ){.boolean = (NULL)})
#define AST_TYPECLAUSE_VAL_STRING() ((union AstTypeClauseVal ){.string = (NULL)})
#define AST_TYPECLAUSE_VAL_LIST(x) ((union AstTypeClauseVal ){.list = (x)})
#define AST_TYPECLAUSE_VAL_TYPE(x) ((union AstTypeClauseVal ){.type = (x)})
#define AST_TYPECLAUSE_VAL_TYPESYMBOL(x) ((union AstTypeClauseVal ){.typeSymbol = (x)})
#define AST_TYPECLAUSE_VAL_VAR(x) ((union AstTypeClauseVal ){.var = (x)})
#define AST_TYPECLAUSE_VAL_TYPECONSTRUCTOR(x) ((union AstTypeClauseVal ){.typeconstructor = (x)})
#define AST_FUN_VAL_FUNCTION(x) ((union AstFunVal ){.function = (x)})
#define AST_FUN_VAL_COMPOSITEFUNCTION(x) ((union AstFunVal ){.compositeFunction = (x)})
#define AST_ARG_VAL_WILDCARD() ((union AstArgVal ){.wildcard = (NULL)})
#define AST_ARG_VAL_SYMBOL(x) ((union AstArgVal ){.symbol = (x)})
#define AST_ARG_VAL_CONS(x) ((union AstArgVal ){.cons = (x)})
#define AST_ARG_VAL_NAMED(x) ((union AstArgVal ){.named = (x)})
#define AST_ARG_VAL_LIST(x) ((union AstArgVal ){.list = (x)})
#define AST_ARG_VAL_ENV(x) ((union AstArgVal ){.env = (x)})
#define AST_ARG_VAL_UNPACK(x) ((union AstArgVal ){.unpack = (x)})
#define AST_ARG_VAL_NUMBER(x) ((union AstArgVal ){.number = (x)})
#define AST_ARG_VAL_STRING(x) ((union AstArgVal ){.string = (x)})
#define AST_ARG_VAL_CHARACTER(x) ((union AstArgVal ){.character = (x)})
#define AST_ARG_VAL_YES() ((union AstArgVal ){.yes = (NULL)})
#define AST_ARG_VAL_NO() ((union AstArgVal ){.no = (NULL)})
#define AST_EXPRESSION_VAL_BACK() ((union AstExpressionVal ){.back = (NULL)})
#define AST_EXPRESSION_VAL_BINOP(x) ((union AstExpressionVal ){.binOp = (x)})
#define AST_EXPRESSION_VAL_NOT(x) ((union AstExpressionVal ){.not = (x)})
#define AST_EXPRESSION_VAL_NEGATE(x) ((union AstExpressionVal ){.negate = (x)})
#define AST_EXPRESSION_VAL_HERE(x) ((union AstExpressionVal ){.here = (x)})
#define AST_EXPRESSION_VAL_FUNCALL(x) ((union AstExpressionVal ){.funCall = (x)})
#define AST_EXPRESSION_VAL_SYMBOL(x) ((union AstExpressionVal ){.symbol = (x)})
#define AST_EXPRESSION_VAL_NUMBER(x) ((union AstExpressionVal ){.number = (x)})
#define AST_EXPRESSION_VAL_STRING(x) ((union AstExpressionVal ){.string = (x)})
#define AST_EXPRESSION_VAL_CHARACTER(x) ((union AstExpressionVal ){.character = (x)})
#define AST_EXPRESSION_VAL_YES() ((union AstExpressionVal ){.yes = (NULL)})
#define AST_EXPRESSION_VAL_NO() ((union AstExpressionVal ){.no = (NULL)})
#define AST_EXPRESSION_VAL_LIST(x) ((union AstExpressionVal ){.list = (x)})
#define AST_EXPRESSION_VAL_FUN(x) ((union AstExpressionVal ){.fun = (x)})
#define AST_EXPRESSION_VAL_ENV(x) ((union AstExpressionVal ){.env = (x)})
#define AST_EXPRESSION_VAL_CONDITIONAL(x) ((union AstExpressionVal ){.conditional = (x)})
#define AST_EXPRESSION_VAL_SWITCHSTATEMENT(x) ((union AstExpressionVal ){.switchStatement = (x)})

#endif
