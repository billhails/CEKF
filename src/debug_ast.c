/*
 * CEKF - VM supporting amb
 * Copyright (C) 2022-2023  Bill Hails
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Abstract Syntax Tree structures generated by the parser.
 *
 * generated from src/ast.yaml by makeAST.py
 */

#include <stdio.h>

#include "debug_ast.h"

static void pad(int depth) { fprintf(stderr, "%*s", depth * 4, ""); }

void printAstNest(struct AstNest * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstNest (NULL)"); return; }
    fprintf(stderr, "AstNest[\n");
    printAstDefinitions(x->definitions, depth + 1);
    fprintf(stderr, "\n");
    printAstExpressions(x->expressions, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstDefinitions(struct AstDefinitions * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstDefinitions (NULL)"); return; }
    fprintf(stderr, "AstDefinitions[\n");
    printAstDefinition(x->definition, depth + 1);
    fprintf(stderr, "\n");
    printAstDefinitions(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstDefine(struct AstDefine * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstDefine (NULL)"); return; }
    fprintf(stderr, "AstDefine[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstExpression(x->expression, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstPrototype(struct AstPrototype * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstPrototype (NULL)"); return; }
    fprintf(stderr, "AstPrototype[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstPrototypeBody(x->body, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstPrototypeBody(struct AstPrototypeBody * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstPrototypeBody (NULL)"); return; }
    fprintf(stderr, "AstPrototypeBody[\n");
    printAstSinglePrototype(x->single, depth + 1);
    fprintf(stderr, "\n");
    printAstPrototypeBody(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstPrototypeSymbolType(struct AstPrototypeSymbolType * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstPrototypeSymbolType (NULL)"); return; }
    fprintf(stderr, "AstPrototypeSymbolType[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstType(x->type, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstLoad(struct AstLoad * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstLoad (NULL)"); return; }
    fprintf(stderr, "AstLoad[\n");
    printAstPackage(x->package, depth + 1);
    fprintf(stderr, "\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstTypeDef(struct AstTypeDef * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstTypeDef (NULL)"); return; }
    fprintf(stderr, "AstTypeDef[\n");
    printAstFlatType(x->flatType, depth + 1);
    fprintf(stderr, "\n");
    printAstTypeBody(x->typeBody, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstFlatType(struct AstFlatType * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstFlatType (NULL)"); return; }
    fprintf(stderr, "AstFlatType[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstTypeSymbols(x->typeSymbols, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstTypeSymbols(struct AstTypeSymbols * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstTypeSymbols (NULL)"); return; }
    fprintf(stderr, "AstTypeSymbols[\n");
        printAstSymbol(x->typeSymbol, depth + 1);
    fprintf(stderr, "\n");
    printAstTypeSymbols(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstTypeBody(struct AstTypeBody * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstTypeBody (NULL)"); return; }
    fprintf(stderr, "AstTypeBody[\n");
    printAstTypeConstructor(x->typeConstructor, depth + 1);
    fprintf(stderr, "\n");
    printAstTypeBody(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstTypeConstructor(struct AstTypeConstructor * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstTypeConstructor (NULL)"); return; }
    fprintf(stderr, "AstTypeConstructor[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstTypeList(x->typeList, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstTypeFunction(struct AstTypeFunction * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstTypeFunction (NULL)"); return; }
    fprintf(stderr, "AstTypeFunction[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstTypeList(x->typeList, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstTypeList(struct AstTypeList * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstTypeList (NULL)"); return; }
    fprintf(stderr, "AstTypeList[\n");
    printAstType(x->type, depth + 1);
    fprintf(stderr, "\n");
    printAstTypeList(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstType(struct AstType * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstType (NULL)"); return; }
    fprintf(stderr, "AstType[\n");
    printAstTypeClause(x->typeClause, depth + 1);
    fprintf(stderr, "\n");
    printAstType(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstCompositeFunction(struct AstCompositeFunction * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstCompositeFunction (NULL)"); return; }
    fprintf(stderr, "AstCompositeFunction[\n");
    printAstFunction(x->function, depth + 1);
    fprintf(stderr, "\n");
    printAstCompositeFunction(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstFunction(struct AstFunction * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstFunction (NULL)"); return; }
    fprintf(stderr, "AstFunction[\n");
    printAstArgList(x->argList, depth + 1);
    fprintf(stderr, "\n");
    printAstNest(x->nest, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstArgList(struct AstArgList * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstArgList (NULL)"); return; }
    fprintf(stderr, "AstArgList[\n");
    printAstArg(x->arg, depth + 1);
    fprintf(stderr, "\n");
    printAstArgList(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstUnpack(struct AstUnpack * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstUnpack (NULL)"); return; }
    fprintf(stderr, "AstUnpack[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstArgList(x->argList, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstNamedArg(struct AstNamedArg * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstNamedArg (NULL)"); return; }
    fprintf(stderr, "AstNamedArg[\n");
        printAstSymbol(x->name, depth + 1);
    fprintf(stderr, "\n");
    printAstArg(x->arg, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstEnvType(struct AstEnvType * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstEnvType (NULL)"); return; }
    fprintf(stderr, "AstEnvType[\n");
        printAstSymbol(x->name, depth + 1);
    fprintf(stderr, "\n");
        printAstSymbol(x->prototype, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstFunCall(struct AstFunCall * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstFunCall (NULL)"); return; }
    fprintf(stderr, "AstFunCall[\n");
    printAstExpression(x->function, depth + 1);
    fprintf(stderr, "\n");
    printAstExpressions(x->arguments, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstPackage(struct AstPackage * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstPackage (NULL)"); return; }
    fprintf(stderr, "AstPackage[\n");
        printAstSymbol(x->symbol, depth + 1);
    fprintf(stderr, "\n");
    printAstPackage(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstExpressions(struct AstExpressions * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstExpressions (NULL)"); return; }
    fprintf(stderr, "AstExpressions[\n");
    printAstExpression(x->expression, depth + 1);
    fprintf(stderr, "\n");
    printAstExpressions(x->next, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstEnv(struct AstEnv * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstEnv (NULL)"); return; }
    fprintf(stderr, "AstEnv[\n");
    printAstPackage(x->package, depth + 1);
    fprintf(stderr, "\n");
    printAstDefinitions(x->definitions, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstIff(struct AstIff * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstIff (NULL)"); return; }
    fprintf(stderr, "AstIff[\n");
    printAstExpression(x->test, depth + 1);
    fprintf(stderr, "\n");
    printAstNest(x->consequent, depth + 1);
    fprintf(stderr, "\n");
    printAstNest(x->alternative, depth + 1);
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstDefinition(struct AstDefinition * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstDefinition (NULL)"); return; }
    fprintf(stderr, "AstDefinition[\n");
    switch(x->type) {
        case AST_DEFINITION_TYPE_DEFINE:
            pad(depth + 1);
            fprintf(stderr, "AST_DEFINITION_TYPE_DEFINE\n");
            printAstDefine(x->val.define, depth + 1);
            break;
        case AST_DEFINITION_TYPE_PROTOTYPE:
            pad(depth + 1);
            fprintf(stderr, "AST_DEFINITION_TYPE_PROTOTYPE\n");
            printAstPrototype(x->val.prototype, depth + 1);
            break;
        case AST_DEFINITION_TYPE_LOAD:
            pad(depth + 1);
            fprintf(stderr, "AST_DEFINITION_TYPE_LOAD\n");
            printAstLoad(x->val.load, depth + 1);
            break;
        case AST_DEFINITION_TYPE_TYPEDEF:
            pad(depth + 1);
            fprintf(stderr, "AST_DEFINITION_TYPE_TYPEDEF\n");
            printAstTypeDef(x->val.typeDef, depth + 1);
            break;
        default:
            cant_happen("unrecognised type %d in printAstDefinition", x->type);
    }
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstSinglePrototype(struct AstSinglePrototype * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstSinglePrototype (NULL)"); return; }
    fprintf(stderr, "AstSinglePrototype[\n");
    switch(x->type) {
        case AST_SINGLEPROTOTYPE_TYPE_SYMBOLTYPE:
            pad(depth + 1);
            fprintf(stderr, "AST_SINGLEPROTOTYPE_TYPE_SYMBOLTYPE\n");
            printAstPrototypeSymbolType(x->val.symbolType, depth + 1);
            break;
        case AST_SINGLEPROTOTYPE_TYPE_PROTOTYPE:
            pad(depth + 1);
            fprintf(stderr, "AST_SINGLEPROTOTYPE_TYPE_PROTOTYPE\n");
            printAstPrototype(x->val.prototype, depth + 1);
            break;
        default:
            cant_happen("unrecognised type %d in printAstSinglePrototype", x->type);
    }
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstTypeClause(struct AstTypeClause * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstTypeClause (NULL)"); return; }
    fprintf(stderr, "AstTypeClause[\n");
    switch(x->type) {
        case AST_TYPECLAUSE_TYPE_INTEGER:
            pad(depth + 1);
            fprintf(stderr, "AST_TYPECLAUSE_TYPE_INTEGER\n");
                        pad(depth + 1);
fprintf(stderr, "void * %p", x->val.integer);
            break;
        case AST_TYPECLAUSE_TYPE_CHARACTER:
            pad(depth + 1);
            fprintf(stderr, "AST_TYPECLAUSE_TYPE_CHARACTER\n");
                        pad(depth + 1);
fprintf(stderr, "void * %p", x->val.character);
            break;
        case AST_TYPECLAUSE_TYPE_VAR:
            pad(depth + 1);
            fprintf(stderr, "AST_TYPECLAUSE_TYPE_VAR\n");
                        printAstSymbol(x->val.var, depth + 1);
            break;
        case AST_TYPECLAUSE_TYPE_TYPEFUNCTION:
            pad(depth + 1);
            fprintf(stderr, "AST_TYPECLAUSE_TYPE_TYPEFUNCTION\n");
            printAstTypeFunction(x->val.typeFunction, depth + 1);
            break;
        default:
            cant_happen("unrecognised type %d in printAstTypeClause", x->type);
    }
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstArg(struct AstArg * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstArg (NULL)"); return; }
    fprintf(stderr, "AstArg[\n");
    switch(x->type) {
        case AST_ARG_TYPE_WILDCARD:
            pad(depth + 1);
            fprintf(stderr, "AST_ARG_TYPE_WILDCARD\n");
                        pad(depth + 1);
fprintf(stderr, "void * %p", x->val.wildcard);
            break;
        case AST_ARG_TYPE_SYMBOL:
            pad(depth + 1);
            fprintf(stderr, "AST_ARG_TYPE_SYMBOL\n");
                        printAstSymbol(x->val.symbol, depth + 1);
            break;
        case AST_ARG_TYPE_NAMED:
            pad(depth + 1);
            fprintf(stderr, "AST_ARG_TYPE_NAMED\n");
            printAstNamedArg(x->val.named, depth + 1);
            break;
        case AST_ARG_TYPE_ENV:
            pad(depth + 1);
            fprintf(stderr, "AST_ARG_TYPE_ENV\n");
            printAstEnvType(x->val.env, depth + 1);
            break;
        case AST_ARG_TYPE_UNPACK:
            pad(depth + 1);
            fprintf(stderr, "AST_ARG_TYPE_UNPACK\n");
            printAstUnpack(x->val.unpack, depth + 1);
            break;
        case AST_ARG_TYPE_NUMBER:
            pad(depth + 1);
            fprintf(stderr, "AST_ARG_TYPE_NUMBER\n");
                        pad(depth + 1);
fprintf(stderr, "int %d", x->val.number);
            break;
        case AST_ARG_TYPE_CHARACTER:
            pad(depth + 1);
            fprintf(stderr, "AST_ARG_TYPE_CHARACTER\n");
                        pad(depth + 1);
fprintf(stderr, "char %c", x->val.character);
            break;
        default:
            cant_happen("unrecognised type %d in printAstArg", x->type);
    }
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

void printAstExpression(struct AstExpression * x, int depth) {
    pad(depth);
    if (x == NULL) { fprintf(stderr, "AstExpression (NULL)"); return; }
    fprintf(stderr, "AstExpression[\n");
    switch(x->type) {
        case AST_EXPRESSION_TYPE_BACK:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_BACK\n");
                        pad(depth + 1);
fprintf(stderr, "void * %p", x->val.back);
            break;
        case AST_EXPRESSION_TYPE_FUNCALL:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_FUNCALL\n");
            printAstFunCall(x->val.funCall, depth + 1);
            break;
        case AST_EXPRESSION_TYPE_SYMBOL:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_SYMBOL\n");
                        printAstSymbol(x->val.symbol, depth + 1);
            break;
        case AST_EXPRESSION_TYPE_NUMBER:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_NUMBER\n");
                        pad(depth + 1);
fprintf(stderr, "int %d", x->val.number);
            break;
        case AST_EXPRESSION_TYPE_CHARACTER:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_CHARACTER\n");
                        pad(depth + 1);
fprintf(stderr, "char %c", x->val.character);
            break;
        case AST_EXPRESSION_TYPE_FUN:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_FUN\n");
            printAstCompositeFunction(x->val.fun, depth + 1);
            break;
        case AST_EXPRESSION_TYPE_ENV:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_ENV\n");
            printAstEnv(x->val.env, depth + 1);
            break;
        case AST_EXPRESSION_TYPE_NEST:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_NEST\n");
            printAstNest(x->val.nest, depth + 1);
            break;
        case AST_EXPRESSION_TYPE_IFF:
            pad(depth + 1);
            fprintf(stderr, "AST_EXPRESSION_TYPE_IFF\n");
            printAstIff(x->val.iff, depth + 1);
            break;
        default:
            cant_happen("unrecognised type %d in printAstExpression", x->type);
    }
    fprintf(stderr, "\n");
    pad(depth);
    fprintf(stderr, "]");
}

