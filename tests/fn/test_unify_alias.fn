let
    // Case A: variable first, then assignment (x, x=1)
    fn test_case_a {
        (x, x=1) { true }
        (_, _) { false }
    }
    
    // Case B: assignment first, then variable (x=1, x)
    fn test_case_b {
        (x=1, x) { true }
        (_, _) { false }
    }
    
    // Test with different types
    fn test_char {
        (x='a', x) { true }
        (_, _) { false }
    }
    
    // Test with any list value (no specific pattern constraint)
    fn test_list {
        (x=l, x) { true }
        (_, _) { false }
    }
    
    // Test with cons pattern constraint
    fn test_cons {
        (x=h@t, x) { true }
        (_, _) { false }
    }
    
    // Test Case A with character literals
    fn test_case_a_char {
        (x, x='b') { true }
        (_, _) { false }
    }
    
    // Test Case A with constructor patterns
    fn test_case_a_cons {
        (x, x=h@t) { true }
        (_, _) { false }
    }
    
    // Test mixed patterns: both Case A and Case B in same function
    fn test_mixed {
        (x=1, x, y, y=2) { true }  // Case B, then Case A
        (_, _, _, _) { false }
    }
in
    // Case A tests: variable first, then assignment
    assert(test_case_a(1, 1) == true);
    assert(test_case_a(1, 2) == false);
    assert(test_case_a(2, 1) == false);
    
    assert(test_case_a_char('b', 'b') == true);
    assert(test_case_a_char('a', 'b') == false);
    assert(test_case_a_char('b', 'a') == false);
    
    assert(test_case_a_cons([1, 2], [1, 2]) == true);
    assert(test_case_a_cons([1], [1]) == true);
    assert(test_case_a_cons([], []) == false);  // not a cons
    assert(test_case_a_cons([1], [2]) == false);
    
    // Mixed Case A and Case B
    assert(test_mixed(1, 1, 2, 2) == true);
    assert(test_mixed(1, 1, 2, 3) == false);
    assert(test_mixed(1, 2, 2, 2) == false);
    
    // Case B tests: assignment first, then variable
    assert(test_case_b(1, 1) == true);
    assert(test_case_b(1, 2) == false);
    assert(test_case_b(2, 1) == false);
    
    assert(test_char('a', 'a') == true);
    assert(test_char('a', 'b') == false);
    
    // These pass because assignment doesn't constrain the inner pattern
    assert(test_list([], []) == true);
    assert(test_list([1], [1]) == true);
    assert(test_list([1], []) == false);
    
    // These require both args to be cons cells and equal
    assert(test_cons([1, 2], [1, 2]) == true);
    assert(test_cons([1], [2]) == false);
    assert(test_cons([], []) == false);  // [] is not a cons