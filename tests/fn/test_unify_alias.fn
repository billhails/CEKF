let
    // Case B: assignment first, then variable (x=1, x)
    fn test_case_b {
        (x=1, x) { true }
        (_, _) { false }
    }
    
    // Test with different types
    fn test_char {
        (x='a', x) { true }
        (_, _) { false }
    }
    
    // Test with any list value (no specific pattern constraint)
    fn test_list {
        (x=l, x) { true }
        (_, _) { false }
    }
    
    // Test with cons pattern constraint
    fn test_cons {
        (x=h@t, x) { true }
        (_, _) { false }
    }
in
    // Case B tests: assignment first, then variable
    assert(test_case_b(1, 1) == true);
    assert(test_case_b(1, 2) == false);
    assert(test_case_b(2, 1) == false);
    
    assert(test_char('a', 'a') == true);
    assert(test_char('a', 'b') == false);
    
    // These pass because assignment doesn't constrain the inner pattern
    assert(test_list([], []) == true);
    assert(test_list([1], [1]) == true);
    assert(test_list([1], []) == false);
    
    // These require both args to be cons cells and equal
    assert(test_cons([1, 2], [1, 2]) == true);
    assert(test_cons([1], [2]) == false);
    assert(test_cons([], []) == false);  // [] is not a cons