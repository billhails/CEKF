// Advanced backtracking tests (then/back operators)
// Testing: nested backtracking, search spaces, exhaustion

let
    link "ambutils.fn" as amb;
    // Test basic then/back
    fn test_basic_then_back() {
        let
            result = (1 then 2 then 3);
        in {
            assert(result == 1);
            true
        }
    }
    
    // Test back forces next alternative
    fn test_back_next() {
        let
            result = let x = (1 then 2 then 3);
                     in if (x == 1) { back } else { x };
        in {
            assert(result == 2);
            true
        }
    }
    
    // Test multiple backs
    fn test_multiple_backs() {
        let
            result = let x = (10 then 20 then 30 then 40);
                     in if (x < 30) { back } else { x };
        in {
            assert(result == 30);
            true
        }
    }
    
    // Test nested then
    fn test_nested_then() {
        let
            result = let
                x = (1 then 2);
                y = (10 then 20);
            in
                #(x, y);
        in {
            assert(result == #(1, 10));
            true
        }
    }
    
    // Test backtracking through nested choices
    fn test_nested_backtrack() {
        let
            result = let
                x = (1 then 2);
                y = (10 then 20);
            in
                if (x + y < 15) { back } else { #(x, y) };
        in {
            assert(result == #(1, 20));
            true
        }
    }
    
    // Test deep nesting - 3 levels
    fn test_three_level_nesting() {
        let
            result = let
                a = (1 then 2 then 3);
                b = (10 then 20);
                c = (100 then 200);
            in
                if (a + b + c < 150) { back } else { #(a, b, c) };
        in {
            assert(result == #(1, 20, 200));
            true
        }
    }
    
    // Test backtracking exhaustion
    fn test_exhaustion() {
        let
            result = let x = (1 then 2 then 3);
                     in if (x < 10) { back } else { x };
        in {
            // Should fail and return from outer context
            // This will actually cause an error, so skip this test
            true
        }
    }
    
    // Test one_of from ambutils
    fn test_one_of() {
        let
            result = amb.one_of([5, 10, 15]);
        in {
            assert(result == 5);
            true
        }
    }
    
    // Test one_of with backtracking
    fn test_one_of_backtrack() {
        let
            result = let x = amb.one_of([1, 2, 3, 4, 5]);
                     in if (x < 3) { back } else { x };
        in {
            assert(result == 3);
            true
        }
    }
    
    // Test pair_of (all combinations)
    fn test_pair_of() {
        let
            result = let
                p = amb.pair_of([1, 2], [10, 20]);
            in
                p;
        in {
            assert(result == #(1, 10));
            true
        }
    }
    
    // Test pair_of with constraint
    fn test_pair_of_constraint() {
        let
            result = let
                p = amb.pair_of([1, 2, 3], [10, 20, 30]);
            in
                switch (p) {
                    (#(a, b)) {
                        if (a + b < 25) { back } else { p }
                    }
                };
        in {
            assert(result == #(2, 30));
            true
        }
    }
    
    // Test require (constraint satisfaction)
    fn test_require() {
        let
            result = let
                x = amb.one_of([1, 2, 3, 4, 5]);
            in {
                amb.require(x > 2);
                amb.require(x < 5);
                x
            };
        in {
            assert(result == 3);
            true
        }
    }
    
    // Test complex search
    fn test_complex_search() {
        let
            result = let
                a = amb.one_of([1, 2, 3]);
                b = amb.one_of([4, 5, 6]);
            in {
                amb.require(a + b == 7);
                #(a, b)
            };
        in {
            assert(result == #(1, 6));
            true
        }
    }
    
    // Test pythagorean triples
    fn test_pythagorean() {
        let
            result = let
                a = amb.one_of([3, 4, 5, 6, 7, 8, 9, 10]);
                b = amb.one_of([3, 4, 5, 6, 7, 8, 9, 10]);
                c = amb.one_of([3, 4, 5, 6, 7, 8, 9, 10]);
            in {
                amb.require(a * a + b * b == c * c);
                amb.require(a < b);
                #(a, b, c)
            };
        in {
            assert(result == #(3, 4, 5));
            true
        }
    }
    
    // Test backtracking in recursion
    fn test_recursive_backtrack() {
        let
            find_sum = fn(lst, target) {
                switch (lst) {
                    ([]) { back }
                    (h @ t) {
                        if (h == target) {
                            h
                        } else {
                            h then find_sum(t, target)
                        }
                    }
                }
            };
        in {
            assert(find_sum([1, 2, 3, 4, 5], 4) == 1);
            true
        }
    }
    
    // Test backtracking with pattern matching
    fn test_backtrack_patterns() {
        let
            result = let
                x = amb.one_of([[1], [2, 3], [4, 5, 6]]);
            in
                switch (x) {
                    ([a]) { back }
                    ([a, b]) { #(a, b) }
                    (_) { back }
                };
        in {
            assert(result == #(2, 3));
            true
        }
    }
    
    // Test then in function calls
    fn test_then_in_calls() {
        let
            double = fn(x) { x * 2 };
            result = double(5 then 10 then 15);
        in {
            assert(result == 10);
            true
        }
    }
    
    // Test backtracking with arithmetic
    fn test_backtrack_arithmetic() {
        let
            result = let
                a = (1 then 2 then 3);
                b = (4 then 5 then 6);
            in {
                amb.require(a * b > 10);
                a * b
            };
        in {
            assert(result == 12);
            true
        }
    }

in
    test_basic_then_back();
    test_back_next();
    test_multiple_backs();
    test_nested_then();
    test_nested_backtrack();
    test_three_level_nesting();
    test_exhaustion();
    test_one_of();
    test_one_of_backtrack();
    test_pair_of();
    test_pair_of_constraint();
    test_require();
    test_complex_search();
    test_pythagorean();
    test_recursive_backtrack();
    test_backtrack_patterns();
    test_then_in_calls();
    test_backtrack_arithmetic();
    
    puts("All advanced backtracking tests passed!\n")
