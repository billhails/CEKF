// Comprehensive test for hygienic operators across all fixities


let
// Test 1: Prefix operators with bare symbols
fn test_prefix_bare_symbol () {
    let
        negate = fn(x) { 0 - x };
        operator "~_" 13 negate;
    in
        assert(~5 == -5)
}

// Test 2: Prefix operators with inline functions
fn test_prefix_inline () {
    let
        fact = fn(x) { if (x == 0) { 1 } else { x * fact(x - 1) } };
        operator "bang_" 13 fact;
    in
        assert(bang 5 == 120)
}

// Test 3: Prefix operators with complex expressions
fn test_prefix_complex () {
    let
        double = fn(x) { x * 2 };
        triple = fn(f) { fn(x) { f(f(f(x))) } };
        operator "pct_" 13 triple(double);
    in
        assert(pct 3 == 24)
}

// Test 4: Prefix operators capturing variables
fn test_prefix_capture () {
    let
        offset = 10;
        in {
            let
                add_offset = fn(x) { x + offset };
                operator "incr_" 13 add_offset;
            in
                assert(incr 5 == 15)
        }
}

// Test 5: Infix operators with bare symbols
fn test_infix_bare_symbol () {
    let
        add = fn(x, y) { x + y };
        operator "_plus_" left 100 add;
    in
        assert(3 plus 4 == 7)
}

// Test 6: Infix operators with inline functions
fn test_infix_inline () {
    let
        operator "_times_" left 100 fn(x, y) { x * y };
    in
        assert(3 times 4 == 12)
}

// Test 7: Infix operators with complex expressions (curried)
fn test_infix_complex () {
    let
        make_op = fn(op) { fn(x, y) { op(x, y) } };
        mult = fn(x, y) { x * y };
        operator "_mul_" left 100 make_op(mult);
    in
        assert(3 mul 4 == 12)
}

// Test 8: Infix operators capturing variables
fn test_infix_capture () {
    let
        base = 100;
        in {
            let
                add_base = fn(x, y) { x + y + base };
                operator "_plusbase_" left 100 add_base;
            in
                assert(3 plusbase 4 == 107)
        }
}

// Test 9: Infix associativity (left)
fn test_infix_left_assoc () {
    let
        operator "_minus_" left 100 fn(x, y) { x - y };
    in
        assert(10 minus 3 minus 2 == 5)
}

// Test 10: Infix associativity (right)
fn test_infix_right_assoc () {
    let
        operator "_cons_" right 100 fn(x, y) { [x] @@ y };
    in
        assert(1 cons 2 cons [] == [1, 2])
}

// Test 11: Postfix operators with bare symbols
fn test_postfix_bare_symbol () {
    let
        fact = fn(n) { if (n == 0) { 1 } else { n * fact(n - 1) } };
        operator "_bang" 120 fact;
    in
        assert(5 bang == 120)
}

// Test 12: Postfix operators with inline functions
fn test_postfix_inline() {
    let
        operator "_squared" 120 fn(x) { x * x };
    in
        assert(5 squared == 25)
}

// Test 13: Postfix operators with complex expressions
fn test_postfix_complex () {
    let
        make_multiplier = fn(n) { fn(x) { x * n } };
        operator "_triple" 120 make_multiplier(3);
    in
        assert(5 triple == 15)
}

// Test 14: Postfix operators capturing variables
fn test_postfix_capture () {
    let
        multiplier = 4;
        in {
            let
                mult_by_var = fn(x) { x * multiplier };
                operator "_quad" 120 mult_by_var;
            in
                assert(5 quad == 20)
        }
}

// Test 15: Nested scopes (operators shadow in inner scope)
fn test_nested_scopes () {
    let
        operator "neg_" 13 fn(x) { 0 - x };
        outer = neg 5;
    in {
        let
            operator "neg_" 13 fn(x) { 0 - x - 1 };
            inner = neg 5;
        in
            assert(outer == -5 and inner == -6)
    }
}

// Test 16: Multiple operator types on same symbol (different fixities not allowed, but test separation)
fn test_operator_separation () {
    let
        operator "star_" 13 fn(x) { x * 2 };
        operator "_starstar_" left 100 fn(x, y) { x * y };
    in
        assert(star 5 == 10 and 3 starstar 4 == 12)
}

// Test 17: Type constructor @ should still work (special case concern)
fn test_type_constructors () {
    let
        list = 1 @ 2 @ 3 @ [];
    in
        assert(list == [1, 2, 3])
}

// Test 18: Shadowing restoration across nested blocks
fn test_shadow_restoration () {
    let
        // Outer definition
        operator "neg_" 13 fn(x) { 0 - x };
        a = neg 5;
    in {
        // Inner shadowing definition
        let
            operator "neg_" 13 fn(x) { 0 - x - 1 };
            b = neg 5;
        in
            assert(a == -5 and b == -6)
    };
    // After inner block, outer binding should be restored
    assert(neg 5 == -5)
}

// Test 19: Operator shadowing inside a function body
fn test_nested_function_scope () {
    let
        fn run() {
                let
                    operator "inc_" 13 fn(x) { x + 1 };
                    a = inc 5;
                in {
                    let
                        operator "inc_" 13 fn(x) { x + 2 };
                        b = inc 5;
                    in
                        assert(a == 6 and b == 7)
                };
                // After inner block, outer function-local binding restored
                assert(inc 5 == 6)
        }
    in
        run()
}
// Main test runner
fn main () {
    test_prefix_bare_symbol();
    test_prefix_inline();
    test_prefix_complex();
    test_prefix_capture();
    
    test_infix_bare_symbol();
    test_infix_inline();
    test_infix_complex();
    test_infix_capture();
    test_infix_left_assoc();
    test_infix_right_assoc();
    
    test_postfix_bare_symbol();
    test_postfix_inline();
    test_postfix_complex();
    test_postfix_capture();
    
    test_nested_scopes();
    test_operator_separation();
    test_type_constructors();
    test_shadow_restoration();
    test_nested_function_scope();

    puts("All operator hygiene tests passed!\n")
}

in main()
