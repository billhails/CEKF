// Comprehensive test of lazy function type tracking (Phases 1 & 2)
// Demonstrates:
// 1. Type system correctly tracks and displays laziness
// 2. Manual adapters work for passing macros to HOFs
// 3. Different lazy/strict type signatures

// === Macros (lazy functions) ===
let
lazy fn lazy_and(a, b) {
    a and b
}

lazy fn lazy_or(a, b) {
    a or b
}

// === Strict functions ===

fn strict_and(x, y) {
    x and y
}

fn strict_or(x, y) {
    x or y
}

// === Manual adapters (convert lazy -> strict interface) ===

fn adapt_lazy_and(x, y) {
    lazy_and(x, y)  // Macro will automatically thunk the arguments
}

fn adapt_lazy_or(x, y) {
    lazy_or(x, y)  // Macro will automatically thunk the arguments
}

// === Higher-order function ===

fn apply_binary(f, x, y) {
    f(x, y)
}
in
// === Type Display ===
assert((typeof lazy_and) == "#() -> bool -> #() -> bool -> bool");
assert((typeof lazy_or) == "#() -> bool -> #() -> bool -> bool");
assert((typeof strict_and) == "bool -> bool -> bool");
assert((typeof strict_or) == "bool -> bool -> bool");
assert((typeof adapt_lazy_and) == "bool -> bool -> bool");
assert((typeof adapt_lazy_or) == "bool -> bool -> bool");

// === Main tests ===
assert(lazy_and(true, false) == false);
assert(strict_and(true, false) == false);

assert(apply_binary(strict_or, true, false) == true);

assert(apply_binary(adapt_lazy_or, true, false) == true);

