// Test namespace and module linking
// Tests importing modules and accessing their components

let

    link "listutils.fn" as listutils;
    link "ambutils.fn" as ambutils;

    // Test: Using imported list functions
    fn test_imported_list_functions() {
        let
            list1 = [1, 2, 3, 4, 5];
            list2 = [10, 20, 30];
            
            len1 = listutils.length(list1);
            len2 = listutils.length(list2);
            
            rev1 = listutils.reverse(list1);
            
            sum1 = listutils.foldl(fn(a, b) { a + b }, 0, list1);
        in
            assert(len1 == 5);
            assert(len2 == 3);
            assert(rev1 == [5, 4, 3, 2, 1]);
            assert(sum1 == 15);
            puts("Imported list functions test passed")
    }
    
    // Test: Using map from imported module
    fn test_imported_map() {
        let
            list1 = [1, 2, 3];
            doubled = listutils.map(fn(x) { x * 2 }, list1);
            squared = listutils.map(fn(x) { x * x }, list1);
        in
            assert(doubled == [2, 4, 6]);
            assert(squared == [1, 4, 9]);
            puts("Imported map test passed")
    }
    
    // Test: Using filter from imported module
    fn test_imported_filter() {
        let
            list1 = [1, 2, 3, 4, 5, 6];
            evens = listutils.filter(fn(x) { x % 2 == 0 }, list1);
            odds = listutils.filter(fn(x) { x % 2 == 1 }, list1);
            large = listutils.filter(fn(x) { x > 3 }, list1);
        in
            assert(evens == [2, 4, 6]);
            assert(odds == [1, 3, 5]);
            assert(large == [4, 5, 6]);
            puts("Imported filter test passed")
    }
    
    // Test: Using amb utilities
    fn test_imported_amb() {
        let
            fn test_one_of() {
                let x = ambutils.one_of([1, 2, 3]);
                in
                    if (x == 2) {
                        x
                    } else {
                        back
                    }
            }
            
            result = test_one_of();
        in
            assert(result == 2);
            puts("Imported amb test passed")
    }
    
    // Test: Chaining imported functions
    fn test_chaining_imported() {
        let
            list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            
            // Filter evens, then double, then sum
            evens = listutils.filter(fn(x) { x % 2 == 0 }, list1);
            doubled = listutils.map(fn(x) { x * 2 }, evens);
            sum = listutils.foldl(fn(a, b) { a + b }, 0, doubled);
        in
            assert(evens == [2, 4, 6, 8, 10]);
            assert(doubled == [4, 8, 12, 16, 20]);
            assert(sum == 60);
            puts("Chaining imported functions test passed")
    }
    
    // Test: Nested use of imported functions
    fn test_nested_imported() {
        let
            list1 = [[1, 2], [3, 4], [5, 6]];
            
            // Flatten using nested maps
            lengths = listutils.map(fn(sublist) { listutils.length(sublist) }, list1);
            
            // Map over sublists
            doubled_lists = listutils.map(
                fn(sublist) { listutils.map(fn(x) { x * 2 }, sublist) },
                list1
            );
        in
            assert(lengths == [2, 2, 2]);
            assert(doubled_lists == [[2, 4], [6, 8], [10, 12]]);
            puts("Nested imported functions test passed")
    }
    
    // Test: Higher-order functions with imports
    fn test_higher_order_with_imports() {
        let
            fn make_adder(n) {
                fn(x) { x + n }
            }
            
            add5 = make_adder(5);
            list1 = [1, 2, 3, 4, 5];
            
            result = listutils.map(add5, list1);
        in
            assert(result == [6, 7, 8, 9, 10]);
            puts("Higher-order with imports test passed")
    }
    
    // Test: Composition with imported functions
    fn test_composition_with_imports() {
        let
            fn compose(f, g) {
                fn(x) { f(g(x)) }
            }
            
            double = fn(x) { x * 2 };
            inc = fn(x) { x + 1 };
            
            double_then_inc = compose(inc, double);
            
            list1 = [1, 2, 3];
            result = listutils.map(double_then_inc, list1);
        in
            assert(result == [3, 5, 7]);
            puts("Composition with imports test passed")
    }

    // Main test runner
    fn main() {
        test_imported_list_functions();
        test_imported_map();
        test_imported_filter();
        test_imported_amb();
        test_chaining_imported();
        test_nested_imported();
        test_higher_order_with_imports();
        test_composition_with_imports();
        puts("All namespace and linking tests completed successfully!")
    }

in
    main()
