// Tests for arithmetic operations with mixed numeric types
// Testing: bigint+float, complex operations, cross-type comparisons,
// subtraction of different types, power operations with all numeric types

let
    // Helper to create complex numbers (real + imaginary*i)
    fn complex(r, i) { r + (i * 1i) }

    // Test bigint + float = float
    fn test_bigint_plus_float() {
        let
            big = 100000;  // Smaller bigint to preserve float precision
            flt = 3.14;
            result = big + flt;
        in
            // Should be a float: 100000 + 3.14 = 100003.14
            assert(result > 100003.0);
            assert(result < 100004.0);
            true
    }

    fn test_float_plus_bigint() {
        let
            flt = 2.718;
            big = 50000;  // Smaller to preserve precision
            result = flt + big;
        in
            // 50000 + 2.718 = 50002.718
            assert(result > 50002.0);
            assert(result < 50003.0);
            true
    }

    fn test_rational_plus_float() {
        let
            rat = 1 / 3;  // Rational 1/3
            flt = 0.5;
            result = rat + flt;
        in
            // 1/3 + 0.5 ≈ 0.833...
            assert(result > 0.8);
            assert(result < 0.9);
            true
    }

    fn test_float_plus_rational() {
        let
            flt = 1.5;
            rat = 1 / 4;  // 0.25
            result = flt + rat;
        in
            // 1.5 + 0.25 = 1.75
            assert(result > 1.7);
            assert(result < 1.8);
            true
    }

    // Test complex number magnitude and angle
    fn test_com_mag_simple() {
        let
            c = complex(3, 4);  // 3+4i
            mag = com_mag(c);
        in
            // magnitude of 3+4i should be 5
            assert(mag == 5);
            true
    }

    fn test_com_mag_zero() {
        let
            c = complex(0, 0);
            mag = com_mag(c);
        in
            assert(mag == 0);
            true
    }

    fn test_com_mag_real() {
        let
            c = complex(5, 0);  // Real number
            mag = com_mag(c);
        in
            assert(mag == 5);
            true
    }

    fn test_com_mag_imaginary() {
        let
            c = complex(0, 12);  // Pure imaginary
            mag = com_mag(c);
        in
            assert(mag == 12);
            true
    }

    fn test_com_theta_zero() {
        let
            c = complex(1, 0);  // Positive real axis
            theta = com_theta(c);
        in
            // Angle should be 0 (or very close)
            assert(theta < 0.01);
            assert(theta > (0 - 0.01));
            true
    }

    fn test_com_theta_pi_over_2() {
        let
            c = complex(0, 1);  // Positive imaginary axis
            theta = com_theta(c);
        in
            // Angle should be π/2 ≈ 1.5708
            assert(theta > 1.5);
            assert(theta < 1.6);
            true
    }

    fn test_com_theta_pi() {
        let
            c = complex(0 - 1, 0);  // Negative real axis
            theta = com_theta(c);
        in
            // Angle should be π ≈ 3.1416 or -π
            // Could be either depending on atan2 implementation
            assert(theta > 3.0 or theta < (0 - 3.0));
            true
    }

            // Test comparisons of different numeric types
    fn test_compare_int_rational() {
        let
            i = 2;
            r = 5 / 2;  // 2.5
        in
            assert(i < r);
            assert(r > i);
            assert(not (i == r));
            true
    }

    fn test_compare_int_float() {
        let
            i = 3;
            f = 3.5;
        in
            assert(i < f);
            assert(f > i);
            assert(i <= f);
            true
    }

    fn test_compare_rational_float() {
        let
            r = 1 / 2;  // 0.5
            f = 0.75;
        in
            assert(r < f);
            assert(f > r);
            true
    }

    fn test_compare_bigint_int() {
        let
            big = 10000000000000000000;
            small = 999999999;
        in
            assert(big > small);
            assert(small < big);
            true
    }

    fn test_compare_bigint_rational() {
        let
            big = 1000000000000;
            r = 999999999999 / 2;
        in
            assert(big > r);
            assert(r < big);
            true
    }

    fn test_compare_bigint_float() {
        let
            big = 999999999999999;
            f = 123456.789;
        in
            assert(big > f);
            assert(f < big);
            true
    }

            // Test subtraction of different types
    fn test_subtract_int_rational() {
        let
            i = 5;
            r = 1 / 2;
            result = i - r;
        in
            // 5 - 1/2 = 9/2
            assert(result > 4);
            assert(result < 5);
            true
    }

    fn test_subtract_rational_int() {
        let
            r = 7 / 2;  // 3.5
            i = 2;
            result = r - i;
        in
            // 7/2 - 2 = 3/2
            assert(result > 1);
            assert(result < 2);
            true
    }

    fn test_subtract_float_int() {
        let
            f = 10.5;
            i = 3;
            result = f - i;
        in
            assert(result > 7.4);
            assert(result < 7.6);
            true
    }

    fn test_subtract_int_float() {
        let
            i = 20;
            f = 3.25;
            result = i - f;
        in
            assert(result > 16.7);
            assert(result < 16.8);
            true
    }

    fn test_subtract_rational_float() {
        let
            r = 3 / 4;  // 0.75
            f = 0.25;
            result = r - f;
        in
            assert(result > 0.4);
            assert(result < 0.6);
            true
    }

    fn test_subtract_bigint_int() {
        let
            big = 10000000000;
            i = 999999999;
            result = big - i;
        in
            assert(result > 9000000000);
            assert(result < 10000000000);
            true
    }

    fn test_subtract_bigint_float() {
        let
            big = 1000000000000;
            f = 0.5;
            result = big - f;
        in
            assert(result > 999999999999.0);
            assert(result < 1000000000000.0);
            true
    }

            // Test power operations (x ** y) with various type combinations
    fn test_power_int_int() {
        assert(2 ** 3 == 8);
        assert(5 ** 0 == 1);
        assert(10 ** 2 == 100);
        true
    }

    fn test_power_int_negative() {
        let
            result = 2 ** -3;
        in
            assert(result == 1/8);
            true
    }

    fn test_power_bigint_int() {
        let
            big = 100000000000;
            result = big ** 2;
        in
            // 10^11 ** 2 = 10^22
            assert(result == 10000000000000000000000);
            true
    }

    fn test_power_int_bigint() {
        let
            base = 2;
            exp = 100;  // Large exponent
            result = base ** exp;
        in
            // 2^100 is enormous
            assert(result > 1000000000000000000000000000000);
            true
    }

    fn test_power_float_int() {
        let
            result = 2.0 ** 3;
        in
            assert(result > 7.9);
            assert(result < 8.1);
            true
    }

    fn test_power_int_float() {
        let
            result = 4 ** 0.5;
        in
            // 4^0.5 = sqrt(4) = 2
            assert(result > 1.9);
            assert(result < 2.1);
            true
    }

    fn test_power_float_float() {
        let
            result = 2.5 ** 2.0;
        in
            // 2.5^2 = 6.25
            assert(result > 6.2);
            assert(result < 6.3);
            true
    }

    fn test_power_float_imaginary_float() {
        let
            result = 2.5 ** 2.0i;
        in
            assert(result > 0);
            assert(result < 6.3);
            true
    }

    fn test_power_rational_int() {
        let
            r = 3 / 2;  // 1.5
            result = r ** 2;
        in
            // (3/2)^2 = 9/4 = 2.25
            assert(result == 9/4);
    }

    fn test_power_int_rational() {
        let
            result = 8 ** (1 / 3);
        in
            // 8^(1/3) = cube root of 8 = 2
            assert(result == 2);
    }

    fn test_power_rational_rational() {
        let
            base = 4 / 1;
            exp = 1 / 2;
            result = base ** exp;
        in
            // 4^(1/2) = 2
            assert(result == 2);
            true
    }

    fn test_power_rational_float() {
        let
            r = 9 / 4;  // 2.25
            result = r ** 2.0;
        in
            // 2.25^2 ≈ 5.0625
            assert(result > 5.0);
            assert(result < 5.1);
    }

    fn test_power_float_rational() {
        let
            result = 16.0 ** (1 / 4);
        in
            // 16^(1/4) = fourth root of 16 = 2
            assert(result > 1.9);
            assert(result < 2.1);
    }

    fn test_power_complex_int() {
        let
            c = complex(0, 1);  // i
            result = c ** 2;
        in
            // i^2 = -1
            assert(result == -1);
    }

    fn test_power_complex_float() {
        let
            c = complex(1, 1);  // 1+i
            result = c ** 2.0;
        in
            // (1+i)^2 = 1 + 2i - 1 = 2i
            true  // Just test it doesn't crash
    }

    fn test_power_int_complex() {
        let
            c = complex(0, 1);  // i
            result = 2 ** c;
        in
            // 2^i = cos(ln(2)) + i*sin(ln(2))
            assert(true);
    }

    fn test_power_bigint_float() {
        let
            big = 1000000000;
            result = big ** 1.5;
        in
            // 10^9 ** 1.5 = 10^13.5 ≈ 31622776601684
            assert(result > 30000000000000.0);
            assert(result < 35000000000000.0);
            true
    }

    fn test_power_float_bigint() {
        let
            result = 1.5 ** 100;
        in
            // 1.5^100 is large but manageable
            assert(result > 1000000.0);
            true
    }

            // Edge cases
    fn test_power_zero_zero() {
        let
            result = 0 ** 0;
        in
            // Mathematically undefined, but often defined as 1 in programming
            assert(result == 1);
            true
    }

    fn test_power_negative_fractional() {
        let
            result = (0 - 8) ** (1 / 3);
        in
            // Cube root of -8 = -2
            // This might return complex number depending on implementation
            true  // Just test it doesn't crash
    }

in
    test_bigint_plus_float();
    test_float_plus_bigint();
    test_rational_plus_float();
    test_float_plus_rational();

    test_com_mag_simple();
    test_com_mag_zero();
    test_com_mag_real();
    test_com_mag_imaginary();

    test_com_theta_zero();
    test_com_theta_pi_over_2();
    test_com_theta_pi();

    test_compare_int_rational();
    test_compare_int_float();
    test_compare_rational_float();
    test_compare_bigint_int();
    test_compare_bigint_rational();
    test_compare_bigint_float();

    test_subtract_int_rational();
    test_subtract_rational_int();
    test_subtract_float_int();
    test_subtract_int_float();
    test_subtract_rational_float();
    test_subtract_bigint_int();
    test_subtract_bigint_float();

    test_power_int_int();
    test_power_int_negative();
    test_power_bigint_int();
    test_power_int_bigint();
    test_power_float_int();
    test_power_int_float();
    test_power_float_float();
    test_power_rational_int();
    test_power_int_rational();
    test_power_rational_rational();
    test_power_rational_float();
    test_power_float_rational();
    test_power_complex_int();
    test_power_complex_float();
    test_power_int_complex();
    test_power_bigint_float();
    test_power_float_bigint();

    test_power_zero_zero();
    test_power_negative_fractional();

    assert(0/2 == 0);
    assert(0/200000000000000000000000 == 0);
    assert(200_000_000_000_000_000_000/200_000_000_000_000_000_000 == 1);
    assert(200_000_000_000_000_000_000 > 1.0);

     test_power_float_imaginary_float();

    puts("All mixed-type arithmetic tests passed!\n")
