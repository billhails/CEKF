// Stress test for permutations of number operations
// Generates a list of all possible number types (positive.
// negative, zero, int, float, rational, complex) and applies
// all possible operations (+, -, *, /, %, **, <=>) between them,
// printing the results. This is mainly to test that no crashes
// or infinite loops occur when combining different number types.
let
    link "listutils.fn" as lst;
    import lst operators;

    fn genStdInts() {
        [4, 0, -4]
    }

    fn genBigInts() {
        [123456789012345678901234567890,
        -123456789012345678901234567890]
    }

    fn genInts() {
        genStdInts() @@ genBigInts()
    }

    fn genFloats() {
        [0.0, 1.5, -2.5]
    }

    fn nonzero(n) {
        com_real(n) != 0 and com_real(n) != 0.0
    }

    fn genRationals() {
        lst.concat(
            genInts() |? nonzero |> fn (numerator) {
                genInts() |? nonzero |> fn (denominator) {
                    numerator / denominator
                }
            }
        )
    }

    fn genReals() {
        genInts() @@ genFloats() @@ genRationals()
    }

    fn genComplex() {
        lst.concat(
            genReals() |> fn (real) {
                genReals() |> fn (imag) {
                    real + imag * 1i
                }
            }
        )
    }

    fn genNumbers() {
        genInts() @@ genFloats() @@ genRationals() @@ genComplex()
    }

    fn opAdd(n1, n2) {
        n1 + n2
    }
    fn opSub(n1, n2) {
        n1 - n2
    }
    fn opMul(n1, n2) {
        n1 * n2
    }
    fn opDiv(n1, n2) {
        n1 / n2
    }
    fn opMod(n1, n2) {
        if (nonzero(n2)) {
            if (com_imag(n1) != 0 and com_imag(n2) == 0) {
                0 // mod not defined for complex numbers
            } else {
                n1 % n2
            }
        } else {
            0
        }
    }
    fn opPow(n1, n2) {
        if (n2 > 100 or n2 < -100) {
            0 // avoid huge computations
        } else {
            n1 ** n2
        }
    }
    fn opCmp(n1, n2) {
        switch(n1 <=> n2) {
            (lt) { -1 }
            (eq) { 0 }
            (gt) { 1 }
        }
    }

    fn genOps() {
        [#(opAdd, "+"),
         #(opSub, "-"),
         #(opMul, "*"),
         #(opDiv, "/"),
         #(opMod, "%"),
         #(opPow, "**"),
         #(opCmp, "<=>")]
    }
in
    genNumbers() |> fn (n1) {
        genNumbers() |> fn (n2) {
            genOps() |> fn (#(op, opName)) {
                putn(n1);
                puts(" " @@ opName @@ " ");
                putn(n2);
                puts(" = ");
                putn(op(n1, n2));
                puts("\n");
                true
            }
        }
    }